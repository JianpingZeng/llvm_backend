Args: llc -march=x86-64 -mcpu=CSE502 -debug -O3 libc.c.bc -o libc.c.S 

Features:+64bit,+sse2,+64bit
CPU:CSE502

Subtarget features: SSELevel 3, 3DNowLevel 0, 64bit 1
PointerSize8
Computing probabilities for entry



=== llexit
5
is64bit 1
5 4 {ax}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
5 0x2105940
5 4 {ax}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
5 0x2105940
5 4 {di}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
5 0x2105940
0 5 {rcx}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x2105940
0 5 {r11}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x2105940
0 8 {memory}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x0
0 9 {dirflag}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x0
0 6 {fpsr}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x0
0 7 {flags}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x0
I've changed this to i64 from i16! Might break returns!Initial selection DAG: BB#0 'llexit:entry'
SelectionDAG has 21 nodes:
  0x2fbf468: ch = EntryToken [ORD=1]

  0x2fe5e50: i64 = Register %RAX [ORD=1]

    0x2fbf468: <multiple use>
    0x2fe5e50: <multiple use>
    0x2fe5950: i64 = Constant<60> [ORD=1]

  0x2fe5f50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5e50, 0x2fe5950 [ORD=1]

  0x2fe6050: i32 = TargetConstant<9> [ORD=1]

  0x2fe6150: i64 = Register %RDI [ORD=1]

    0x2fe5f50: <multiple use>
    0x2fe6150: <multiple use>
      0x2fbf468: <multiple use>
      0x2fe5750: i64 = Register %vreg0 [ORD=1]

    0x2fe5850: i64,ch = CopyFromReg 0x2fbf468, 0x2fe5750 [ORD=1]

    0x2fe5f50: <multiple use>
  0x2fe6250: ch,glue = CopyToReg 0x2fe5f50, 0x2fe6150, 0x2fe5850, 0x2fe5f50:1 [ORD=1]

  0x2fe6350: i32 = TargetConstant<12> [ORD=1]

    0x2fe6250: <multiple use>
    0x2fe5a50: i64 = TargetExternalSymbol'syscall' [ORD=1]

    0x2fe5b50: ch = MDNode<0x2f9f510> [ORD=1]

    0x2fe5c50: i64 = TargetConstant<1> [ORD=1]

    0x2fe5d50: i32 = TargetConstant<10> [ORD=1]

    0x2fe5e50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe5e50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe6150: <multiple use>
    0x2fe6350: <multiple use>
    0x2fe6450: i64 = Register %RCX [ORD=1]

    0x2fe6350: <multiple use>
    0x2fe6550: i64 = Register %R11 [ORD=1]

    0x2fe6350: <multiple use>
    0x2fe8dd0: i32 = Register %EFLAGS [ORD=1]

    0x2fe6250: <multiple use>
  0x2fe8ed0: ch,glue = inlineasm 0x2fe6250, 0x2fe5a50, 0x2fe5b50, 0x2fe5c50, 0x2fe5d50, 0x2fe5e50, 0x2fe6050, 0x2fe5e50, 0x2fe6050, 0x2fe6150, 0x2fe6350, 0x2fe6450, 0x2fe6350, 0x2fe6550, 0x2fe6350, 0x2fe8dd0, 0x2fe6250:1 [ORD=1]

      0x2fe8ed0: <multiple use>
      0x2fe5e50: <multiple use>
      0x2fe8ed0: <multiple use>
    0x2fe8fd0: i64,ch,glue = CopyFromReg 0x2fe8ed0, 0x2fe5e50, 0x2fe8ed0:1 [ORD=1]

    0x2fe90d0: i64 = TargetConstant<0>

  0x2fe91d0: ch = X86ISD::RET_FLAG 0x2fe8fd0:1, 0x2fe90d0


Optimized lowered selection DAG: BB#0 'llexit:entry'
SelectionDAG has 21 nodes:
  0x2fbf468: ch = EntryToken [ORD=1]

  0x2fe5e50: i64 = Register %RAX [ORD=1]

    0x2fbf468: <multiple use>
    0x2fe5e50: <multiple use>
    0x2fe5950: i64 = Constant<60> [ORD=1]

  0x2fe5f50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5e50, 0x2fe5950 [ORD=1]

  0x2fe6050: i32 = TargetConstant<9> [ORD=1]

  0x2fe6150: i64 = Register %RDI [ORD=1]

    0x2fe5f50: <multiple use>
    0x2fe6150: <multiple use>
      0x2fbf468: <multiple use>
      0x2fe5750: i64 = Register %vreg0 [ORD=1]

    0x2fe5850: i64,ch = CopyFromReg 0x2fbf468, 0x2fe5750 [ORD=1]

    0x2fe5f50: <multiple use>
  0x2fe6250: ch,glue = CopyToReg 0x2fe5f50, 0x2fe6150, 0x2fe5850, 0x2fe5f50:1 [ORD=1]

  0x2fe6350: i32 = TargetConstant<12> [ORD=1]

    0x2fe6250: <multiple use>
    0x2fe5a50: i64 = TargetExternalSymbol'syscall' [ORD=1]

    0x2fe5b50: ch = MDNode<0x2f9f510> [ORD=1]

    0x2fe5c50: i64 = TargetConstant<1> [ORD=1]

    0x2fe5d50: i32 = TargetConstant<10> [ORD=1]

    0x2fe5e50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe5e50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe6150: <multiple use>
    0x2fe6350: <multiple use>
    0x2fe6450: i64 = Register %RCX [ORD=1]

    0x2fe6350: <multiple use>
    0x2fe6550: i64 = Register %R11 [ORD=1]

    0x2fe6350: <multiple use>
    0x2fe8dd0: i32 = Register %EFLAGS [ORD=1]

    0x2fe6250: <multiple use>
  0x2fe8ed0: ch,glue = inlineasm 0x2fe6250, 0x2fe5a50, 0x2fe5b50, 0x2fe5c50, 0x2fe5d50, 0x2fe5e50, 0x2fe6050, 0x2fe5e50, 0x2fe6050, 0x2fe6150, 0x2fe6350, 0x2fe6450, 0x2fe6350, 0x2fe6550, 0x2fe6350, 0x2fe8dd0, 0x2fe6250:1 [ORD=1]

      0x2fe8ed0: <multiple use>
      0x2fe5e50: <multiple use>
      0x2fe8ed0: <multiple use>
    0x2fe8fd0: i64,ch,glue = CopyFromReg 0x2fe8ed0, 0x2fe5e50, 0x2fe8ed0:1 [ORD=1]

    0x2fe90d0: i64 = TargetConstant<0>

  0x2fe91d0: ch = X86ISD::RET_FLAG 0x2fe8fd0:1, 0x2fe90d0


Legally typed node: 0x2fe90d0: i64 = TargetConstant<0> [ID=0]

Promote integer result: 0x2fe8dd0: i32 = Register %EFLAGS [ORD=1] [ID=0]

In Custom Lowering 8 4 1
Replacing Node Results. Node has OpCode
85
Legally typed node: 0x2fe92d0: i64 = Register %EFLAGS [ID=0]

Legally typed node: 0x2fe6550: i64 = Register %R11 [ORD=1] [ID=0]

Legally typed node: 0x2fe6450: i64 = Register %RCX [ORD=1] [ID=0]

Legally typed node: 0x2fe6350: i32 = TargetConstant<12> [ORD=1] [ID=0]

Legally typed node: 0x2fe6150: i64 = Register %RDI [ORD=1] [ID=0]

Legally typed node: 0x2fe6050: i32 = TargetConstant<9> [ORD=1] [ID=0]

Legally typed node: 0x2fe5e50: i64 = Register %RAX [ORD=1] [ID=0]

Legally typed node: 0x2fe5d50: i32 = TargetConstant<10> [ORD=1] [ID=0]

Legally typed node: 0x2fe5c50: i64 = TargetConstant<1> [ORD=1] [ID=0]

Legally typed node: 0x2fe5b50: ch = MDNode<0x2f9f510> [ORD=1] [ID=0]

Legally typed node: 0x2fe5a50: i64 = TargetExternalSymbol'syscall' [ORD=1] [ID=0]

Legally typed node: 0x2fe5950: i64 = Constant<60> [ORD=1] [ID=0]

Legally typed node: 0x2fe5750: i64 = Register %vreg0 [ORD=1] [ID=0]

Legally typed node: 0x2fbf468: ch = EntryToken [ORD=1] [ID=0]

Legally typed node: 0x2fe5850: i64,ch = CopyFromReg 0x2fbf468, 0x2fe5750 [ORD=1] [ID=0]

Legally typed node: 0x2fe5f50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5e50, 0x2fe5950 [ORD=1] [ID=0]

Legally typed node: 0x2fe6250: ch,glue = CopyToReg 0x2fe5f50, 0x2fe6150, 0x2fe5850, 0x2fe5f50:1 [ORD=1] [ID=0]

Legally typed node: 0x2fe8ed0: ch,glue = inlineasm 0x2fe6250, 0x2fe5a50, 0x2fe5b50, 0x2fe5c50, 0x2fe5d50, 0x2fe5e50, 0x2fe6050, 0x2fe5e50, 0x2fe6050, 0x2fe6150, 0x2fe6350, 0x2fe6450, 0x2fe6350, 0x2fe6550, 0x2fe6350, 0x2fe92d0, 0x2fe6250:1 [ORD=1] [ID=0]

Legally typed node: 0x2fe8fd0: i64,ch,glue = CopyFromReg 0x2fe8ed0, 0x2fe5e50, 0x2fe8ed0:1 [ORD=1] [ID=0]

Legally typed node: 0x2fe91d0: ch = X86ISD::RET_FLAG 0x2fe8fd0:1, 0x2fe90d0 [ID=0]

Legally typed node: 0x7fff8d52a470: ch = handlenode 0x2fe91d0 [ID=0]

Type-legalized selection DAG: BB#0 'llexit:entry'
SelectionDAG has 21 nodes:
  0x2fbf468: ch = EntryToken [ORD=1] [ID=-3]

  0x2fe5e50: i64 = Register %RAX [ORD=1] [ID=-3]

    0x2fbf468: <multiple use>
    0x2fe5e50: <multiple use>
    0x2fe5950: i64 = Constant<60> [ORD=1] [ID=-3]

  0x2fe5f50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5e50, 0x2fe5950 [ORD=1] [ID=-3]

  0x2fe6050: i32 = TargetConstant<9> [ORD=1] [ID=-3]

  0x2fe6150: i64 = Register %RDI [ORD=1] [ID=-3]

    0x2fe5f50: <multiple use>
    0x2fe6150: <multiple use>
      0x2fbf468: <multiple use>
      0x2fe5750: i64 = Register %vreg0 [ORD=1] [ID=-3]

    0x2fe5850: i64,ch = CopyFromReg 0x2fbf468, 0x2fe5750 [ORD=1] [ID=-3]

    0x2fe5f50: <multiple use>
  0x2fe6250: ch,glue = CopyToReg 0x2fe5f50, 0x2fe6150, 0x2fe5850, 0x2fe5f50:1 [ORD=1] [ID=-3]

  0x2fe6350: i32 = TargetConstant<12> [ORD=1] [ID=-3]

    0x2fe6250: <multiple use>
    0x2fe5a50: i64 = TargetExternalSymbol'syscall' [ORD=1] [ID=-3]

    0x2fe5b50: ch = MDNode<0x2f9f510> [ORD=1] [ID=-3]

    0x2fe5c50: i64 = TargetConstant<1> [ORD=1] [ID=-3]

    0x2fe5d50: i32 = TargetConstant<10> [ORD=1] [ID=-3]

    0x2fe5e50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe5e50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe6150: <multiple use>
    0x2fe6350: <multiple use>
    0x2fe6450: i64 = Register %RCX [ORD=1] [ID=-3]

    0x2fe6350: <multiple use>
    0x2fe6550: i64 = Register %R11 [ORD=1] [ID=-3]

    0x2fe6350: <multiple use>
    0x2fe92d0: i64 = Register %EFLAGS [ID=-3]

    0x2fe6250: <multiple use>
  0x2fe8ed0: ch,glue = inlineasm 0x2fe6250, 0x2fe5a50, 0x2fe5b50, 0x2fe5c50, 0x2fe5d50, 0x2fe5e50, 0x2fe6050, 0x2fe5e50, 0x2fe6050, 0x2fe6150, 0x2fe6350, 0x2fe6450, 0x2fe6350, 0x2fe6550, 0x2fe6350, 0x2fe92d0, 0x2fe6250:1 [ORD=1] [ID=-3]

      0x2fe8ed0: <multiple use>
      0x2fe5e50: <multiple use>
      0x2fe8ed0: <multiple use>
    0x2fe8fd0: i64,ch,glue = CopyFromReg 0x2fe8ed0, 0x2fe5e50, 0x2fe8ed0:1 [ORD=1] [ID=-3]

    0x2fe90d0: i64 = TargetConstant<0> [ID=-3]

  0x2fe91d0: ch = X86ISD::RET_FLAG 0x2fe8fd0:1, 0x2fe90d0 [ID=-3]


Optimized type-legalized selection DAG: BB#0 'llexit:entry'
SelectionDAG has 21 nodes:
  0x2fbf468: ch = EntryToken [ORD=1] [ID=-3]

  0x2fe5e50: i64 = Register %RAX [ORD=1] [ID=-3]

    0x2fbf468: <multiple use>
    0x2fe5e50: <multiple use>
    0x2fe5950: i64 = Constant<60> [ORD=1] [ID=-3]

  0x2fe5f50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5e50, 0x2fe5950 [ORD=1] [ID=-3]

  0x2fe6050: i32 = TargetConstant<9> [ORD=1] [ID=-3]

  0x2fe6150: i64 = Register %RDI [ORD=1] [ID=-3]

    0x2fe5f50: <multiple use>
    0x2fe6150: <multiple use>
      0x2fbf468: <multiple use>
      0x2fe5750: i64 = Register %vreg0 [ORD=1] [ID=-3]

    0x2fe5850: i64,ch = CopyFromReg 0x2fbf468, 0x2fe5750 [ORD=1] [ID=-3]

    0x2fe5f50: <multiple use>
  0x2fe6250: ch,glue = CopyToReg 0x2fe5f50, 0x2fe6150, 0x2fe5850, 0x2fe5f50:1 [ORD=1] [ID=-3]

  0x2fe6350: i32 = TargetConstant<12> [ORD=1] [ID=-3]

    0x2fe6250: <multiple use>
    0x2fe5a50: i64 = TargetExternalSymbol'syscall' [ORD=1] [ID=-3]

    0x2fe5b50: ch = MDNode<0x2f9f510> [ORD=1] [ID=-3]

    0x2fe5c50: i64 = TargetConstant<1> [ORD=1] [ID=-3]

    0x2fe5d50: i32 = TargetConstant<10> [ORD=1] [ID=-3]

    0x2fe5e50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe5e50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe6150: <multiple use>
    0x2fe6350: <multiple use>
    0x2fe6450: i64 = Register %RCX [ORD=1] [ID=-3]

    0x2fe6350: <multiple use>
    0x2fe6550: i64 = Register %R11 [ORD=1] [ID=-3]

    0x2fe6350: <multiple use>
    0x2fe92d0: i64 = Register %EFLAGS [ID=-3]

    0x2fe6250: <multiple use>
  0x2fe8ed0: ch,glue = inlineasm 0x2fe6250, 0x2fe5a50, 0x2fe5b50, 0x2fe5c50, 0x2fe5d50, 0x2fe5e50, 0x2fe6050, 0x2fe5e50, 0x2fe6050, 0x2fe6150, 0x2fe6350, 0x2fe6450, 0x2fe6350, 0x2fe6550, 0x2fe6350, 0x2fe92d0, 0x2fe6250:1 [ORD=1] [ID=-3]

      0x2fe8ed0: <multiple use>
      0x2fe5e50: <multiple use>
      0x2fe8ed0: <multiple use>
    0x2fe8fd0: i64,ch,glue = CopyFromReg 0x2fe8ed0, 0x2fe5e50, 0x2fe8ed0:1 [ORD=1] [ID=-3]

    0x2fe90d0: i64 = TargetConstant<0> [ID=-3]

  0x2fe91d0: ch = X86ISD::RET_FLAG 0x2fe8fd0:1, 0x2fe90d0 [ID=-3]


In LegalizeDAG() 211
In legalize Op211
0
0
5
In LegalizeDAG() 43
In legalize Op43
5
0
50
0
5
50
In LegalizeDAG() 151
In legalize Op151
0
50
0
5
0
5
4
5
4
5
4
5
4
5
4
5
4
5
50
In LegalizeDAG() 42
In legalize Op42
0
50
0
5
5
50
In LegalizeDAG() 42
In legalize Op42
0
50
0
5
5
In LegalizeDAG() 43
In legalize Op43
5
0
0
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 29
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 29
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 29
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 29
In LegalizeDAG() 29
In LegalizeDAG() 162
In legalize Op162
0
In LegalizeDAG() 36
In legalize Op36
5
In LegalizeDAG() 10
In legalize Op10
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 1
In legalize Op1
0
Legalized selection DAG: BB#0 'llexit:entry'
SelectionDAG has 21 nodes:
  0x2fbf468: ch = EntryToken [ORD=1] [ID=0]

  0x2fe5e50: i64 = Register %RAX [ORD=1] [ID=7]

  0x2fe6050: i32 = TargetConstant<9> [ORD=1] [ID=8]

  0x2fe6150: i64 = Register %RDI [ORD=1] [ID=9]

  0x2fe6350: i32 = TargetConstant<12> [ORD=1] [ID=10]

    0x2fbf468: <multiple use>
    0x2fe5e50: <multiple use>
    0x2fe5950: i64 = Constant<60> [ORD=1] [ID=2]

  0x2fe5f50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5e50, 0x2fe5950 [ORD=1] [ID=16]

    0x2fe5f50: <multiple use>
    0x2fe6150: <multiple use>
      0x2fbf468: <multiple use>
      0x2fe5750: i64 = Register %vreg0 [ORD=1] [ID=1]

    0x2fe5850: i64,ch = CopyFromReg 0x2fbf468, 0x2fe5750 [ORD=1] [ID=15]

    0x2fe5f50: <multiple use>
  0x2fe6250: ch,glue = CopyToReg 0x2fe5f50, 0x2fe6150, 0x2fe5850, 0x2fe5f50:1 [ORD=1] [ID=17]

    0x2fe6250: <multiple use>
    0x2fe5a50: i64 = TargetExternalSymbol'syscall' [ORD=1] [ID=3]

    0x2fe5b50: ch = MDNode<0x2f9f510> [ORD=1] [ID=4]

    0x2fe5c50: i64 = TargetConstant<1> [ORD=1] [ID=5]

    0x2fe5d50: i32 = TargetConstant<10> [ORD=1] [ID=6]

    0x2fe5e50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe5e50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe6150: <multiple use>
    0x2fe6350: <multiple use>
    0x2fe6450: i64 = Register %RCX [ORD=1] [ID=11]

    0x2fe6350: <multiple use>
    0x2fe6550: i64 = Register %R11 [ORD=1] [ID=12]

    0x2fe6350: <multiple use>
    0x2fe92d0: i64 = Register %EFLAGS [ID=14]

    0x2fe6250: <multiple use>
  0x2fe8ed0: ch,glue = inlineasm 0x2fe6250, 0x2fe5a50, 0x2fe5b50, 0x2fe5c50, 0x2fe5d50, 0x2fe5e50, 0x2fe6050, 0x2fe5e50, 0x2fe6050, 0x2fe6150, 0x2fe6350, 0x2fe6450, 0x2fe6350, 0x2fe6550, 0x2fe6350, 0x2fe92d0, 0x2fe6250:1 [ORD=1] [ID=18]

      0x2fe8ed0: <multiple use>
      0x2fe5e50: <multiple use>
      0x2fe8ed0: <multiple use>
    0x2fe8fd0: i64,ch,glue = CopyFromReg 0x2fe8ed0, 0x2fe5e50, 0x2fe8ed0:1 [ORD=1] [ID=19]

    0x2fe90d0: i64 = TargetConstant<0> [ID=13]

  0x2fe91d0: ch = X86ISD::RET_FLAG 0x2fe8fd0:1, 0x2fe90d0 [ID=20]


Optimized legalized selection DAG: BB#0 'llexit:entry'
SelectionDAG has 21 nodes:
  0x2fbf468: ch = EntryToken [ORD=1] [ID=0]

  0x2fe5e50: i64 = Register %RAX [ORD=1] [ID=7]

  0x2fe6050: i32 = TargetConstant<9> [ORD=1] [ID=8]

  0x2fe6150: i64 = Register %RDI [ORD=1] [ID=9]

  0x2fe6350: i32 = TargetConstant<12> [ORD=1] [ID=10]

    0x2fbf468: <multiple use>
    0x2fe5e50: <multiple use>
    0x2fe5950: i64 = Constant<60> [ORD=1] [ID=2]

  0x2fe5f50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5e50, 0x2fe5950 [ORD=1] [ID=16]

    0x2fe5f50: <multiple use>
    0x2fe6150: <multiple use>
      0x2fbf468: <multiple use>
      0x2fe5750: i64 = Register %vreg0 [ORD=1] [ID=1]

    0x2fe5850: i64,ch = CopyFromReg 0x2fbf468, 0x2fe5750 [ORD=1] [ID=15]

    0x2fe5f50: <multiple use>
  0x2fe6250: ch,glue = CopyToReg 0x2fe5f50, 0x2fe6150, 0x2fe5850, 0x2fe5f50:1 [ORD=1] [ID=17]

    0x2fe6250: <multiple use>
    0x2fe5a50: i64 = TargetExternalSymbol'syscall' [ORD=1] [ID=3]

    0x2fe5b50: ch = MDNode<0x2f9f510> [ORD=1] [ID=4]

    0x2fe5c50: i64 = TargetConstant<1> [ORD=1] [ID=5]

    0x2fe5d50: i32 = TargetConstant<10> [ORD=1] [ID=6]

    0x2fe5e50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe5e50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe6150: <multiple use>
    0x2fe6350: <multiple use>
    0x2fe6450: i64 = Register %RCX [ORD=1] [ID=11]

    0x2fe6350: <multiple use>
    0x2fe6550: i64 = Register %R11 [ORD=1] [ID=12]

    0x2fe6350: <multiple use>
    0x2fe92d0: i64 = Register %EFLAGS [ID=14]

    0x2fe6250: <multiple use>
  0x2fe8ed0: ch,glue = inlineasm 0x2fe6250, 0x2fe5a50, 0x2fe5b50, 0x2fe5c50, 0x2fe5d50, 0x2fe5e50, 0x2fe6050, 0x2fe5e50, 0x2fe6050, 0x2fe6150, 0x2fe6350, 0x2fe6450, 0x2fe6350, 0x2fe6550, 0x2fe6350, 0x2fe92d0, 0x2fe6250:1 [ORD=1] [ID=18]

      0x2fe8ed0: <multiple use>
      0x2fe5e50: <multiple use>
      0x2fe8ed0: <multiple use>
    0x2fe8fd0: i64,ch,glue = CopyFromReg 0x2fe8ed0, 0x2fe5e50, 0x2fe8ed0:1 [ORD=1] [ID=19]

    0x2fe90d0: i64 = TargetConstant<0> [ID=13]

  0x2fe91d0: ch = X86ISD::RET_FLAG 0x2fe8fd0:1, 0x2fe90d0 [ID=20]


===== Instruction selection begins: BB#0 'entry'
Selecting: 0x2fe91d0: ch = X86ISD::RET_FLAG 0x2fe8fd0:1, 0x2fe90d0 [ID=20]

ISEL: Starting pattern match on root node: 0x2fe91d0: ch = X86ISD::RET_FLAG 0x2fe8fd0:1, 0x2fe90d0 [ID=20]

  Morphed node: 0x2fe91d0: ch = RET 0x2fe8fd0:1

ISEL: Match complete!
=> 0x2fe91d0: ch = RET 0x2fe8fd0:1

Selecting: 0x2fe8fd0: i64,ch,glue = CopyFromReg 0x2fe8ed0, 0x2fe5e50, 0x2fe8ed0:1 [ORD=1] [ID=19]

=> 0x2fe8fd0: i64,ch,glue = CopyFromReg 0x2fe8ed0, 0x2fe5e50, 0x2fe8ed0:1 [ORD=1]

Selecting: 0x2fe8ed0: ch,glue = inlineasm 0x2fe6250, 0x2fe5a50, 0x2fe5b50, 0x2fe5c50, 0x2fe5d50, 0x2fe5e50, 0x2fe6050, 0x2fe5e50, 0x2fe6050, 0x2fe6150, 0x2fe6350, 0x2fe6450, 0x2fe6350, 0x2fe6550, 0x2fe6350, 0x2fe92d0, 0x2fe6250:1 [ORD=1] [ID=18]

=> 0x2fe90d0: ch,glue = inlineasm 0x2fe6250, 0x2fe5a50, 0x2fe5b50, 0x2fe5c50, 0x2fe5d50, 0x2fe5e50, 0x2fe6050, 0x2fe5e50, 0x2fe6050, 0x2fe6150, 0x2fe6350, 0x2fe6450, 0x2fe6350, 0x2fe6550, 0x2fe6350, 0x2fe92d0, 0x2fe6250:1

Selecting: 0x2fe6250: ch,glue = CopyToReg 0x2fe5f50, 0x2fe6150, 0x2fe5850, 0x2fe5f50:1 [ORD=1] [ID=17]

=> 0x2fe6250: ch,glue = CopyToReg 0x2fe5f50, 0x2fe6150, 0x2fe5850, 0x2fe5f50:1 [ORD=1]

Selecting: 0x2fe5f50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5e50, 0x2fe5950 [ORD=1] [ID=16]

=> 0x2fe5f50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5e50, 0x2fe5950 [ORD=1]

Selecting: 0x2fe5850: i64,ch = CopyFromReg 0x2fbf468, 0x2fe5750 [ORD=1] [ID=15]

=> 0x2fe5850: i64,ch = CopyFromReg 0x2fbf468, 0x2fe5750 [ORD=1]

Selecting: 0x2fe92d0: i64 = Register %EFLAGS [ID=14]

=> 0x2fe92d0: i64 = Register %EFLAGS

Selecting: 0x2fe6550: i64 = Register %R11 [ORD=1] [ID=12]

=> 0x2fe6550: i64 = Register %R11 [ORD=1]

Selecting: 0x2fe6450: i64 = Register %RCX [ORD=1] [ID=11]

=> 0x2fe6450: i64 = Register %RCX [ORD=1]

Selecting: 0x2fe6350: i32 = TargetConstant<12> [ORD=1] [ID=10]

=> 0x2fe6350: i32 = TargetConstant<12> [ORD=1]

Selecting: 0x2fe6150: i64 = Register %RDI [ORD=1] [ID=9]

=> 0x2fe6150: i64 = Register %RDI [ORD=1]

Selecting: 0x2fe6050: i32 = TargetConstant<9> [ORD=1] [ID=8]

=> 0x2fe6050: i32 = TargetConstant<9> [ORD=1]

Selecting: 0x2fe5e50: i64 = Register %RAX [ORD=1] [ID=7]

=> 0x2fe5e50: i64 = Register %RAX [ORD=1]

Selecting: 0x2fe5d50: i32 = TargetConstant<10> [ORD=1] [ID=6]

=> 0x2fe5d50: i32 = TargetConstant<10> [ORD=1]

Selecting: 0x2fe5c50: i64 = TargetConstant<1> [ORD=1] [ID=5]

=> 0x2fe5c50: i64 = TargetConstant<1> [ORD=1]

Selecting: 0x2fe5b50: ch = MDNode<0x2f9f510> [ORD=1] [ID=4]

=> 0x2fe5b50: ch = MDNode<0x2f9f510> [ORD=1]

Selecting: 0x2fe5a50: i64 = TargetExternalSymbol'syscall' [ORD=1] [ID=3]

=> 0x2fe5a50: i64 = TargetExternalSymbol'syscall' [ORD=1]

Selecting: 0x2fe5950: i64 = Constant<60> [ORD=1] [ID=2]

ISEL: Starting pattern match on root node: 0x2fe5950: i64 = Constant<60> [ORD=1] [ID=2]

  Initial Opcode index to 83167
  Skipped scope entry (due to false predicate) at index 83169, continuing at 83219
  TypeSwitch[i64] from 83221 to 83224
  Morphed node: 0x2fe5950: i64 = MOV64ri64i32 0x2fe8ed0 [ORD=1]

ISEL: Match complete!
=> 0x2fe5950: i64 = MOV64ri64i32 0x2fe8ed0 [ORD=1]

Selecting: 0x2fe5750: i64 = Register %vreg0 [ORD=1] [ID=1]

=> 0x2fe5750: i64 = Register %vreg0 [ORD=1]

Selecting: 0x2fbf468: ch = EntryToken [ORD=1] [ID=0]

=> 0x2fbf468: ch = EntryToken [ORD=1]

===== Instruction selection ends:
Selected selection DAG: BB#0 'llexit:entry'
SelectionDAG has 21 nodes:
  0x2fbf468: ch = EntryToken [ORD=1]

  0x2fe5e50: i64 = Register %RAX [ORD=1]

  0x2fe6050: i32 = TargetConstant<9> [ORD=1]

  0x2fe6150: i64 = Register %RDI [ORD=1]

  0x2fe6350: i32 = TargetConstant<12> [ORD=1]

    0x2fbf468: <multiple use>
    0x2fe5e50: <multiple use>
      0x2fe8ed0: i64 = TargetConstant<60>

    0x2fe5950: i64 = MOV64ri64i32 0x2fe8ed0 [ORD=1]

  0x2fe5f50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5e50, 0x2fe5950 [ORD=1]

    0x2fe5f50: <multiple use>
    0x2fe6150: <multiple use>
      0x2fbf468: <multiple use>
      0x2fe5750: i64 = Register %vreg0 [ORD=1]

    0x2fe5850: i64,ch = CopyFromReg 0x2fbf468, 0x2fe5750 [ORD=1]

    0x2fe5f50: <multiple use>
  0x2fe6250: ch,glue = CopyToReg 0x2fe5f50, 0x2fe6150, 0x2fe5850, 0x2fe5f50:1 [ORD=1]

    0x2fe6250: <multiple use>
    0x2fe5a50: i64 = TargetExternalSymbol'syscall' [ORD=1]

    0x2fe5b50: ch = MDNode<0x2f9f510> [ORD=1]

    0x2fe5c50: i64 = TargetConstant<1> [ORD=1]

    0x2fe5d50: i32 = TargetConstant<10> [ORD=1]

    0x2fe5e50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe5e50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe6150: <multiple use>
    0x2fe6350: <multiple use>
    0x2fe6450: i64 = Register %RCX [ORD=1]

    0x2fe6350: <multiple use>
    0x2fe6550: i64 = Register %R11 [ORD=1]

    0x2fe6350: <multiple use>
    0x2fe92d0: i64 = Register %EFLAGS

    0x2fe6250: <multiple use>
  0x2fe90d0: ch,glue = inlineasm 0x2fe6250, 0x2fe5a50, 0x2fe5b50, 0x2fe5c50, 0x2fe5d50, 0x2fe5e50, 0x2fe6050, 0x2fe5e50, 0x2fe6050, 0x2fe6150, 0x2fe6350, 0x2fe6450, 0x2fe6350, 0x2fe6550, 0x2fe6350, 0x2fe92d0, 0x2fe6250:1

      0x2fe90d0: <multiple use>
      0x2fe5e50: <multiple use>
      0x2fe90d0: <multiple use>
    0x2fe8fd0: i64,ch,glue = CopyFromReg 0x2fe90d0, 0x2fe5e50, 0x2fe90d0:1 [ORD=1]

  0x2fe91d0: ch = RET 0x2fe8fd0:1


********** List Scheduling BB#0 'entry' **********
SU(0): 0x2fe91d0: ch = RET 0x2fe8fd0:1 [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x2fe8fd0: i64,ch,glue = CopyFromReg 0x2fe90d0, 0x2fe5e50, 0x2fe90d0:1 [ORD=1] [ID=1]

    0x2fe5f50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5e50, 0x2fe5950 [ORD=1] [ID=1]

    0x2fe6250: ch,glue = CopyToReg 0x2fe5f50, 0x2fe6150, 0x2fe5850, 0x2fe5f50:1 [ORD=1] [ID=1]

    0x2fe90d0: ch,glue = inlineasm 0x2fe6250, 0x2fe5a50, 0x2fe5b50, 0x2fe5c50, 0x2fe5d50, 0x2fe5e50, 0x2fe6050, 0x2fe5e50, 0x2fe6050, 0x2fe6150, 0x2fe6350, 0x2fe6450, 0x2fe6350, 0x2fe6550, 0x2fe6350, 0x2fe92d0, 0x2fe6250:1 [ID=1]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(2): Latency=1
   val SU(3): Latency=1
  Successors:
   ch  SU(0): Latency=1

SU(2): 0x2fe5850: i64,ch = CopyFromReg 0x2fbf468, 0x2fe5750 [ORD=1] [ID=2]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
   val SU(1): Latency=1

SU(3): 0x2fe5950: i64 = MOV64ri64i32 0x2fe8ed0 [ORD=1] [ID=3]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
   val SU(1): Latency=1


Examining Available:
Height 0: SU(0): 0x2fe91d0: ch = RET 0x2fe8fd0:1 [ID=0]


*** Scheduling [0]: SU(0): 0x2fe91d0: ch = RET 0x2fe8fd0:1 [ID=0]


Examining Available:
Height 1: SU(1): 0x2fe8fd0: i64,ch,glue = CopyFromReg 0x2fe90d0, 0x2fe5e50, 0x2fe90d0:1 [ORD=1] [ID=1]

    0x2fe5f50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5e50, 0x2fe5950 [ORD=1] [ID=1]

    0x2fe6250: ch,glue = CopyToReg 0x2fe5f50, 0x2fe6150, 0x2fe5850, 0x2fe5f50:1 [ORD=1] [ID=1]

    0x2fe90d0: ch,glue = inlineasm 0x2fe6250, 0x2fe5a50, 0x2fe5b50, 0x2fe5c50, 0x2fe5d50, 0x2fe5e50, 0x2fe6050, 0x2fe5e50, 0x2fe6050, 0x2fe6150, 0x2fe6350, 0x2fe6450, 0x2fe6350, 0x2fe6550, 0x2fe6350, 0x2fe92d0, 0x2fe6250:1 [ID=1]


*** Scheduling [1]: SU(1): 0x2fe8fd0: i64,ch,glue = CopyFromReg 0x2fe90d0, 0x2fe5e50, 0x2fe90d0:1 [ORD=1] [ID=1]

    0x2fe5f50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5e50, 0x2fe5950 [ORD=1] [ID=1]

    0x2fe6250: ch,glue = CopyToReg 0x2fe5f50, 0x2fe6150, 0x2fe5850, 0x2fe5f50:1 [ORD=1] [ID=1]

    0x2fe90d0: ch,glue = inlineasm 0x2fe6250, 0x2fe5a50, 0x2fe5b50, 0x2fe5c50, 0x2fe5d50, 0x2fe5e50, 0x2fe6050, 0x2fe5e50, 0x2fe6050, 0x2fe6150, 0x2fe6350, 0x2fe6450, 0x2fe6350, 0x2fe6550, 0x2fe6350, 0x2fe92d0, 0x2fe6250:1 [ID=1]

GR64: 2 / 12

Examining Available:
Height 2: SU(2): 0x2fe5850: i64,ch = CopyFromReg 0x2fbf468, 0x2fe5750 [ORD=1] [ID=2]

Height 2: SU(3): 0x2fe5950: i64 = MOV64ri64i32 0x2fe8ed0 [ORD=1] [ID=3]


*** Scheduling [2]: SU(2): 0x2fe5850: i64,ch = CopyFromReg 0x2fbf468, 0x2fe5750 [ORD=1] [ID=2]

GR64: 1 / 12

Examining Available:
Height 2: SU(3): 0x2fe5950: i64 = MOV64ri64i32 0x2fe8ed0 [ORD=1] [ID=3]


*** Scheduling [3]: SU(3): 0x2fe5950: i64 = MOV64ri64i32 0x2fe8ed0 [ORD=1] [ID=3]

*** Final schedule ***
SU(3): 0x2fe5950: i64 = MOV64ri64i32 0x2fe8ed0 [ORD=1] [ID=3]

SU(2): 0x2fe5850: i64,ch = CopyFromReg 0x2fbf468, 0x2fe5750 [ORD=1] [ID=2]

SU(1): 0x2fe8fd0: i64,ch,glue = CopyFromReg 0x2fe90d0, 0x2fe5e50, 0x2fe90d0:1 [ORD=1] [ID=1]

    0x2fe5f50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5e50, 0x2fe5950 [ORD=1] [ID=1]

    0x2fe6250: ch,glue = CopyToReg 0x2fe5f50, 0x2fe6150, 0x2fe5850, 0x2fe5f50:1 [ORD=1] [ID=1]

    0x2fe90d0: ch,glue = inlineasm 0x2fe6250, 0x2fe5a50, 0x2fe5b50, 0x2fe5c50, 0x2fe5d50, 0x2fe5e50, 0x2fe6050, 0x2fe5e50, 0x2fe6050, 0x2fe6150, 0x2fe6350, 0x2fe6450, 0x2fe6350, 0x2fe6550, 0x2fe6350, 0x2fe92d0, 0x2fe6250:1 [ID=1]

SU(0): 0x2fe91d0: ch = RET 0x2fe8fd0:1 [ID=0]


TADA
Total amount of phi nodes to update: 0
# Machine code for function llexit: SSA
Function Live Ins: %RDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg0<def> = COPY %RDI; GR64:%vreg0
32B		%vreg1<def> = MOV64ri64i32 60; GR64:%vreg1
48B		%RAX<def> = COPY %vreg1; GR64:%vreg1
64B		%RDI<def> = COPY %vreg0; GR64:%vreg0
80B		INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def>, $1:[reguse], %RAX, $2:[reguse], %RDI, $3:[clobber], %RCX<earlyclobber,imp-def>, $4:[clobber], %R11<earlyclobber,imp-def>, $5:[clobber], %EFLAGS<earlyclobber,imp-def>, <<badref>>
96B		%vreg2<def> = COPY %RAX; GR64:%vreg2
112B		RET

# End machine code for function llexit.

********** Stack Coloring **********
********** Function: llexit
DeadMachineInstructionElim: DELETING: %vreg2<def> = COPY %RAX; GR64:%vreg2
******** Pre-regalloc Machine LICM: llexit ********
Entering: entry
Exiting: entry
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: llexit
********** PROCESS IMPLICIT DEFS **********
********** Function: llexit
********** REWRITING TWO-ADDR INSTRS **********
********** Function: llexit
# Machine code for function llexit: Post SSA
Function Live Ins: %RDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg0<def> = COPY %RDI<kill>; GR64:%vreg0
32B		%vreg1<def> = MOV64ri64i32 60; GR64:%vreg1
48B		%RAX<def> = COPY %vreg1<kill>; GR64:%vreg1
64B		%RDI<def> = COPY %vreg0<kill>; GR64:%vreg0
80B		INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def,dead>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI<kill>, $3:[clobber], %RCX<earlyclobber,imp-def,dead>, $4:[clobber], %R11<earlyclobber,imp-def,dead>, $5:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
96B		RET

# End machine code for function llexit.

********** COMPUTING LIVE INTERVALS **********
********** Function: llexit
BB#0:		# derived from entry
16B	%vreg0<def> = COPY %RDI<kill>; GR64:%vreg0
		register: %vreg0 +[16r,64r:0)
32B	%vreg1<def> = MOV64ri64i32 60; GR64:%vreg1
		register: %vreg1 +[32r,48r:0)
48B	%RAX<def> = COPY %vreg1<kill>; GR64:%vreg1
64B	%RDI<def> = COPY %vreg0<kill>; GR64:%vreg0
80B	INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def,dead>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI<kill>, $3:[clobber], %RCX<earlyclobber,imp-def,dead>, $4:[clobber], %R11<earlyclobber,imp-def,dead>, $5:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
96B	RET
Computing live-in reg-units in ABI blocks.
0B	BB#0 DIL#0
Created 1 new intervals.
********** INTERVALS **********
DIL = [0B,16r:0)[64r,80r:1)  0@0B-phi 1@64r
%vreg0 = [16r,64r:0)  0@16r
%vreg1 = [32r,48r:0)  0@32r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function llexit: Post SSA
Function Live Ins: %RDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg0<def> = COPY %RDI; GR64:%vreg0
32B		%vreg1<def> = MOV64ri64i32 60; GR64:%vreg1
48B		%RAX<def> = COPY %vreg1<kill>; GR64:%vreg1
64B		%RDI<def> = COPY %vreg0<kill>; GR64:%vreg0
80B		INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def,dead>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI, $3:[clobber], %RCX<earlyclobber,imp-def,dead>, $4:[clobber], %R11<earlyclobber,imp-def,dead>, $5:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
96B		RET

# End machine code for function llexit.

********** COMPUTING LIVE DEBUG VARIABLES: llexit **********
********** DEBUG VARIABLES **********
********** SIMPLE REGISTER COALESCING **********
********** Function: llexit
********** JOINING INTERVALS ***********
entry:
16B	%vreg0<def> = COPY %RDI; GR64:%vreg0
	Considering merging %vreg0 with %RDI
	Can only merge into reserved registers.
48B	%RAX<def> = COPY %vreg1<kill>; GR64:%vreg1
	Considering merging %vreg1 with %RAX
	Can only merge into reserved registers.
Remat: %RAX<def> = MOV64ri64i32 60
Shrink: [32r,48r:0)  0@32r
All defs dead: 32r	%vreg1<def,dead> = MOV64ri64i32 60; GR64:%vreg1
Shrunk: [32r,32d:0)  0@32r
Deleting dead def 32r	%vreg1<def,dead> = MOV64ri64i32 60; GR64:%vreg1
64B	%RDI<def> = COPY %vreg0<kill>; GR64:%vreg0
	Considering merging %vreg0 with %RDI
	Can only merge into reserved registers.
Trying to inflate 0 regs.
********** INTERVALS **********
DIL = [0B,16r:0)[64r,80r:1)  0@0B-phi 1@64r
%vreg0 = [16r,64r:0)  0@16r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function llexit: Post SSA
Function Live Ins: %RDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg0<def> = COPY %RDI; GR64:%vreg0
48B		%RAX<def> = MOV64ri64i32 60
64B		%RDI<def> = COPY %vreg0<kill>; GR64:%vreg0
80B		INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def,dead>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI, $3:[clobber], %RCX<earlyclobber,imp-def,dead>, $4:[clobber], %R11<earlyclobber,imp-def,dead>, $5:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
96B		RET

# End machine code for function llexit.

********** DEBUG VARIABLES **********
********** Compute Spill Weights **********
********** Function: llexit
********** GREEDY REGISTER ALLOCATION **********
********** Function: llexit

selectOrSplit GR64:%vreg0 [16r,64r:0)  0@16r
AllocationOrder(GR64) = [ %RAX %RCX %RDX %RSI %RDI %R8 %R9 %R10 %R11 %RBX %R14 %R15 %R12 %R13 %RBP ]
hints: %RDI
assigning %vreg0 to %RDI: DIL
********** REWRITE VIRTUAL REGISTERS **********
********** Function: llexit
********** REGISTER MAP **********
[%vreg0 -> %RDI] GR64

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg0<def> = COPY %RDI; GR64:%vreg0
48B		%RAX<def> = MOV64ri64i32 60
64B		%RDI<def> = COPY %vreg0<kill>; GR64:%vreg0
80B		INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def,dead>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI, $3:[clobber], %RCX<earlyclobber,imp-def,dead>, $4:[clobber], %R11<earlyclobber,imp-def,dead>, $5:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
96B		RET
> %RDI<def> = COPY %RDI
Deleting identity copy.
> %RAX<def> = MOV64ri64i32 60
> %RDI<def> = COPY %RDI<kill>
Deleting identity copy.
> INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def,dead>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI, $3:[clobber], %RCX<earlyclobber,imp-def,dead>, $4:[clobber], %R11<earlyclobber,imp-def,dead>, $5:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
> RET
********** EMITTING LIVE DEBUG VARIABLES **********
********** Stack Slot Coloring **********
********** Function: llexit
******** Post-regalloc Machine LICM: llexit ********
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: llexit
RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0
Frequency(BB#0 derived from LLVM BB entry) = 1024
********** FIX EXECUTION DEPENDENCIES: VR128 **********
The instruction being printed 1504 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 2234 1501 1647 1642 1506 1648 1643 1645 1640Computing probabilities for entry



=== puts
5
is64bit 1
5 4 {ax}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
5 0x2105940
5 4 {ax}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
5 0x2105940
5 4 {di}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
5 0x2105940
5 4 {si}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
5 0x2105940
5 4 {dx}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
5 0x2105940
0 5 {rcx}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x2105940
0 5 {r11}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x2105940
0 8 {memory}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x0
0 9 {dirflag}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x0
0 6 {fpsr}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x0
0 7 {flags}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x0
I've changed this to i64 from i16! Might break returns!Initial selection DAG: BB#0 'puts:entry'
SelectionDAG has 26 nodes:
  0x2fbf468: ch = EntryToken [ORD=2]

  0x2fe91d0: i64 = Constant<1> [ORD=3]

  0x2fe92d0: i64 = Register %RAX [ORD=3]

    0x2fbf468: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe91d0: <multiple use>
  0x2fe6550: ch,glue = CopyToReg 0x2fbf468, 0x2fe92d0, 0x2fe91d0 [ORD=3]

  0x2fe6450: i32 = TargetConstant<9> [ORD=3]

  0x2fe6350: i64 = Register %RDI [ORD=3]

    0x2fe6550: <multiple use>
    0x2fe6350: <multiple use>
    0x2fe91d0: <multiple use>
    0x2fe6550: <multiple use>
  0x2fe6150: ch,glue = CopyToReg 0x2fe6550, 0x2fe6350, 0x2fe91d0, 0x2fe6550:1 [ORD=3]

  0x2fe6050: i64 = Register %RSI [ORD=3]

    0x2fe6150: <multiple use>
    0x2fe6050: <multiple use>
      0x2fbf468: <multiple use>
      0x2fe8ed0: i64 = Register %vreg0 [ORD=2]

    0x2fe90d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe8ed0 [ORD=2]

    0x2fe6150: <multiple use>
  0x2fe5e50: ch,glue = CopyToReg 0x2fe6150, 0x2fe6050, 0x2fe90d0, 0x2fe6150:1 [ORD=3]

  0x2fe5d50: i64 = Register %RDX [ORD=3]

    0x2fe5e50: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe91d0: <multiple use>
    0x2fe5e50: <multiple use>
  0x2fe5c50: ch,glue = CopyToReg 0x2fe5e50, 0x2fe5d50, 0x2fe91d0, 0x2fe5e50:1 [ORD=3]

  0x2fe5b50: i32 = TargetConstant<12> [ORD=3]

    0x2fe5c50: <multiple use>
    0x2fe8fd0: i64 = TargetExternalSymbol'syscall' [ORD=3]

    0x2fe6250: ch = MDNode<0x2f9dfd0> [ORD=3]

    0x2fe5f50: i64 = TargetConstant<1> [ORD=3]

    0x2fe5850: i32 = TargetConstant<10> [ORD=3]

    0x2fe92d0: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe6350: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5b50: <multiple use>
    0x2fe5a50: i64 = Register %RCX [ORD=3]

    0x2fe5b50: <multiple use>
    0x2fe5950: i64 = Register %R11 [ORD=3]

    0x2fe5b50: <multiple use>
    0x2fe5750: i32 = Register %EFLAGS [ORD=3]

    0x2fe5c50: <multiple use>
  0x2fe8dd0: ch,glue = inlineasm 0x2fe5c50, 0x2fe8fd0, 0x2fe6250, 0x2fe5f50, 0x2fe5850, 0x2fe92d0, 0x2fe6450, 0x2fe92d0, 0x2fe6450, 0x2fe6350, 0x2fe6450, 0x2fe6050, 0x2fe6450, 0x2fe5d50, 0x2fe5b50, 0x2fe5a50, 0x2fe5b50, 0x2fe5950, 0x2fe5b50, 0x2fe5750, 0x2fe5c50:1 [ORD=3]

    0x2fe8dd0: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe8dd0: <multiple use>
  0x2fe93d0: i64,ch,glue = CopyFromReg 0x2fe8dd0, 0x2fe92d0, 0x2fe8dd0:1 [ORD=3]

    0x2fe93d0: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe93d0: <multiple use>
  0x2fe95d0: ch,glue = CopyToReg 0x2fe93d0:1, 0x2fe92d0, 0x2fe93d0

    0x2fe95d0: <multiple use>
    0x2fe94d0: i64 = TargetConstant<0>

    0x2fe95d0: <multiple use>
  0x2fe96d0: ch = X86ISD::RET_FLAG 0x2fe95d0, 0x2fe94d0, 0x2fe95d0:1


Optimized lowered selection DAG: BB#0 'puts:entry'
SelectionDAG has 26 nodes:
  0x2fbf468: ch = EntryToken [ORD=2]

  0x2fe91d0: i64 = Constant<1> [ORD=3]

  0x2fe92d0: i64 = Register %RAX [ORD=3]

    0x2fbf468: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe91d0: <multiple use>
  0x2fe6550: ch,glue = CopyToReg 0x2fbf468, 0x2fe92d0, 0x2fe91d0 [ORD=3]

  0x2fe6450: i32 = TargetConstant<9> [ORD=3]

  0x2fe6350: i64 = Register %RDI [ORD=3]

    0x2fe6550: <multiple use>
    0x2fe6350: <multiple use>
    0x2fe91d0: <multiple use>
    0x2fe6550: <multiple use>
  0x2fe6150: ch,glue = CopyToReg 0x2fe6550, 0x2fe6350, 0x2fe91d0, 0x2fe6550:1 [ORD=3]

  0x2fe6050: i64 = Register %RSI [ORD=3]

    0x2fe6150: <multiple use>
    0x2fe6050: <multiple use>
      0x2fbf468: <multiple use>
      0x2fe8ed0: i64 = Register %vreg0 [ORD=2]

    0x2fe90d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe8ed0 [ORD=2]

    0x2fe6150: <multiple use>
  0x2fe5e50: ch,glue = CopyToReg 0x2fe6150, 0x2fe6050, 0x2fe90d0, 0x2fe6150:1 [ORD=3]

  0x2fe5d50: i64 = Register %RDX [ORD=3]

    0x2fe5e50: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe91d0: <multiple use>
    0x2fe5e50: <multiple use>
  0x2fe5c50: ch,glue = CopyToReg 0x2fe5e50, 0x2fe5d50, 0x2fe91d0, 0x2fe5e50:1 [ORD=3]

  0x2fe5b50: i32 = TargetConstant<12> [ORD=3]

    0x2fe5c50: <multiple use>
    0x2fe8fd0: i64 = TargetExternalSymbol'syscall' [ORD=3]

    0x2fe6250: ch = MDNode<0x2f9dfd0> [ORD=3]

    0x2fe5f50: i64 = TargetConstant<1> [ORD=3]

    0x2fe5850: i32 = TargetConstant<10> [ORD=3]

    0x2fe92d0: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe6350: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5b50: <multiple use>
    0x2fe5a50: i64 = Register %RCX [ORD=3]

    0x2fe5b50: <multiple use>
    0x2fe5950: i64 = Register %R11 [ORD=3]

    0x2fe5b50: <multiple use>
    0x2fe5750: i32 = Register %EFLAGS [ORD=3]

    0x2fe5c50: <multiple use>
  0x2fe8dd0: ch,glue = inlineasm 0x2fe5c50, 0x2fe8fd0, 0x2fe6250, 0x2fe5f50, 0x2fe5850, 0x2fe92d0, 0x2fe6450, 0x2fe92d0, 0x2fe6450, 0x2fe6350, 0x2fe6450, 0x2fe6050, 0x2fe6450, 0x2fe5d50, 0x2fe5b50, 0x2fe5a50, 0x2fe5b50, 0x2fe5950, 0x2fe5b50, 0x2fe5750, 0x2fe5c50:1 [ORD=3]

    0x2fe8dd0: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe8dd0: <multiple use>
  0x2fe93d0: i64,ch,glue = CopyFromReg 0x2fe8dd0, 0x2fe92d0, 0x2fe8dd0:1 [ORD=3]

    0x2fe93d0: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe93d0: <multiple use>
  0x2fe95d0: ch,glue = CopyToReg 0x2fe93d0:1, 0x2fe92d0, 0x2fe93d0

    0x2fe95d0: <multiple use>
    0x2fe94d0: i64 = TargetConstant<0>

    0x2fe95d0: <multiple use>
  0x2fe96d0: ch = X86ISD::RET_FLAG 0x2fe95d0, 0x2fe94d0, 0x2fe95d0:1


Legally typed node: 0x2fe94d0: i64 = TargetConstant<0> [ID=0]

Promote integer result: 0x2fe5750: i32 = Register %EFLAGS [ORD=3] [ID=0]

In Custom Lowering 8 4 1
Replacing Node Results. Node has OpCode
85
Legally typed node: 0x2fe97d0: i64 = Register %EFLAGS [ID=0]

Legally typed node: 0x2fe5950: i64 = Register %R11 [ORD=3] [ID=0]

Legally typed node: 0x2fe5a50: i64 = Register %RCX [ORD=3] [ID=0]

Legally typed node: 0x2fe5b50: i32 = TargetConstant<12> [ORD=3] [ID=0]

Legally typed node: 0x2fe5d50: i64 = Register %RDX [ORD=3] [ID=0]

Legally typed node: 0x2fe6050: i64 = Register %RSI [ORD=3] [ID=0]

Legally typed node: 0x2fe6350: i64 = Register %RDI [ORD=3] [ID=0]

Legally typed node: 0x2fe6450: i32 = TargetConstant<9> [ORD=3] [ID=0]

Legally typed node: 0x2fe92d0: i64 = Register %RAX [ORD=3] [ID=0]

Legally typed node: 0x2fe5850: i32 = TargetConstant<10> [ORD=3] [ID=0]

Legally typed node: 0x2fe5f50: i64 = TargetConstant<1> [ORD=3] [ID=0]

Legally typed node: 0x2fe6250: ch = MDNode<0x2f9dfd0> [ORD=3] [ID=0]

Legally typed node: 0x2fe8fd0: i64 = TargetExternalSymbol'syscall' [ORD=3] [ID=0]

Legally typed node: 0x2fe91d0: i64 = Constant<1> [ORD=3] [ID=0]

Legally typed node: 0x2fe8ed0: i64 = Register %vreg0 [ORD=2] [ID=0]

Legally typed node: 0x2fbf468: ch = EntryToken [ORD=2] [ID=0]

Legally typed node: 0x2fe90d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe8ed0 [ORD=2] [ID=0]

Legally typed node: 0x2fe6550: ch,glue = CopyToReg 0x2fbf468, 0x2fe92d0, 0x2fe91d0 [ORD=3] [ID=0]

Legally typed node: 0x2fe6150: ch,glue = CopyToReg 0x2fe6550, 0x2fe6350, 0x2fe91d0, 0x2fe6550:1 [ORD=3] [ID=0]

Legally typed node: 0x2fe5e50: ch,glue = CopyToReg 0x2fe6150, 0x2fe6050, 0x2fe90d0, 0x2fe6150:1 [ORD=3] [ID=0]

Legally typed node: 0x2fe5c50: ch,glue = CopyToReg 0x2fe5e50, 0x2fe5d50, 0x2fe91d0, 0x2fe5e50:1 [ORD=3] [ID=0]

Legally typed node: 0x2fe8dd0: ch,glue = inlineasm 0x2fe5c50, 0x2fe8fd0, 0x2fe6250, 0x2fe5f50, 0x2fe5850, 0x2fe92d0, 0x2fe6450, 0x2fe92d0, 0x2fe6450, 0x2fe6350, 0x2fe6450, 0x2fe6050, 0x2fe6450, 0x2fe5d50, 0x2fe5b50, 0x2fe5a50, 0x2fe5b50, 0x2fe5950, 0x2fe5b50, 0x2fe97d0, 0x2fe5c50:1 [ORD=3] [ID=0]

Legally typed node: 0x2fe93d0: i64,ch,glue = CopyFromReg 0x2fe8dd0, 0x2fe92d0, 0x2fe8dd0:1 [ORD=3] [ID=0]

Legally typed node: 0x2fe95d0: ch,glue = CopyToReg 0x2fe93d0:1, 0x2fe92d0, 0x2fe93d0 [ID=0]

Legally typed node: 0x2fe96d0: ch = X86ISD::RET_FLAG 0x2fe95d0, 0x2fe94d0, 0x2fe95d0:1 [ID=0]

Legally typed node: 0x7fff8d52a470: ch = handlenode 0x2fe96d0 [ID=0]

Type-legalized selection DAG: BB#0 'puts:entry'
SelectionDAG has 26 nodes:
  0x2fbf468: ch = EntryToken [ORD=2] [ID=-3]

  0x2fe91d0: i64 = Constant<1> [ORD=3] [ID=-3]

  0x2fe92d0: i64 = Register %RAX [ORD=3] [ID=-3]

    0x2fbf468: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe91d0: <multiple use>
  0x2fe6550: ch,glue = CopyToReg 0x2fbf468, 0x2fe92d0, 0x2fe91d0 [ORD=3] [ID=-3]

  0x2fe6450: i32 = TargetConstant<9> [ORD=3] [ID=-3]

  0x2fe6350: i64 = Register %RDI [ORD=3] [ID=-3]

    0x2fe6550: <multiple use>
    0x2fe6350: <multiple use>
    0x2fe91d0: <multiple use>
    0x2fe6550: <multiple use>
  0x2fe6150: ch,glue = CopyToReg 0x2fe6550, 0x2fe6350, 0x2fe91d0, 0x2fe6550:1 [ORD=3] [ID=-3]

  0x2fe6050: i64 = Register %RSI [ORD=3] [ID=-3]

    0x2fe6150: <multiple use>
    0x2fe6050: <multiple use>
      0x2fbf468: <multiple use>
      0x2fe8ed0: i64 = Register %vreg0 [ORD=2] [ID=-3]

    0x2fe90d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe8ed0 [ORD=2] [ID=-3]

    0x2fe6150: <multiple use>
  0x2fe5e50: ch,glue = CopyToReg 0x2fe6150, 0x2fe6050, 0x2fe90d0, 0x2fe6150:1 [ORD=3] [ID=-3]

  0x2fe5d50: i64 = Register %RDX [ORD=3] [ID=-3]

    0x2fe5e50: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe91d0: <multiple use>
    0x2fe5e50: <multiple use>
  0x2fe5c50: ch,glue = CopyToReg 0x2fe5e50, 0x2fe5d50, 0x2fe91d0, 0x2fe5e50:1 [ORD=3] [ID=-3]

  0x2fe5b50: i32 = TargetConstant<12> [ORD=3] [ID=-3]

    0x2fe5c50: <multiple use>
    0x2fe8fd0: i64 = TargetExternalSymbol'syscall' [ORD=3] [ID=-3]

    0x2fe6250: ch = MDNode<0x2f9dfd0> [ORD=3] [ID=-3]

    0x2fe5f50: i64 = TargetConstant<1> [ORD=3] [ID=-3]

    0x2fe5850: i32 = TargetConstant<10> [ORD=3] [ID=-3]

    0x2fe92d0: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe6350: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5b50: <multiple use>
    0x2fe5a50: i64 = Register %RCX [ORD=3] [ID=-3]

    0x2fe5b50: <multiple use>
    0x2fe5950: i64 = Register %R11 [ORD=3] [ID=-3]

    0x2fe5b50: <multiple use>
    0x2fe97d0: i64 = Register %EFLAGS [ID=-3]

    0x2fe5c50: <multiple use>
  0x2fe8dd0: ch,glue = inlineasm 0x2fe5c50, 0x2fe8fd0, 0x2fe6250, 0x2fe5f50, 0x2fe5850, 0x2fe92d0, 0x2fe6450, 0x2fe92d0, 0x2fe6450, 0x2fe6350, 0x2fe6450, 0x2fe6050, 0x2fe6450, 0x2fe5d50, 0x2fe5b50, 0x2fe5a50, 0x2fe5b50, 0x2fe5950, 0x2fe5b50, 0x2fe97d0, 0x2fe5c50:1 [ORD=3] [ID=-3]

    0x2fe8dd0: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe8dd0: <multiple use>
  0x2fe93d0: i64,ch,glue = CopyFromReg 0x2fe8dd0, 0x2fe92d0, 0x2fe8dd0:1 [ORD=3] [ID=-3]

    0x2fe93d0: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe93d0: <multiple use>
  0x2fe95d0: ch,glue = CopyToReg 0x2fe93d0:1, 0x2fe92d0, 0x2fe93d0 [ID=-3]

    0x2fe95d0: <multiple use>
    0x2fe94d0: i64 = TargetConstant<0> [ID=-3]

    0x2fe95d0: <multiple use>
  0x2fe96d0: ch = X86ISD::RET_FLAG 0x2fe95d0, 0x2fe94d0, 0x2fe95d0:1 [ID=-3]


Optimized type-legalized selection DAG: BB#0 'puts:entry'
SelectionDAG has 26 nodes:
  0x2fbf468: ch = EntryToken [ORD=2] [ID=-3]

  0x2fe91d0: i64 = Constant<1> [ORD=3] [ID=-3]

  0x2fe92d0: i64 = Register %RAX [ORD=3] [ID=-3]

    0x2fbf468: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe91d0: <multiple use>
  0x2fe6550: ch,glue = CopyToReg 0x2fbf468, 0x2fe92d0, 0x2fe91d0 [ORD=3] [ID=-3]

  0x2fe6450: i32 = TargetConstant<9> [ORD=3] [ID=-3]

  0x2fe6350: i64 = Register %RDI [ORD=3] [ID=-3]

    0x2fe6550: <multiple use>
    0x2fe6350: <multiple use>
    0x2fe91d0: <multiple use>
    0x2fe6550: <multiple use>
  0x2fe6150: ch,glue = CopyToReg 0x2fe6550, 0x2fe6350, 0x2fe91d0, 0x2fe6550:1 [ORD=3] [ID=-3]

  0x2fe6050: i64 = Register %RSI [ORD=3] [ID=-3]

    0x2fe6150: <multiple use>
    0x2fe6050: <multiple use>
      0x2fbf468: <multiple use>
      0x2fe8ed0: i64 = Register %vreg0 [ORD=2] [ID=-3]

    0x2fe90d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe8ed0 [ORD=2] [ID=-3]

    0x2fe6150: <multiple use>
  0x2fe5e50: ch,glue = CopyToReg 0x2fe6150, 0x2fe6050, 0x2fe90d0, 0x2fe6150:1 [ORD=3] [ID=-3]

  0x2fe5d50: i64 = Register %RDX [ORD=3] [ID=-3]

    0x2fe5e50: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe91d0: <multiple use>
    0x2fe5e50: <multiple use>
  0x2fe5c50: ch,glue = CopyToReg 0x2fe5e50, 0x2fe5d50, 0x2fe91d0, 0x2fe5e50:1 [ORD=3] [ID=-3]

  0x2fe5b50: i32 = TargetConstant<12> [ORD=3] [ID=-3]

    0x2fe5c50: <multiple use>
    0x2fe8fd0: i64 = TargetExternalSymbol'syscall' [ORD=3] [ID=-3]

    0x2fe6250: ch = MDNode<0x2f9dfd0> [ORD=3] [ID=-3]

    0x2fe5f50: i64 = TargetConstant<1> [ORD=3] [ID=-3]

    0x2fe5850: i32 = TargetConstant<10> [ORD=3] [ID=-3]

    0x2fe92d0: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe6350: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5b50: <multiple use>
    0x2fe5a50: i64 = Register %RCX [ORD=3] [ID=-3]

    0x2fe5b50: <multiple use>
    0x2fe5950: i64 = Register %R11 [ORD=3] [ID=-3]

    0x2fe5b50: <multiple use>
    0x2fe97d0: i64 = Register %EFLAGS [ID=-3]

    0x2fe5c50: <multiple use>
  0x2fe8dd0: ch,glue = inlineasm 0x2fe5c50, 0x2fe8fd0, 0x2fe6250, 0x2fe5f50, 0x2fe5850, 0x2fe92d0, 0x2fe6450, 0x2fe92d0, 0x2fe6450, 0x2fe6350, 0x2fe6450, 0x2fe6050, 0x2fe6450, 0x2fe5d50, 0x2fe5b50, 0x2fe5a50, 0x2fe5b50, 0x2fe5950, 0x2fe5b50, 0x2fe97d0, 0x2fe5c50:1 [ORD=3] [ID=-3]

    0x2fe8dd0: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe8dd0: <multiple use>
  0x2fe93d0: i64,ch,glue = CopyFromReg 0x2fe8dd0, 0x2fe92d0, 0x2fe8dd0:1 [ORD=3] [ID=-3]

    0x2fe93d0: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe93d0: <multiple use>
  0x2fe95d0: ch,glue = CopyToReg 0x2fe93d0:1, 0x2fe92d0, 0x2fe93d0 [ID=-3]

    0x2fe95d0: <multiple use>
    0x2fe94d0: i64 = TargetConstant<0> [ID=-3]

    0x2fe95d0: <multiple use>
  0x2fe96d0: ch = X86ISD::RET_FLAG 0x2fe95d0, 0x2fe94d0, 0x2fe95d0:1 [ID=-3]


In LegalizeDAG() 211
In legalize Op211
0
0
5
50
In LegalizeDAG() 42
In legalize Op42
0
50
0
5
5
In LegalizeDAG() 43
In legalize Op43
5
0
50
0
5
50
In LegalizeDAG() 151
In legalize Op151
0
50
0
5
0
5
4
5
4
5
4
5
4
5
4
5
4
5
4
5
4
5
50
In LegalizeDAG() 42
In legalize Op42
0
50
0
5
5
50
In LegalizeDAG() 42
In legalize Op42
0
50
0
5
5
50
In LegalizeDAG() 42
In legalize Op42
0
50
0
5
5
50
In LegalizeDAG() 42
In legalize Op42
0
50
0
5
5
In LegalizeDAG() 43
In legalize Op43
5
0
0
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 29
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 29
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 29
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 29
In LegalizeDAG() 29
In LegalizeDAG() 162
In legalize Op162
0
In LegalizeDAG() 36
In legalize Op36
5
In LegalizeDAG() 10
In legalize Op10
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 1
In legalize Op1
0
Legalized selection DAG: BB#0 'puts:entry'
SelectionDAG has 26 nodes:
  0x2fbf468: ch = EntryToken [ORD=2] [ID=0]

  0x2fe91d0: i64 = Constant<1> [ORD=3] [ID=2]

  0x2fe92d0: i64 = Register %RAX [ORD=3] [ID=7]

  0x2fe6450: i32 = TargetConstant<9> [ORD=3] [ID=8]

  0x2fe6350: i64 = Register %RDI [ORD=3] [ID=9]

  0x2fe6050: i64 = Register %RSI [ORD=3] [ID=10]

  0x2fe5d50: i64 = Register %RDX [ORD=3] [ID=11]

  0x2fe5b50: i32 = TargetConstant<12> [ORD=3] [ID=12]

    0x2fbf468: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe91d0: <multiple use>
  0x2fe6550: ch,glue = CopyToReg 0x2fbf468, 0x2fe92d0, 0x2fe91d0 [ORD=3] [ID=18]

    0x2fe6550: <multiple use>
    0x2fe6350: <multiple use>
    0x2fe91d0: <multiple use>
    0x2fe6550: <multiple use>
  0x2fe6150: ch,glue = CopyToReg 0x2fe6550, 0x2fe6350, 0x2fe91d0, 0x2fe6550:1 [ORD=3] [ID=19]

    0x2fe6150: <multiple use>
    0x2fe6050: <multiple use>
      0x2fbf468: <multiple use>
      0x2fe8ed0: i64 = Register %vreg0 [ORD=2] [ID=1]

    0x2fe90d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe8ed0 [ORD=2] [ID=17]

    0x2fe6150: <multiple use>
  0x2fe5e50: ch,glue = CopyToReg 0x2fe6150, 0x2fe6050, 0x2fe90d0, 0x2fe6150:1 [ORD=3] [ID=20]

    0x2fe5e50: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe91d0: <multiple use>
    0x2fe5e50: <multiple use>
  0x2fe5c50: ch,glue = CopyToReg 0x2fe5e50, 0x2fe5d50, 0x2fe91d0, 0x2fe5e50:1 [ORD=3] [ID=21]

    0x2fe5c50: <multiple use>
    0x2fe8fd0: i64 = TargetExternalSymbol'syscall' [ORD=3] [ID=3]

    0x2fe6250: ch = MDNode<0x2f9dfd0> [ORD=3] [ID=4]

    0x2fe5f50: i64 = TargetConstant<1> [ORD=3] [ID=5]

    0x2fe5850: i32 = TargetConstant<10> [ORD=3] [ID=6]

    0x2fe92d0: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe6350: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5b50: <multiple use>
    0x2fe5a50: i64 = Register %RCX [ORD=3] [ID=13]

    0x2fe5b50: <multiple use>
    0x2fe5950: i64 = Register %R11 [ORD=3] [ID=14]

    0x2fe5b50: <multiple use>
    0x2fe97d0: i64 = Register %EFLAGS [ID=16]

    0x2fe5c50: <multiple use>
  0x2fe8dd0: ch,glue = inlineasm 0x2fe5c50, 0x2fe8fd0, 0x2fe6250, 0x2fe5f50, 0x2fe5850, 0x2fe92d0, 0x2fe6450, 0x2fe92d0, 0x2fe6450, 0x2fe6350, 0x2fe6450, 0x2fe6050, 0x2fe6450, 0x2fe5d50, 0x2fe5b50, 0x2fe5a50, 0x2fe5b50, 0x2fe5950, 0x2fe5b50, 0x2fe97d0, 0x2fe5c50:1 [ORD=3] [ID=22]

    0x2fe8dd0: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe8dd0: <multiple use>
  0x2fe93d0: i64,ch,glue = CopyFromReg 0x2fe8dd0, 0x2fe92d0, 0x2fe8dd0:1 [ORD=3] [ID=23]

    0x2fe93d0: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe93d0: <multiple use>
  0x2fe95d0: ch,glue = CopyToReg 0x2fe93d0:1, 0x2fe92d0, 0x2fe93d0 [ID=24]

    0x2fe95d0: <multiple use>
    0x2fe94d0: i64 = TargetConstant<0> [ID=15]

    0x2fe95d0: <multiple use>
  0x2fe96d0: ch = X86ISD::RET_FLAG 0x2fe95d0, 0x2fe94d0, 0x2fe95d0:1 [ID=25]


Optimized legalized selection DAG: BB#0 'puts:entry'
SelectionDAG has 26 nodes:
  0x2fbf468: ch = EntryToken [ORD=2] [ID=0]

  0x2fe91d0: i64 = Constant<1> [ORD=3] [ID=2]

  0x2fe92d0: i64 = Register %RAX [ORD=3] [ID=7]

  0x2fe6450: i32 = TargetConstant<9> [ORD=3] [ID=8]

  0x2fe6350: i64 = Register %RDI [ORD=3] [ID=9]

  0x2fe6050: i64 = Register %RSI [ORD=3] [ID=10]

  0x2fe5d50: i64 = Register %RDX [ORD=3] [ID=11]

  0x2fe5b50: i32 = TargetConstant<12> [ORD=3] [ID=12]

    0x2fbf468: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe91d0: <multiple use>
  0x2fe6550: ch,glue = CopyToReg 0x2fbf468, 0x2fe92d0, 0x2fe91d0 [ORD=3] [ID=18]

    0x2fe6550: <multiple use>
    0x2fe6350: <multiple use>
    0x2fe91d0: <multiple use>
    0x2fe6550: <multiple use>
  0x2fe6150: ch,glue = CopyToReg 0x2fe6550, 0x2fe6350, 0x2fe91d0, 0x2fe6550:1 [ORD=3] [ID=19]

    0x2fe6150: <multiple use>
    0x2fe6050: <multiple use>
      0x2fbf468: <multiple use>
      0x2fe8ed0: i64 = Register %vreg0 [ORD=2] [ID=1]

    0x2fe90d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe8ed0 [ORD=2] [ID=17]

    0x2fe6150: <multiple use>
  0x2fe5e50: ch,glue = CopyToReg 0x2fe6150, 0x2fe6050, 0x2fe90d0, 0x2fe6150:1 [ORD=3] [ID=20]

    0x2fe5e50: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe91d0: <multiple use>
    0x2fe5e50: <multiple use>
  0x2fe5c50: ch,glue = CopyToReg 0x2fe5e50, 0x2fe5d50, 0x2fe91d0, 0x2fe5e50:1 [ORD=3] [ID=21]

    0x2fe5c50: <multiple use>
    0x2fe8fd0: i64 = TargetExternalSymbol'syscall' [ORD=3] [ID=3]

    0x2fe6250: ch = MDNode<0x2f9dfd0> [ORD=3] [ID=4]

    0x2fe5f50: i64 = TargetConstant<1> [ORD=3] [ID=5]

    0x2fe5850: i32 = TargetConstant<10> [ORD=3] [ID=6]

    0x2fe92d0: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe6350: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5b50: <multiple use>
    0x2fe5a50: i64 = Register %RCX [ORD=3] [ID=13]

    0x2fe5b50: <multiple use>
    0x2fe5950: i64 = Register %R11 [ORD=3] [ID=14]

    0x2fe5b50: <multiple use>
    0x2fe97d0: i64 = Register %EFLAGS [ID=16]

    0x2fe5c50: <multiple use>
  0x2fe8dd0: ch,glue = inlineasm 0x2fe5c50, 0x2fe8fd0, 0x2fe6250, 0x2fe5f50, 0x2fe5850, 0x2fe92d0, 0x2fe6450, 0x2fe92d0, 0x2fe6450, 0x2fe6350, 0x2fe6450, 0x2fe6050, 0x2fe6450, 0x2fe5d50, 0x2fe5b50, 0x2fe5a50, 0x2fe5b50, 0x2fe5950, 0x2fe5b50, 0x2fe97d0, 0x2fe5c50:1 [ORD=3] [ID=22]

    0x2fe8dd0: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe8dd0: <multiple use>
  0x2fe93d0: i64,ch,glue = CopyFromReg 0x2fe8dd0, 0x2fe92d0, 0x2fe8dd0:1 [ORD=3] [ID=23]

    0x2fe93d0: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe93d0: <multiple use>
  0x2fe95d0: ch,glue = CopyToReg 0x2fe93d0:1, 0x2fe92d0, 0x2fe93d0 [ID=24]

    0x2fe95d0: <multiple use>
    0x2fe94d0: i64 = TargetConstant<0> [ID=15]

    0x2fe95d0: <multiple use>
  0x2fe96d0: ch = X86ISD::RET_FLAG 0x2fe95d0, 0x2fe94d0, 0x2fe95d0:1 [ID=25]


===== Instruction selection begins: BB#0 'entry'
Selecting: 0x2fe96d0: ch = X86ISD::RET_FLAG 0x2fe95d0, 0x2fe94d0, 0x2fe95d0:1 [ID=25]

ISEL: Starting pattern match on root node: 0x2fe96d0: ch = X86ISD::RET_FLAG 0x2fe95d0, 0x2fe94d0, 0x2fe95d0:1 [ID=25]

  Initial Opcode index to 81356
  Morphed node: 0x2fe96d0: ch = RET 0x2fe95d0, 0x2fe95d0:1

ISEL: Match complete!
=> 0x2fe96d0: ch = RET 0x2fe95d0, 0x2fe95d0:1

Selecting: 0x2fe95d0: ch,glue = CopyToReg 0x2fe93d0:1, 0x2fe92d0, 0x2fe93d0 [ID=24]

=> 0x2fe95d0: ch,glue = CopyToReg 0x2fe93d0:1, 0x2fe92d0, 0x2fe93d0

Selecting: 0x2fe93d0: i64,ch,glue = CopyFromReg 0x2fe8dd0, 0x2fe92d0, 0x2fe8dd0:1 [ORD=3] [ID=23]

=> 0x2fe93d0: i64,ch,glue = CopyFromReg 0x2fe8dd0, 0x2fe92d0, 0x2fe8dd0:1 [ORD=3]

Selecting: 0x2fe8dd0: ch,glue = inlineasm 0x2fe5c50, 0x2fe8fd0, 0x2fe6250, 0x2fe5f50, 0x2fe5850, 0x2fe92d0, 0x2fe6450, 0x2fe92d0, 0x2fe6450, 0x2fe6350, 0x2fe6450, 0x2fe6050, 0x2fe6450, 0x2fe5d50, 0x2fe5b50, 0x2fe5a50, 0x2fe5b50, 0x2fe5950, 0x2fe5b50, 0x2fe97d0, 0x2fe5c50:1 [ORD=3] [ID=22]

=> 0x2fe94d0: ch,glue = inlineasm 0x2fe5c50, 0x2fe8fd0, 0x2fe6250, 0x2fe5f50, 0x2fe5850, 0x2fe92d0, 0x2fe6450, 0x2fe92d0, 0x2fe6450, 0x2fe6350, 0x2fe6450, 0x2fe6050, 0x2fe6450, 0x2fe5d50, 0x2fe5b50, 0x2fe5a50, 0x2fe5b50, 0x2fe5950, 0x2fe5b50, 0x2fe97d0, 0x2fe5c50:1

Selecting: 0x2fe5c50: ch,glue = CopyToReg 0x2fe5e50, 0x2fe5d50, 0x2fe91d0, 0x2fe5e50:1 [ORD=3] [ID=21]

=> 0x2fe5c50: ch,glue = CopyToReg 0x2fe5e50, 0x2fe5d50, 0x2fe91d0, 0x2fe5e50:1 [ORD=3]

Selecting: 0x2fe5e50: ch,glue = CopyToReg 0x2fe6150, 0x2fe6050, 0x2fe90d0, 0x2fe6150:1 [ORD=3] [ID=20]

=> 0x2fe5e50: ch,glue = CopyToReg 0x2fe6150, 0x2fe6050, 0x2fe90d0, 0x2fe6150:1 [ORD=3]

Selecting: 0x2fe6150: ch,glue = CopyToReg 0x2fe6550, 0x2fe6350, 0x2fe91d0, 0x2fe6550:1 [ORD=3] [ID=19]

=> 0x2fe6150: ch,glue = CopyToReg 0x2fe6550, 0x2fe6350, 0x2fe91d0, 0x2fe6550:1 [ORD=3]

Selecting: 0x2fe6550: ch,glue = CopyToReg 0x2fbf468, 0x2fe92d0, 0x2fe91d0 [ORD=3] [ID=18]

=> 0x2fe6550: ch,glue = CopyToReg 0x2fbf468, 0x2fe92d0, 0x2fe91d0 [ORD=3]

Selecting: 0x2fe90d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe8ed0 [ORD=2] [ID=17]

=> 0x2fe90d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe8ed0 [ORD=2]

Selecting: 0x2fe97d0: i64 = Register %EFLAGS [ID=16]

=> 0x2fe97d0: i64 = Register %EFLAGS

Selecting: 0x2fe5950: i64 = Register %R11 [ORD=3] [ID=14]

=> 0x2fe5950: i64 = Register %R11 [ORD=3]

Selecting: 0x2fe5a50: i64 = Register %RCX [ORD=3] [ID=13]

=> 0x2fe5a50: i64 = Register %RCX [ORD=3]

Selecting: 0x2fe5b50: i32 = TargetConstant<12> [ORD=3] [ID=12]

=> 0x2fe5b50: i32 = TargetConstant<12> [ORD=3]

Selecting: 0x2fe5d50: i64 = Register %RDX [ORD=3] [ID=11]

=> 0x2fe5d50: i64 = Register %RDX [ORD=3]

Selecting: 0x2fe6050: i64 = Register %RSI [ORD=3] [ID=10]

=> 0x2fe6050: i64 = Register %RSI [ORD=3]

Selecting: 0x2fe6350: i64 = Register %RDI [ORD=3] [ID=9]

=> 0x2fe6350: i64 = Register %RDI [ORD=3]

Selecting: 0x2fe6450: i32 = TargetConstant<9> [ORD=3] [ID=8]

=> 0x2fe6450: i32 = TargetConstant<9> [ORD=3]

Selecting: 0x2fe92d0: i64 = Register %RAX [ORD=3] [ID=7]

=> 0x2fe92d0: i64 = Register %RAX [ORD=3]

Selecting: 0x2fe5850: i32 = TargetConstant<10> [ORD=3] [ID=6]

=> 0x2fe5850: i32 = TargetConstant<10> [ORD=3]

Selecting: 0x2fe5f50: i64 = TargetConstant<1> [ORD=3] [ID=5]

=> 0x2fe5f50: i64 = TargetConstant<1> [ORD=3]

Selecting: 0x2fe6250: ch = MDNode<0x2f9dfd0> [ORD=3] [ID=4]

=> 0x2fe6250: ch = MDNode<0x2f9dfd0> [ORD=3]

Selecting: 0x2fe8fd0: i64 = TargetExternalSymbol'syscall' [ORD=3] [ID=3]

=> 0x2fe8fd0: i64 = TargetExternalSymbol'syscall' [ORD=3]

Selecting: 0x2fe91d0: i64 = Constant<1> [ORD=3] [ID=2]

ISEL: Starting pattern match on root node: 0x2fe91d0: i64 = Constant<1> [ORD=3] [ID=2]

  Initial Opcode index to 83167
  Skipped scope entry (due to false predicate) at index 83169, continuing at 83219
  TypeSwitch[i64] from 83221 to 83224
  Morphed node: 0x2fe91d0: i64 = MOV64ri64i32 0x2fe5f50 [ORD=3]

ISEL: Match complete!
=> 0x2fe91d0: i64 = MOV64ri64i32 0x2fe5f50 [ORD=3]

Selecting: 0x2fe8ed0: i64 = Register %vreg0 [ORD=2] [ID=1]

=> 0x2fe8ed0: i64 = Register %vreg0 [ORD=2]

Selecting: 0x2fbf468: ch = EntryToken [ORD=2] [ID=0]

=> 0x2fbf468: ch = EntryToken [ORD=2]

===== Instruction selection ends:
Selected selection DAG: BB#0 'puts:entry'
SelectionDAG has 25 nodes:
  0x2fbf468: ch = EntryToken [ORD=2]

    0x2fe5f50: <multiple use>
  0x2fe91d0: i64 = MOV64ri64i32 0x2fe5f50 [ORD=3]

  0x2fe5f50: i64 = TargetConstant<1> [ORD=3]

  0x2fe92d0: i64 = Register %RAX [ORD=3]

  0x2fe6450: i32 = TargetConstant<9> [ORD=3]

  0x2fe6350: i64 = Register %RDI [ORD=3]

  0x2fe6050: i64 = Register %RSI [ORD=3]

  0x2fe5d50: i64 = Register %RDX [ORD=3]

  0x2fe5b50: i32 = TargetConstant<12> [ORD=3]

    0x2fbf468: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe91d0: <multiple use>
  0x2fe6550: ch,glue = CopyToReg 0x2fbf468, 0x2fe92d0, 0x2fe91d0 [ORD=3]

    0x2fe6550: <multiple use>
    0x2fe6350: <multiple use>
    0x2fe91d0: <multiple use>
    0x2fe6550: <multiple use>
  0x2fe6150: ch,glue = CopyToReg 0x2fe6550, 0x2fe6350, 0x2fe91d0, 0x2fe6550:1 [ORD=3]

    0x2fe6150: <multiple use>
    0x2fe6050: <multiple use>
      0x2fbf468: <multiple use>
      0x2fe8ed0: i64 = Register %vreg0 [ORD=2]

    0x2fe90d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe8ed0 [ORD=2]

    0x2fe6150: <multiple use>
  0x2fe5e50: ch,glue = CopyToReg 0x2fe6150, 0x2fe6050, 0x2fe90d0, 0x2fe6150:1 [ORD=3]

    0x2fe5e50: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe91d0: <multiple use>
    0x2fe5e50: <multiple use>
  0x2fe5c50: ch,glue = CopyToReg 0x2fe5e50, 0x2fe5d50, 0x2fe91d0, 0x2fe5e50:1 [ORD=3]

    0x2fe94d0: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe94d0: <multiple use>
  0x2fe93d0: i64,ch,glue = CopyFromReg 0x2fe94d0, 0x2fe92d0, 0x2fe94d0:1 [ORD=3]

    0x2fe93d0: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe93d0: <multiple use>
  0x2fe95d0: ch,glue = CopyToReg 0x2fe93d0:1, 0x2fe92d0, 0x2fe93d0

    0x2fe5c50: <multiple use>
    0x2fe8fd0: i64 = TargetExternalSymbol'syscall' [ORD=3]

    0x2fe6250: ch = MDNode<0x2f9dfd0> [ORD=3]

    0x2fe5f50: <multiple use>
    0x2fe5850: i32 = TargetConstant<10> [ORD=3]

    0x2fe92d0: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe6350: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5b50: <multiple use>
    0x2fe5a50: i64 = Register %RCX [ORD=3]

    0x2fe5b50: <multiple use>
    0x2fe5950: i64 = Register %R11 [ORD=3]

    0x2fe5b50: <multiple use>
    0x2fe97d0: i64 = Register %EFLAGS

    0x2fe5c50: <multiple use>
  0x2fe94d0: ch,glue = inlineasm 0x2fe5c50, 0x2fe8fd0, 0x2fe6250, 0x2fe5f50, 0x2fe5850, 0x2fe92d0, 0x2fe6450, 0x2fe92d0, 0x2fe6450, 0x2fe6350, 0x2fe6450, 0x2fe6050, 0x2fe6450, 0x2fe5d50, 0x2fe5b50, 0x2fe5a50, 0x2fe5b50, 0x2fe5950, 0x2fe5b50, 0x2fe97d0, 0x2fe5c50:1

    0x2fe95d0: <multiple use>
    0x2fe95d0: <multiple use>
  0x2fe96d0: ch = RET 0x2fe95d0, 0x2fe95d0:1


********** List Scheduling BB#0 'entry' **********
SU(0): 0x2fe96d0: ch = RET 0x2fe95d0, 0x2fe95d0:1 [ID=0]

    0x2fe95d0: ch,glue = CopyToReg 0x2fe93d0:1, 0x2fe92d0, 0x2fe93d0 [ID=0]

  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1
   val SU(1): Latency=1

SU(1): 0x2fe93d0: i64,ch,glue = CopyFromReg 0x2fe94d0, 0x2fe92d0, 0x2fe94d0:1 [ORD=3] [ID=1]

    0x2fe6550: ch,glue = CopyToReg 0x2fbf468, 0x2fe92d0, 0x2fe91d0 [ORD=3] [ID=1]

    0x2fe6150: ch,glue = CopyToReg 0x2fe6550, 0x2fe6350, 0x2fe91d0, 0x2fe6550:1 [ORD=3] [ID=1]

    0x2fe5e50: ch,glue = CopyToReg 0x2fe6150, 0x2fe6050, 0x2fe90d0, 0x2fe6150:1 [ORD=3] [ID=1]

    0x2fe5c50: ch,glue = CopyToReg 0x2fe5e50, 0x2fe5d50, 0x2fe91d0, 0x2fe5e50:1 [ORD=3] [ID=1]

    0x2fe94d0: ch,glue = inlineasm 0x2fe5c50, 0x2fe8fd0, 0x2fe6250, 0x2fe5f50, 0x2fe5850, 0x2fe92d0, 0x2fe6450, 0x2fe92d0, 0x2fe6450, 0x2fe6350, 0x2fe6450, 0x2fe6050, 0x2fe6450, 0x2fe5d50, 0x2fe5b50, 0x2fe5a50, 0x2fe5b50, 0x2fe5950, 0x2fe5b50, 0x2fe97d0, 0x2fe5c50:1 [ID=1]

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(2): Latency=1
   val SU(3): Latency=1
  Successors:
   ch  SU(0): Latency=1
   val SU(0): Latency=1

SU(2): 0x2fe91d0: i64 = MOV64ri64i32 0x2fe5f50 [ORD=3] [ID=2]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
   val SU(1): Latency=1

SU(3): 0x2fe90d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe8ed0 [ORD=2] [ID=3]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
   val SU(1): Latency=1


Examining Available:
Height 0: SU(0): 0x2fe96d0: ch = RET 0x2fe95d0, 0x2fe95d0:1 [ID=0]

    0x2fe95d0: ch,glue = CopyToReg 0x2fe93d0:1, 0x2fe92d0, 0x2fe93d0 [ID=0]


*** Scheduling [0]: SU(0): 0x2fe96d0: ch = RET 0x2fe95d0, 0x2fe95d0:1 [ID=0]

    0x2fe95d0: ch,glue = CopyToReg 0x2fe93d0:1, 0x2fe92d0, 0x2fe93d0 [ID=0]

GR64: 1 / 12

Examining Available:
Height 1: SU(1): 0x2fe93d0: i64,ch,glue = CopyFromReg 0x2fe94d0, 0x2fe92d0, 0x2fe94d0:1 [ORD=3] [ID=1]

    0x2fe6550: ch,glue = CopyToReg 0x2fbf468, 0x2fe92d0, 0x2fe91d0 [ORD=3] [ID=1]

    0x2fe6150: ch,glue = CopyToReg 0x2fe6550, 0x2fe6350, 0x2fe91d0, 0x2fe6550:1 [ORD=3] [ID=1]

    0x2fe5e50: ch,glue = CopyToReg 0x2fe6150, 0x2fe6050, 0x2fe90d0, 0x2fe6150:1 [ORD=3] [ID=1]

    0x2fe5c50: ch,glue = CopyToReg 0x2fe5e50, 0x2fe5d50, 0x2fe91d0, 0x2fe5e50:1 [ORD=3] [ID=1]

    0x2fe94d0: ch,glue = inlineasm 0x2fe5c50, 0x2fe8fd0, 0x2fe6250, 0x2fe5f50, 0x2fe5850, 0x2fe92d0, 0x2fe6450, 0x2fe92d0, 0x2fe6450, 0x2fe6350, 0x2fe6450, 0x2fe6050, 0x2fe6450, 0x2fe5d50, 0x2fe5b50, 0x2fe5a50, 0x2fe5b50, 0x2fe5950, 0x2fe5b50, 0x2fe97d0, 0x2fe5c50:1 [ID=1]


*** Scheduling [1]: SU(1): 0x2fe93d0: i64,ch,glue = CopyFromReg 0x2fe94d0, 0x2fe92d0, 0x2fe94d0:1 [ORD=3] [ID=1]

    0x2fe6550: ch,glue = CopyToReg 0x2fbf468, 0x2fe92d0, 0x2fe91d0 [ORD=3] [ID=1]

    0x2fe6150: ch,glue = CopyToReg 0x2fe6550, 0x2fe6350, 0x2fe91d0, 0x2fe6550:1 [ORD=3] [ID=1]

    0x2fe5e50: ch,glue = CopyToReg 0x2fe6150, 0x2fe6050, 0x2fe90d0, 0x2fe6150:1 [ORD=3] [ID=1]

    0x2fe5c50: ch,glue = CopyToReg 0x2fe5e50, 0x2fe5d50, 0x2fe91d0, 0x2fe5e50:1 [ORD=3] [ID=1]

    0x2fe94d0: ch,glue = inlineasm 0x2fe5c50, 0x2fe8fd0, 0x2fe6250, 0x2fe5f50, 0x2fe5850, 0x2fe92d0, 0x2fe6450, 0x2fe92d0, 0x2fe6450, 0x2fe6350, 0x2fe6450, 0x2fe6050, 0x2fe6450, 0x2fe5d50, 0x2fe5b50, 0x2fe5a50, 0x2fe5b50, 0x2fe5950, 0x2fe5b50, 0x2fe97d0, 0x2fe5c50:1 [ID=1]

GR64: 2 / 12

Examining Available:
Height 2: SU(2): 0x2fe91d0: i64 = MOV64ri64i32 0x2fe5f50 [ORD=3] [ID=2]

Height 2: SU(3): 0x2fe90d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe8ed0 [ORD=2] [ID=3]


*** Scheduling [2]: SU(2): 0x2fe91d0: i64 = MOV64ri64i32 0x2fe5f50 [ORD=3] [ID=2]

GR64: 1 / 12

Examining Available:
Height 2: SU(3): 0x2fe90d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe8ed0 [ORD=2] [ID=3]


*** Scheduling [3]: SU(3): 0x2fe90d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe8ed0 [ORD=2] [ID=3]

*** Final schedule ***
SU(3): 0x2fe90d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe8ed0 [ORD=2] [ID=3]

SU(2): 0x2fe91d0: i64 = MOV64ri64i32 0x2fe5f50 [ORD=3] [ID=2]

SU(1): 0x2fe93d0: i64,ch,glue = CopyFromReg 0x2fe94d0, 0x2fe92d0, 0x2fe94d0:1 [ORD=3] [ID=1]

    0x2fe6550: ch,glue = CopyToReg 0x2fbf468, 0x2fe92d0, 0x2fe91d0 [ORD=3] [ID=1]

    0x2fe6150: ch,glue = CopyToReg 0x2fe6550, 0x2fe6350, 0x2fe91d0, 0x2fe6550:1 [ORD=3] [ID=1]

    0x2fe5e50: ch,glue = CopyToReg 0x2fe6150, 0x2fe6050, 0x2fe90d0, 0x2fe6150:1 [ORD=3] [ID=1]

    0x2fe5c50: ch,glue = CopyToReg 0x2fe5e50, 0x2fe5d50, 0x2fe91d0, 0x2fe5e50:1 [ORD=3] [ID=1]

    0x2fe94d0: ch,glue = inlineasm 0x2fe5c50, 0x2fe8fd0, 0x2fe6250, 0x2fe5f50, 0x2fe5850, 0x2fe92d0, 0x2fe6450, 0x2fe92d0, 0x2fe6450, 0x2fe6350, 0x2fe6450, 0x2fe6050, 0x2fe6450, 0x2fe5d50, 0x2fe5b50, 0x2fe5a50, 0x2fe5b50, 0x2fe5950, 0x2fe5b50, 0x2fe97d0, 0x2fe5c50:1 [ID=1]

SU(0): 0x2fe96d0: ch = RET 0x2fe95d0, 0x2fe95d0:1 [ID=0]

    0x2fe95d0: ch,glue = CopyToReg 0x2fe93d0:1, 0x2fe92d0, 0x2fe93d0 [ID=0]


TADA
Total amount of phi nodes to update: 0
# Machine code for function puts: SSA
Function Live Ins: %RDI in %vreg0
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg0<def> = COPY %RDI; GR64:%vreg0
32B		%vreg1<def> = MOV64ri64i32 1; GR64:%vreg1
48B		%RAX<def> = COPY %vreg1; GR64:%vreg1
64B		%RDI<def> = COPY %vreg1; GR64:%vreg1
80B		%RSI<def> = COPY %vreg0; GR64:%vreg0
96B		%RDX<def> = COPY %vreg1; GR64:%vreg1
112B		INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def>, $1:[reguse], %RAX, $2:[reguse], %RDI, $3:[reguse], %RSI, $4:[reguse], %RDX, $5:[clobber], %RCX<earlyclobber,imp-def>, $6:[clobber], %R11<earlyclobber,imp-def>, $7:[clobber], %EFLAGS<earlyclobber,imp-def>, <<badref>>
128B		%vreg2<def> = COPY %RAX; GR64:%vreg2
144B		%RAX<def> = COPY %vreg2; GR64:%vreg2
160B		RET

# End machine code for function puts.

********** Stack Coloring **********
********** Function: puts
******** Pre-regalloc Machine LICM: puts ********
Entering: entry
Exiting: entry
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: puts
********** PROCESS IMPLICIT DEFS **********
********** Function: puts
********** REWRITING TWO-ADDR INSTRS **********
********** Function: puts
# Machine code for function puts: Post SSA
Function Live Ins: %RDI in %vreg0
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg0<def> = COPY %RDI<kill>; GR64:%vreg0
32B		%vreg1<def> = MOV64ri64i32 1; GR64:%vreg1
48B		%RAX<def> = COPY %vreg1; GR64:%vreg1
64B		%RDI<def> = COPY %vreg1; GR64:%vreg1
80B		%RSI<def> = COPY %vreg0<kill>; GR64:%vreg0
96B		%RDX<def> = COPY %vreg1<kill>; GR64:%vreg1
112B		INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI<kill>, $3:[reguse], %RSI<kill>, $4:[reguse], %RDX<kill>, $5:[clobber], %RCX<earlyclobber,imp-def,dead>, $6:[clobber], %R11<earlyclobber,imp-def,dead>, $7:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
128B		%vreg2<def> = COPY %RAX<kill>; GR64:%vreg2
144B		%RAX<def> = COPY %vreg2<kill>; GR64:%vreg2
160B		RET %RAX<imp-use,kill>

# End machine code for function puts.

********** COMPUTING LIVE INTERVALS **********
********** Function: puts
BB#0:		# derived from entry
16B	%vreg0<def> = COPY %RDI<kill>; GR64:%vreg0
		register: %vreg0 +[16r,80r:0)
32B	%vreg1<def> = MOV64ri64i32 1; GR64:%vreg1
		register: %vreg1 +[32r,96r:0)
48B	%RAX<def> = COPY %vreg1; GR64:%vreg1
64B	%RDI<def> = COPY %vreg1; GR64:%vreg1
80B	%RSI<def> = COPY %vreg0<kill>; GR64:%vreg0
96B	%RDX<def> = COPY %vreg1<kill>; GR64:%vreg1
112B	INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI<kill>, $3:[reguse], %RSI<kill>, $4:[reguse], %RDX<kill>, $5:[clobber], %RCX<earlyclobber,imp-def,dead>, $6:[clobber], %R11<earlyclobber,imp-def,dead>, $7:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
128B	%vreg2<def> = COPY %RAX<kill>; GR64:%vreg2
		register: %vreg2 +[128r,144r:0)
144B	%RAX<def> = COPY %vreg2<kill>; GR64:%vreg2
160B	RET %RAX<imp-use,kill>
Computing live-in reg-units in ABI blocks.
0B	BB#0 DIL#0
Created 1 new intervals.
********** INTERVALS **********
DIL = [0B,16r:0)[64r,112r:1)  0@0B-phi 1@64r
%vreg0 = [16r,80r:0)  0@16r
%vreg1 = [32r,96r:0)  0@32r
%vreg2 = [128r,144r:0)  0@128r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function puts: Post SSA
Function Live Ins: %RDI in %vreg0
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg0<def> = COPY %RDI; GR64:%vreg0
32B		%vreg1<def> = MOV64ri64i32 1; GR64:%vreg1
48B		%RAX<def> = COPY %vreg1; GR64:%vreg1
64B		%RDI<def> = COPY %vreg1; GR64:%vreg1
80B		%RSI<def> = COPY %vreg0<kill>; GR64:%vreg0
96B		%RDX<def> = COPY %vreg1<kill>; GR64:%vreg1
112B		INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI, $3:[reguse], %RSI<kill>, $4:[reguse], %RDX<kill>, $5:[clobber], %RCX<earlyclobber,imp-def,dead>, $6:[clobber], %R11<earlyclobber,imp-def,dead>, $7:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
128B		%vreg2<def> = COPY %RAX<kill>; GR64:%vreg2
144B		%RAX<def> = COPY %vreg2<kill>; GR64:%vreg2
160B		RET %RAX<imp-use,kill>

# End machine code for function puts.

********** COMPUTING LIVE DEBUG VARIABLES: puts **********
********** DEBUG VARIABLES **********
********** SIMPLE REGISTER COALESCING **********
********** Function: puts
********** JOINING INTERVALS ***********
entry:
16B	%vreg0<def> = COPY %RDI; GR64:%vreg0
	Considering merging %vreg0 with %RDI
	Can only merge into reserved registers.
48B	%RAX<def> = COPY %vreg1; GR64:%vreg1
	Considering merging %vreg1 with %RAX
	Can only merge into reserved registers.
Remat: %RAX<def> = MOV64ri64i32 1
Shrink: [32r,96r:0)  0@32r
Shrunk: [32r,96r:0)  0@32r
64B	%RDI<def> = COPY %vreg1; GR64:%vreg1
	Considering merging %vreg1 with %RDI
	Can only merge into reserved registers.
Remat: %RDI<def> = MOV64ri64i32 1
Shrink: [32r,96r:0)  0@32r
Shrunk: [32r,96r:0)  0@32r
80B	%RSI<def> = COPY %vreg0<kill>; GR64:%vreg0
	Considering merging %vreg0 with %RSI
	Can only merge into reserved registers.
96B	%RDX<def> = COPY %vreg1<kill>; GR64:%vreg1
	Considering merging %vreg1 with %RDX
	Can only merge into reserved registers.
Remat: %RDX<def> = MOV64ri64i32 1
Shrink: [32r,96r:0)  0@32r
All defs dead: 32r	%vreg1<def,dead> = MOV64ri64i32 1; GR64:%vreg1
Shrunk: [32r,32d:0)  0@32r
Deleting dead def 32r	%vreg1<def,dead> = MOV64ri64i32 1; GR64:%vreg1
128B	%vreg2<def> = COPY %RAX<kill>; GR64:%vreg2
	Considering merging %vreg2 with %RAX
	Can only merge into reserved registers.
144B	%RAX<def> = COPY %vreg2<kill>; GR64:%vreg2
	Considering merging %vreg2 with %RAX
	Can only merge into reserved registers.
Trying to inflate 0 regs.
********** INTERVALS **********
DIL = [0B,16r:0)[64r,112r:1)  0@0B-phi 1@64r
%vreg0 = [16r,80r:0)  0@16r
%vreg2 = [128r,144r:0)  0@128r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function puts: Post SSA
Function Live Ins: %RDI in %vreg0
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg0<def> = COPY %RDI; GR64:%vreg0
48B		%RAX<def> = MOV64ri64i32 1
64B		%RDI<def> = MOV64ri64i32 1
80B		%RSI<def> = COPY %vreg0<kill>; GR64:%vreg0
96B		%RDX<def> = MOV64ri64i32 1
112B		INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI, $3:[reguse], %RSI<kill>, $4:[reguse], %RDX<kill>, $5:[clobber], %RCX<earlyclobber,imp-def,dead>, $6:[clobber], %R11<earlyclobber,imp-def,dead>, $7:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
128B		%vreg2<def> = COPY %RAX<kill>; GR64:%vreg2
144B		%RAX<def> = COPY %vreg2<kill>; GR64:%vreg2
160B		RET %RAX<imp-use,kill>

# End machine code for function puts.

********** DEBUG VARIABLES **********
********** Compute Spill Weights **********
********** Function: puts
********** GREEDY REGISTER ALLOCATION **********
********** Function: puts

selectOrSplit GR64:%vreg0 [16r,80r:0)  0@16r
hints: %RDI
missed hint %RDI
assigning %vreg0 to %RCX: CH CL

selectOrSplit GR64:%vreg2 [128r,144r:0)  0@128r
hints: %RAX
assigning %vreg2 to %RAX: AH AL
********** REWRITE VIRTUAL REGISTERS **********
********** Function: puts
********** REGISTER MAP **********
[%vreg0 -> %RCX] GR64
[%vreg2 -> %RAX] GR64

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg0<def> = COPY %RDI; GR64:%vreg0
48B		%RAX<def> = MOV64ri64i32 1
64B		%RDI<def> = MOV64ri64i32 1
80B		%RSI<def> = COPY %vreg0<kill>; GR64:%vreg0
96B		%RDX<def> = MOV64ri64i32 1
112B		INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def>, $1:[reguse], %RAX, $2:[reguse], %RDI, $3:[reguse], %RSI<kill>, $4:[reguse], %RDX<kill>, $5:[clobber], %RCX<earlyclobber,imp-def,dead>, $6:[clobber], %R11<earlyclobber,imp-def,dead>, $7:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
128B		%vreg2<def> = COPY %RAX; GR64:%vreg2
144B		%RAX<def> = COPY %vreg2<kill>; GR64:%vreg2
160B		RET %RAX<imp-use>
> %RCX<def> = COPY %RDI
> %RAX<def> = MOV64ri64i32 1
> %RDI<def> = MOV64ri64i32 1
> %RSI<def> = COPY %RCX<kill>
> %RDX<def> = MOV64ri64i32 1
> INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def>, $1:[reguse], %RAX, $2:[reguse], %RDI, $3:[reguse], %RSI<kill>, $4:[reguse], %RDX<kill>, $5:[clobber], %RCX<earlyclobber,imp-def,dead>, $6:[clobber], %R11<earlyclobber,imp-def,dead>, $7:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
> %RAX<def> = COPY %RAX
Deleting identity copy.
> %RAX<def> = COPY %RAX<kill>
Deleting identity copy.
> RET %RAX<imp-use>
********** EMITTING LIVE DEBUG VARIABLES **********
********** Stack Slot Coloring **********
********** Function: puts
******** Post-regalloc Machine LICM: puts ********
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: puts
real copy:   %RCX<def> = COPY %RDI
replaced by: %RCX<def> = MOV64rr %RDI
real copy:   %RSI<def> = COPY %RCX<kill>
replaced by: %RSI<def> = MOV64rr %RCX<kill>
RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0
Frequency(BB#0 derived from LLVM BB entry) = 1024
********** FIX EXECUTION DEPENDENCIES: VR128 **********
The instruction being printed 1508 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 1504 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 1504 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 1508 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 1504 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 2234 1501 1647 1642 1506 1648 1643 1645 1640Computing probabilities for entry



=== llstrlen
5
is64bit 1
I've changed this to i64 from i16! Might break returns!Initial selection DAG: BB#0 'llstrlen:entry'
SelectionDAG has 8 nodes:
  0x2fbf468: ch = EntryToken

    0x2fbf468: <multiple use>
    0x2fe94d0: i64 = Register %vreg0

  0x2fe96d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe94d0

    0x2fbf468: <multiple use>
    0x2fe5c50: i64 = Register %RAX

    0x2fe95d0: i64 = Constant<1>

  0x2fe5e50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5c50, 0x2fe95d0

    0x2fe5e50: <multiple use>
    0x2fe93d0: i64 = TargetConstant<0>

    0x2fe5e50: <multiple use>
  0x2fe6150: ch = X86ISD::RET_FLAG 0x2fe5e50, 0x2fe93d0, 0x2fe5e50:1


Optimized lowered selection DAG: BB#0 'llstrlen:entry'
SelectionDAG has 6 nodes:
    0x2fbf468: ch = EntryToken

    0x2fe5c50: i64 = Register %RAX

    0x2fe95d0: i64 = Constant<1>

  0x2fe5e50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5c50, 0x2fe95d0

    0x2fe5e50: <multiple use>
    0x2fe93d0: i64 = TargetConstant<0>

    0x2fe5e50: <multiple use>
  0x2fe6150: ch = X86ISD::RET_FLAG 0x2fe5e50, 0x2fe93d0, 0x2fe5e50:1


Legally typed node: 0x2fe5c50: i64 = Register %RAX [ID=0]

Legally typed node: 0x2fe93d0: i64 = TargetConstant<0> [ID=0]

Legally typed node: 0x2fe95d0: i64 = Constant<1> [ID=0]

Legally typed node: 0x2fbf468: ch = EntryToken [ID=0]

Legally typed node: 0x2fe5e50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5c50, 0x2fe95d0 [ID=0]

Legally typed node: 0x2fe6150: ch = X86ISD::RET_FLAG 0x2fe5e50, 0x2fe93d0, 0x2fe5e50:1 [ID=0]

Legally typed node: 0x7fff8d52a470: ch = handlenode 0x2fe6150 [ID=0]

Type-legalized selection DAG: BB#0 'llstrlen:entry'
SelectionDAG has 6 nodes:
    0x2fbf468: ch = EntryToken [ID=-3]

    0x2fe5c50: i64 = Register %RAX [ID=-3]

    0x2fe95d0: i64 = Constant<1> [ID=-3]

  0x2fe5e50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5c50, 0x2fe95d0 [ID=-3]

    0x2fe5e50: <multiple use>
    0x2fe93d0: i64 = TargetConstant<0> [ID=-3]

    0x2fe5e50: <multiple use>
  0x2fe6150: ch = X86ISD::RET_FLAG 0x2fe5e50, 0x2fe93d0, 0x2fe5e50:1 [ID=-3]


In LegalizeDAG() 211
In legalize Op211
0
0
5
50
In LegalizeDAG() 42
In legalize Op42
0
50
0
5
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 29
In LegalizeDAG() 10
In legalize Op10
5
In LegalizeDAG() 1
In legalize Op1
0
Legalized selection DAG: BB#0 'llstrlen:entry'
SelectionDAG has 6 nodes:
    0x2fbf468: ch = EntryToken [ID=0]

    0x2fe5c50: i64 = Register %RAX [ID=3]

    0x2fe95d0: i64 = Constant<1> [ID=1]

  0x2fe5e50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5c50, 0x2fe95d0 [ID=4]

    0x2fe5e50: <multiple use>
    0x2fe93d0: i64 = TargetConstant<0> [ID=2]

    0x2fe5e50: <multiple use>
  0x2fe6150: ch = X86ISD::RET_FLAG 0x2fe5e50, 0x2fe93d0, 0x2fe5e50:1 [ID=5]


Optimized legalized selection DAG: BB#0 'llstrlen:entry'
SelectionDAG has 6 nodes:
    0x2fbf468: ch = EntryToken [ID=0]

    0x2fe5c50: i64 = Register %RAX [ID=3]

    0x2fe95d0: i64 = Constant<1> [ID=1]

  0x2fe5e50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5c50, 0x2fe95d0 [ID=4]

    0x2fe5e50: <multiple use>
    0x2fe93d0: i64 = TargetConstant<0> [ID=2]

    0x2fe5e50: <multiple use>
  0x2fe6150: ch = X86ISD::RET_FLAG 0x2fe5e50, 0x2fe93d0, 0x2fe5e50:1 [ID=5]


===== Instruction selection begins: BB#0 'entry'
Selecting: 0x2fe6150: ch = X86ISD::RET_FLAG 0x2fe5e50, 0x2fe93d0, 0x2fe5e50:1 [ID=5]

ISEL: Starting pattern match on root node: 0x2fe6150: ch = X86ISD::RET_FLAG 0x2fe5e50, 0x2fe93d0, 0x2fe5e50:1 [ID=5]

  Initial Opcode index to 81356
  Morphed node: 0x2fe6150: ch = RET 0x2fe5e50, 0x2fe5e50:1

ISEL: Match complete!
=> 0x2fe6150: ch = RET 0x2fe5e50, 0x2fe5e50:1

Selecting: 0x2fe5e50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5c50, 0x2fe95d0 [ID=4]

=> 0x2fe5e50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5c50, 0x2fe95d0

Selecting: 0x2fe5c50: i64 = Register %RAX [ID=3]

=> 0x2fe5c50: i64 = Register %RAX

Selecting: 0x2fe95d0: i64 = Constant<1> [ID=1]

ISEL: Starting pattern match on root node: 0x2fe95d0: i64 = Constant<1> [ID=1]

  Initial Opcode index to 83167
  Skipped scope entry (due to false predicate) at index 83169, continuing at 83219
  TypeSwitch[i64] from 83221 to 83224
  Morphed node: 0x2fe95d0: i64 = MOV64ri64i32 0x2fe93d0

ISEL: Match complete!
=> 0x2fe95d0: i64 = MOV64ri64i32 0x2fe93d0

Selecting: 0x2fbf468: ch = EntryToken [ID=0]

=> 0x2fbf468: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#0 'llstrlen:entry'
SelectionDAG has 6 nodes:
    0x2fbf468: ch = EntryToken

    0x2fe5c50: i64 = Register %RAX

      0x2fe93d0: i64 = TargetConstant<1>

    0x2fe95d0: i64 = MOV64ri64i32 0x2fe93d0

  0x2fe5e50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5c50, 0x2fe95d0

    0x2fe5e50: <multiple use>
    0x2fe5e50: <multiple use>
  0x2fe6150: ch = RET 0x2fe5e50, 0x2fe5e50:1


********** List Scheduling BB#0 'entry' **********
SU(0): 0x2fe6150: ch = RET 0x2fe5e50, 0x2fe5e50:1 [ID=0]

    0x2fe5e50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5c50, 0x2fe95d0 [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(1): Latency=1

SU(1): 0x2fe95d0: i64 = MOV64ri64i32 0x2fe93d0 [ID=1]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
   val SU(0): Latency=1


Examining Available:
Height 0: SU(0): 0x2fe6150: ch = RET 0x2fe5e50, 0x2fe5e50:1 [ID=0]

    0x2fe5e50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5c50, 0x2fe95d0 [ID=0]


*** Scheduling [0]: SU(0): 0x2fe6150: ch = RET 0x2fe5e50, 0x2fe5e50:1 [ID=0]

    0x2fe5e50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5c50, 0x2fe95d0 [ID=0]

GR64: 1 / 12

Examining Available:
Height 1: SU(1): 0x2fe95d0: i64 = MOV64ri64i32 0x2fe93d0 [ID=1]


*** Scheduling [1]: SU(1): 0x2fe95d0: i64 = MOV64ri64i32 0x2fe93d0 [ID=1]

*** Final schedule ***
SU(1): 0x2fe95d0: i64 = MOV64ri64i32 0x2fe93d0 [ID=1]

SU(0): 0x2fe6150: ch = RET 0x2fe5e50, 0x2fe5e50:1 [ID=0]

    0x2fe5e50: ch,glue = CopyToReg 0x2fbf468, 0x2fe5c50, 0x2fe95d0 [ID=0]


Total amount of phi nodes to update: 0
# Machine code for function llstrlen: SSA
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
16B		%vreg1<def> = MOV64ri64i32 1; GR64:%vreg1
32B		%RAX<def> = COPY %vreg1; GR64:%vreg1
48B		RET

# End machine code for function llstrlen.

********** Stack Coloring **********
********** Function: llstrlen
******** Pre-regalloc Machine LICM: llstrlen ********
Entering: entry
Exiting: entry
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: llstrlen
********** PROCESS IMPLICIT DEFS **********
********** Function: llstrlen
********** REWRITING TWO-ADDR INSTRS **********
********** Function: llstrlen
# Machine code for function llstrlen: Post SSA
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
16B		%vreg1<def> = MOV64ri64i32 1; GR64:%vreg1
32B		%RAX<def> = COPY %vreg1<kill>; GR64:%vreg1
48B		RET %RAX<imp-use,kill>

# End machine code for function llstrlen.

********** COMPUTING LIVE INTERVALS **********
********** Function: llstrlen
BB#0:		# derived from entry
16B	%vreg1<def> = MOV64ri64i32 1; GR64:%vreg1
		register: %vreg1 +[16r,32r:0)
32B	%RAX<def> = COPY %vreg1<kill>; GR64:%vreg1
48B	RET %RAX<imp-use,kill>
Computing live-in reg-units in ABI blocks.
Created 0 new intervals.
********** INTERVALS **********
%vreg1 = [16r,32r:0)  0@16r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function llstrlen: Post SSA
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
16B		%vreg1<def> = MOV64ri64i32 1; GR64:%vreg1
32B		%RAX<def> = COPY %vreg1<kill>; GR64:%vreg1
48B		RET %RAX<imp-use,kill>

# End machine code for function llstrlen.

********** COMPUTING LIVE DEBUG VARIABLES: llstrlen **********
********** DEBUG VARIABLES **********
********** SIMPLE REGISTER COALESCING **********
********** Function: llstrlen
********** JOINING INTERVALS ***********
entry:
32B	%RAX<def> = COPY %vreg1<kill>; GR64:%vreg1
	Considering merging %vreg1 with %RAX
	Can only merge into reserved registers.
Remat: %RAX<def> = MOV64ri64i32 1
Shrink: [16r,32r:0)  0@16r
All defs dead: 16r	%vreg1<def,dead> = MOV64ri64i32 1; GR64:%vreg1
Shrunk: [16r,16d:0)  0@16r
Deleting dead def 16r	%vreg1<def,dead> = MOV64ri64i32 1; GR64:%vreg1
Trying to inflate 0 regs.
********** INTERVALS **********
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function llstrlen: Post SSA
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
32B		%RAX<def> = MOV64ri64i32 1
48B		RET %RAX<imp-use,kill>

# End machine code for function llstrlen.

********** DEBUG VARIABLES **********
********** Compute Spill Weights **********
********** Function: llstrlen
********** GREEDY REGISTER ALLOCATION **********
********** Function: llstrlen
********** REWRITE VIRTUAL REGISTERS **********
********** Function: llstrlen
********** REGISTER MAP **********

0B	BB#0: derived from LLVM BB %entry
32B		%RAX<def> = MOV64ri64i32 1
48B		RET %RAX<imp-use,kill>
> %RAX<def> = MOV64ri64i32 1
> RET %RAX<imp-use,kill>
********** EMITTING LIVE DEBUG VARIABLES **********
********** Stack Slot Coloring **********
********** Function: llstrlen
******** Post-regalloc Machine LICM: llstrlen ********
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: llstrlen
RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0
Frequency(BB#0 derived from LLVM BB entry) = 1024
********** FIX EXECUTION DEPENDENCIES: VR128 **********
The instruction being printed 1504 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 2234 1501 1647 1642 1506 1648 1643 1645 1640CGP: Found      local addrmode: [Base:%s]
CGP: Found      local addrmode: [Base:%s]
Computing probabilities for entry



=== putchar
5
is64bit 1
5 4 {ax}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
5 0x2105940
5 4 {ax}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
5 0x2105940
5 4 {di}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
5 0x2105940
5 4 {si}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
5 0x2105940
5 4 {dx}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
5 0x2105940
0 5 {rcx}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x2105940
0 5 {r11}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x2105940
0 8 {memory}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x0
0 9 {dirflag}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x0
0 6 {fpsr}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x0
0 7 {flags}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x0
I've changed this to i64 from i16! Might break returns!Initial selection DAG: BB#0 'putchar:entry'
SelectionDAG has 30 nodes:
  0x2fbf468: ch = EntryToken [ORD=5]

  0x2fe5e50: i64 = FrameIndex<0> [ORD=4]

  0x2fe5c50: i64 = Constant<0>

  0x2fe96d0: i64 = Constant<1> [ORD=7]

  0x2fe5a50: i64 = Register %RAX [ORD=7]

      0x2fbf468: <multiple use>
        0x2fbf468: <multiple use>
        0x2fe93d0: i64 = Register %vreg0 [ORD=5]

      0x2fe6150: i64,ch = CopyFromReg 0x2fbf468, 0x2fe93d0 [ORD=5]

      0x2fe5e50: <multiple use>
      0x2fe95d0: i64 = undef [ORD=5]

    0x2fe94d0: ch = store 0x2fbf468, 0x2fe6150, 0x2fe5e50, 0x2fe95d0<ST8[%arrayidx1](tbaa=!"long long")> [ORD=5]

    0x2fe5a50: <multiple use>
    0x2fe96d0: <multiple use>
  0x2fe5b50: ch,glue = CopyToReg 0x2fe94d0, 0x2fe5a50, 0x2fe96d0 [ORD=7]

  0x2fe5d50: i32 = TargetConstant<9> [ORD=7]

  0x2fe6050: i64 = Register %RDI [ORD=7]

    0x2fe5b50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe96d0: <multiple use>
    0x2fe5b50: <multiple use>
  0x2fe6350: ch,glue = CopyToReg 0x2fe5b50, 0x2fe6050, 0x2fe96d0, 0x2fe5b50:1 [ORD=7]

  0x2fe6450: i64 = Register %RSI [ORD=7]

    0x2fe6350: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5e50: <multiple use>
    0x2fe6350: <multiple use>
  0x2fe92d0: ch,glue = CopyToReg 0x2fe6350, 0x2fe6450, 0x2fe5e50, 0x2fe6350:1 [ORD=7]

  0x2fe5850: i64 = Register %RDX [ORD=7]

    0x2fe92d0: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe96d0: <multiple use>
    0x2fe92d0: <multiple use>
  0x2fe5f50: ch,glue = CopyToReg 0x2fe92d0, 0x2fe5850, 0x2fe96d0, 0x2fe92d0:1 [ORD=7]

  0x2fe6250: i32 = TargetConstant<12> [ORD=7]

    0x2fe5f50: <multiple use>
    0x2fe6550: i64 = TargetExternalSymbol'syscall' [ORD=7]

    0x2fe90d0: ch = MDNode<0x2f9dfd0> [ORD=7]

    0x2fe97d0: i64 = TargetConstant<1> [ORD=7]

    0x2fe5950: i32 = TargetConstant<10> [ORD=7]

    0x2fe5a50: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5a50: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe6250: <multiple use>
    0x2fe8fd0: i64 = Register %RCX [ORD=7]

    0x2fe6250: <multiple use>
    0x2fe91d0: i64 = Register %R11 [ORD=7]

    0x2fe6250: <multiple use>
    0x2fe8ed0: i32 = Register %EFLAGS [ORD=7]

    0x2fe5f50: <multiple use>
  0x2fe8dd0: ch,glue = inlineasm 0x2fe5f50, 0x2fe6550, 0x2fe90d0, 0x2fe97d0, 0x2fe5950, 0x2fe5a50, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe6050, 0x2fe5d50, 0x2fe6450, 0x2fe5d50, 0x2fe5850, 0x2fe6250, 0x2fe8fd0, 0x2fe6250, 0x2fe91d0, 0x2fe6250, 0x2fe8ed0, 0x2fe5f50:1 [ORD=7]

    0x2fe8dd0: <multiple use>
    0x2fe5a50: <multiple use>
    0x2fe8dd0: <multiple use>
  0x2fe5750: i64,ch,glue = CopyFromReg 0x2fe8dd0, 0x2fe5a50, 0x2fe8dd0:1 [ORD=7]

    0x2fe5750: <multiple use>
    0x2fe5a50: <multiple use>
    0x2fe5750: <multiple use>
  0x2fe99d0: ch,glue = CopyToReg 0x2fe5750:1, 0x2fe5a50, 0x2fe5750

    0x2fe99d0: <multiple use>
    0x2fe98d0: i64 = TargetConstant<0>

    0x2fe99d0: <multiple use>
  0x2fe9ad0: ch = X86ISD::RET_FLAG 0x2fe99d0, 0x2fe98d0, 0x2fe99d0:1


Optimized lowered selection DAG: BB#0 'putchar:entry'
SelectionDAG has 29 nodes:
  0x2fbf468: ch = EntryToken [ORD=5]

  0x2fe5e50: i64 = FrameIndex<0> [ORD=4]

  0x2fe96d0: i64 = Constant<1> [ORD=7]

  0x2fe5a50: i64 = Register %RAX [ORD=7]

      0x2fbf468: <multiple use>
        0x2fbf468: <multiple use>
        0x2fe93d0: i64 = Register %vreg0 [ORD=5]

      0x2fe6150: i64,ch = CopyFromReg 0x2fbf468, 0x2fe93d0 [ORD=5]

      0x2fe5e50: <multiple use>
      0x2fe95d0: i64 = undef [ORD=5]

    0x2fe94d0: ch = store 0x2fbf468, 0x2fe6150, 0x2fe5e50, 0x2fe95d0<ST8[%arrayidx1](tbaa=!"long long")> [ORD=5]

    0x2fe5a50: <multiple use>
    0x2fe96d0: <multiple use>
  0x2fe5b50: ch,glue = CopyToReg 0x2fe94d0, 0x2fe5a50, 0x2fe96d0 [ORD=7]

  0x2fe5d50: i32 = TargetConstant<9> [ORD=7]

  0x2fe6050: i64 = Register %RDI [ORD=7]

    0x2fe5b50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe96d0: <multiple use>
    0x2fe5b50: <multiple use>
  0x2fe6350: ch,glue = CopyToReg 0x2fe5b50, 0x2fe6050, 0x2fe96d0, 0x2fe5b50:1 [ORD=7]

  0x2fe6450: i64 = Register %RSI [ORD=7]

    0x2fe6350: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5e50: <multiple use>
    0x2fe6350: <multiple use>
  0x2fe92d0: ch,glue = CopyToReg 0x2fe6350, 0x2fe6450, 0x2fe5e50, 0x2fe6350:1 [ORD=7]

  0x2fe5850: i64 = Register %RDX [ORD=7]

    0x2fe92d0: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe96d0: <multiple use>
    0x2fe92d0: <multiple use>
  0x2fe5f50: ch,glue = CopyToReg 0x2fe92d0, 0x2fe5850, 0x2fe96d0, 0x2fe92d0:1 [ORD=7]

  0x2fe6250: i32 = TargetConstant<12> [ORD=7]

    0x2fe5f50: <multiple use>
    0x2fe6550: i64 = TargetExternalSymbol'syscall' [ORD=7]

    0x2fe90d0: ch = MDNode<0x2f9dfd0> [ORD=7]

    0x2fe97d0: i64 = TargetConstant<1> [ORD=7]

    0x2fe5950: i32 = TargetConstant<10> [ORD=7]

    0x2fe5a50: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5a50: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe6250: <multiple use>
    0x2fe8fd0: i64 = Register %RCX [ORD=7]

    0x2fe6250: <multiple use>
    0x2fe91d0: i64 = Register %R11 [ORD=7]

    0x2fe6250: <multiple use>
    0x2fe8ed0: i32 = Register %EFLAGS [ORD=7]

    0x2fe5f50: <multiple use>
  0x2fe8dd0: ch,glue = inlineasm 0x2fe5f50, 0x2fe6550, 0x2fe90d0, 0x2fe97d0, 0x2fe5950, 0x2fe5a50, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe6050, 0x2fe5d50, 0x2fe6450, 0x2fe5d50, 0x2fe5850, 0x2fe6250, 0x2fe8fd0, 0x2fe6250, 0x2fe91d0, 0x2fe6250, 0x2fe8ed0, 0x2fe5f50:1 [ORD=7]

    0x2fe8dd0: <multiple use>
    0x2fe5a50: <multiple use>
    0x2fe8dd0: <multiple use>
  0x2fe5750: i64,ch,glue = CopyFromReg 0x2fe8dd0, 0x2fe5a50, 0x2fe8dd0:1 [ORD=7]

    0x2fe5750: <multiple use>
    0x2fe5a50: <multiple use>
    0x2fe5750: <multiple use>
  0x2fe99d0: ch,glue = CopyToReg 0x2fe5750:1, 0x2fe5a50, 0x2fe5750

    0x2fe99d0: <multiple use>
    0x2fe98d0: i64 = TargetConstant<0>

    0x2fe99d0: <multiple use>
  0x2fe9ad0: ch = X86ISD::RET_FLAG 0x2fe99d0, 0x2fe98d0, 0x2fe99d0:1


Legally typed node: 0x2fe98d0: i64 = TargetConstant<0> [ID=0]

Promote integer result: 0x2fe8ed0: i32 = Register %EFLAGS [ORD=7] [ID=0]

In Custom Lowering 8 4 1
Replacing Node Results. Node has OpCode
85
Legally typed node: 0x2fe5c50: i64 = Register %EFLAGS [ID=0]

Legally typed node: 0x2fe91d0: i64 = Register %R11 [ORD=7] [ID=0]

Legally typed node: 0x2fe8fd0: i64 = Register %RCX [ORD=7] [ID=0]

Legally typed node: 0x2fe6250: i32 = TargetConstant<12> [ORD=7] [ID=0]

Legally typed node: 0x2fe5850: i64 = Register %RDX [ORD=7] [ID=0]

Legally typed node: 0x2fe6450: i64 = Register %RSI [ORD=7] [ID=0]

Legally typed node: 0x2fe6050: i64 = Register %RDI [ORD=7] [ID=0]

Legally typed node: 0x2fe5d50: i32 = TargetConstant<9> [ORD=7] [ID=0]

Legally typed node: 0x2fe5a50: i64 = Register %RAX [ORD=7] [ID=0]

Legally typed node: 0x2fe5950: i32 = TargetConstant<10> [ORD=7] [ID=0]

Legally typed node: 0x2fe97d0: i64 = TargetConstant<1> [ORD=7] [ID=0]

Legally typed node: 0x2fe90d0: ch = MDNode<0x2f9dfd0> [ORD=7] [ID=0]

Legally typed node: 0x2fe6550: i64 = TargetExternalSymbol'syscall' [ORD=7] [ID=0]

Legally typed node: 0x2fe96d0: i64 = Constant<1> [ORD=7] [ID=0]

Legally typed node: 0x2fe95d0: i64 = undef [ORD=5] [ID=0]

Legally typed node: 0x2fe5e50: i64 = FrameIndex<0> [ORD=4] [ID=0]

Legally typed node: 0x2fe93d0: i64 = Register %vreg0 [ORD=5] [ID=0]

Legally typed node: 0x2fbf468: ch = EntryToken [ORD=5] [ID=0]

Legally typed node: 0x2fe6150: i64,ch = CopyFromReg 0x2fbf468, 0x2fe93d0 [ORD=5] [ID=0]

Legally typed node: 0x2fe94d0: ch = store 0x2fbf468, 0x2fe6150, 0x2fe5e50, 0x2fe95d0<ST8[%arrayidx1](tbaa=!"long long")> [ORD=5] [ID=0]

Legally typed node: 0x2fe5b50: ch,glue = CopyToReg 0x2fe94d0, 0x2fe5a50, 0x2fe96d0 [ORD=7] [ID=0]

Legally typed node: 0x2fe6350: ch,glue = CopyToReg 0x2fe5b50, 0x2fe6050, 0x2fe96d0, 0x2fe5b50:1 [ORD=7] [ID=0]

Legally typed node: 0x2fe92d0: ch,glue = CopyToReg 0x2fe6350, 0x2fe6450, 0x2fe5e50, 0x2fe6350:1 [ORD=7] [ID=0]

Legally typed node: 0x2fe5f50: ch,glue = CopyToReg 0x2fe92d0, 0x2fe5850, 0x2fe96d0, 0x2fe92d0:1 [ORD=7] [ID=0]

Legally typed node: 0x2fe8dd0: ch,glue = inlineasm 0x2fe5f50, 0x2fe6550, 0x2fe90d0, 0x2fe97d0, 0x2fe5950, 0x2fe5a50, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe6050, 0x2fe5d50, 0x2fe6450, 0x2fe5d50, 0x2fe5850, 0x2fe6250, 0x2fe8fd0, 0x2fe6250, 0x2fe91d0, 0x2fe6250, 0x2fe5c50, 0x2fe5f50:1 [ORD=7] [ID=0]

Legally typed node: 0x2fe5750: i64,ch,glue = CopyFromReg 0x2fe8dd0, 0x2fe5a50, 0x2fe8dd0:1 [ORD=7] [ID=0]

Legally typed node: 0x2fe99d0: ch,glue = CopyToReg 0x2fe5750:1, 0x2fe5a50, 0x2fe5750 [ID=0]

Legally typed node: 0x2fe9ad0: ch = X86ISD::RET_FLAG 0x2fe99d0, 0x2fe98d0, 0x2fe99d0:1 [ID=0]

Legally typed node: 0x7fff8d52a470: ch = handlenode 0x2fe9ad0 [ID=0]

Type-legalized selection DAG: BB#0 'putchar:entry'
SelectionDAG has 29 nodes:
  0x2fbf468: ch = EntryToken [ORD=5] [ID=-3]

  0x2fe5e50: i64 = FrameIndex<0> [ORD=4] [ID=-3]

  0x2fe96d0: i64 = Constant<1> [ORD=7] [ID=-3]

  0x2fe5a50: i64 = Register %RAX [ORD=7] [ID=-3]

      0x2fbf468: <multiple use>
        0x2fbf468: <multiple use>
        0x2fe93d0: i64 = Register %vreg0 [ORD=5] [ID=-3]

      0x2fe6150: i64,ch = CopyFromReg 0x2fbf468, 0x2fe93d0 [ORD=5] [ID=-3]

      0x2fe5e50: <multiple use>
      0x2fe95d0: i64 = undef [ORD=5] [ID=-3]

    0x2fe94d0: ch = store 0x2fbf468, 0x2fe6150, 0x2fe5e50, 0x2fe95d0<ST8[%arrayidx1](tbaa=!"long long")> [ORD=5] [ID=-3]

    0x2fe5a50: <multiple use>
    0x2fe96d0: <multiple use>
  0x2fe5b50: ch,glue = CopyToReg 0x2fe94d0, 0x2fe5a50, 0x2fe96d0 [ORD=7] [ID=-3]

  0x2fe5d50: i32 = TargetConstant<9> [ORD=7] [ID=-3]

  0x2fe6050: i64 = Register %RDI [ORD=7] [ID=-3]

    0x2fe5b50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe96d0: <multiple use>
    0x2fe5b50: <multiple use>
  0x2fe6350: ch,glue = CopyToReg 0x2fe5b50, 0x2fe6050, 0x2fe96d0, 0x2fe5b50:1 [ORD=7] [ID=-3]

  0x2fe6450: i64 = Register %RSI [ORD=7] [ID=-3]

    0x2fe6350: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5e50: <multiple use>
    0x2fe6350: <multiple use>
  0x2fe92d0: ch,glue = CopyToReg 0x2fe6350, 0x2fe6450, 0x2fe5e50, 0x2fe6350:1 [ORD=7] [ID=-3]

  0x2fe5850: i64 = Register %RDX [ORD=7] [ID=-3]

    0x2fe92d0: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe96d0: <multiple use>
    0x2fe92d0: <multiple use>
  0x2fe5f50: ch,glue = CopyToReg 0x2fe92d0, 0x2fe5850, 0x2fe96d0, 0x2fe92d0:1 [ORD=7] [ID=-3]

  0x2fe6250: i32 = TargetConstant<12> [ORD=7] [ID=-3]

    0x2fe5f50: <multiple use>
    0x2fe6550: i64 = TargetExternalSymbol'syscall' [ORD=7] [ID=-3]

    0x2fe90d0: ch = MDNode<0x2f9dfd0> [ORD=7] [ID=-3]

    0x2fe97d0: i64 = TargetConstant<1> [ORD=7] [ID=-3]

    0x2fe5950: i32 = TargetConstant<10> [ORD=7] [ID=-3]

    0x2fe5a50: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5a50: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe6250: <multiple use>
    0x2fe8fd0: i64 = Register %RCX [ORD=7] [ID=-3]

    0x2fe6250: <multiple use>
    0x2fe91d0: i64 = Register %R11 [ORD=7] [ID=-3]

    0x2fe6250: <multiple use>
    0x2fe5c50: i64 = Register %EFLAGS [ID=-3]

    0x2fe5f50: <multiple use>
  0x2fe8dd0: ch,glue = inlineasm 0x2fe5f50, 0x2fe6550, 0x2fe90d0, 0x2fe97d0, 0x2fe5950, 0x2fe5a50, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe6050, 0x2fe5d50, 0x2fe6450, 0x2fe5d50, 0x2fe5850, 0x2fe6250, 0x2fe8fd0, 0x2fe6250, 0x2fe91d0, 0x2fe6250, 0x2fe5c50, 0x2fe5f50:1 [ORD=7] [ID=-3]

    0x2fe8dd0: <multiple use>
    0x2fe5a50: <multiple use>
    0x2fe8dd0: <multiple use>
  0x2fe5750: i64,ch,glue = CopyFromReg 0x2fe8dd0, 0x2fe5a50, 0x2fe8dd0:1 [ORD=7] [ID=-3]

    0x2fe5750: <multiple use>
    0x2fe5a50: <multiple use>
    0x2fe5750: <multiple use>
  0x2fe99d0: ch,glue = CopyToReg 0x2fe5750:1, 0x2fe5a50, 0x2fe5750 [ID=-3]

    0x2fe99d0: <multiple use>
    0x2fe98d0: i64 = TargetConstant<0> [ID=-3]

    0x2fe99d0: <multiple use>
  0x2fe9ad0: ch = X86ISD::RET_FLAG 0x2fe99d0, 0x2fe98d0, 0x2fe99d0:1 [ID=-3]


Optimized type-legalized selection DAG: BB#0 'putchar:entry'
SelectionDAG has 29 nodes:
  0x2fbf468: ch = EntryToken [ORD=5] [ID=-3]

  0x2fe5e50: i64 = FrameIndex<0> [ORD=4] [ID=-3]

  0x2fe96d0: i64 = Constant<1> [ORD=7] [ID=-3]

  0x2fe5a50: i64 = Register %RAX [ORD=7] [ID=-3]

      0x2fbf468: <multiple use>
        0x2fbf468: <multiple use>
        0x2fe93d0: i64 = Register %vreg0 [ORD=5] [ID=-3]

      0x2fe6150: i64,ch = CopyFromReg 0x2fbf468, 0x2fe93d0 [ORD=5] [ID=-3]

      0x2fe5e50: <multiple use>
      0x2fe95d0: i64 = undef [ORD=5] [ID=-3]

    0x2fe94d0: ch = store 0x2fbf468, 0x2fe6150, 0x2fe5e50, 0x2fe95d0<ST8[%arrayidx1](tbaa=!"long long")> [ORD=5] [ID=-3]

    0x2fe5a50: <multiple use>
    0x2fe96d0: <multiple use>
  0x2fe5b50: ch,glue = CopyToReg 0x2fe94d0, 0x2fe5a50, 0x2fe96d0 [ORD=7] [ID=-3]

  0x2fe5d50: i32 = TargetConstant<9> [ORD=7] [ID=-3]

  0x2fe6050: i64 = Register %RDI [ORD=7] [ID=-3]

    0x2fe5b50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe96d0: <multiple use>
    0x2fe5b50: <multiple use>
  0x2fe6350: ch,glue = CopyToReg 0x2fe5b50, 0x2fe6050, 0x2fe96d0, 0x2fe5b50:1 [ORD=7] [ID=-3]

  0x2fe6450: i64 = Register %RSI [ORD=7] [ID=-3]

    0x2fe6350: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5e50: <multiple use>
    0x2fe6350: <multiple use>
  0x2fe92d0: ch,glue = CopyToReg 0x2fe6350, 0x2fe6450, 0x2fe5e50, 0x2fe6350:1 [ORD=7] [ID=-3]

  0x2fe5850: i64 = Register %RDX [ORD=7] [ID=-3]

    0x2fe92d0: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe96d0: <multiple use>
    0x2fe92d0: <multiple use>
  0x2fe5f50: ch,glue = CopyToReg 0x2fe92d0, 0x2fe5850, 0x2fe96d0, 0x2fe92d0:1 [ORD=7] [ID=-3]

  0x2fe6250: i32 = TargetConstant<12> [ORD=7] [ID=-3]

    0x2fe5f50: <multiple use>
    0x2fe6550: i64 = TargetExternalSymbol'syscall' [ORD=7] [ID=-3]

    0x2fe90d0: ch = MDNode<0x2f9dfd0> [ORD=7] [ID=-3]

    0x2fe97d0: i64 = TargetConstant<1> [ORD=7] [ID=-3]

    0x2fe5950: i32 = TargetConstant<10> [ORD=7] [ID=-3]

    0x2fe5a50: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5a50: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe6250: <multiple use>
    0x2fe8fd0: i64 = Register %RCX [ORD=7] [ID=-3]

    0x2fe6250: <multiple use>
    0x2fe91d0: i64 = Register %R11 [ORD=7] [ID=-3]

    0x2fe6250: <multiple use>
    0x2fe5c50: i64 = Register %EFLAGS [ID=-3]

    0x2fe5f50: <multiple use>
  0x2fe8dd0: ch,glue = inlineasm 0x2fe5f50, 0x2fe6550, 0x2fe90d0, 0x2fe97d0, 0x2fe5950, 0x2fe5a50, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe6050, 0x2fe5d50, 0x2fe6450, 0x2fe5d50, 0x2fe5850, 0x2fe6250, 0x2fe8fd0, 0x2fe6250, 0x2fe91d0, 0x2fe6250, 0x2fe5c50, 0x2fe5f50:1 [ORD=7] [ID=-3]

    0x2fe8dd0: <multiple use>
    0x2fe5a50: <multiple use>
    0x2fe8dd0: <multiple use>
  0x2fe5750: i64,ch,glue = CopyFromReg 0x2fe8dd0, 0x2fe5a50, 0x2fe8dd0:1 [ORD=7] [ID=-3]

    0x2fe5750: <multiple use>
    0x2fe5a50: <multiple use>
    0x2fe5750: <multiple use>
  0x2fe99d0: ch,glue = CopyToReg 0x2fe5750:1, 0x2fe5a50, 0x2fe5750 [ID=-3]

    0x2fe99d0: <multiple use>
    0x2fe98d0: i64 = TargetConstant<0> [ID=-3]

    0x2fe99d0: <multiple use>
  0x2fe9ad0: ch = X86ISD::RET_FLAG 0x2fe99d0, 0x2fe98d0, 0x2fe99d0:1 [ID=-3]


In LegalizeDAG() 211
In legalize Op211
0
0
5
50
In LegalizeDAG() 42
In legalize Op42
0
50
0
5
5
In LegalizeDAG() 43
In legalize Op43
5
0
50
0
5
50
In LegalizeDAG() 151
In legalize Op151
0
50
0
5
0
5
4
5
4
5
4
5
4
5
4
5
4
5
4
5
4
5
50
In LegalizeDAG() 42
In legalize Op42
0
50
0
5
5
50
In LegalizeDAG() 42
In legalize Op42
0
50
0
5
5
50
In LegalizeDAG() 42
In legalize Op42
0
50
0
5
5
50
In LegalizeDAG() 42
In legalize Op42
0
50
0
5
5
In LegalizeDAG() 144
In legalize Op144
0
0
5
5
5
In LegalizeDAG() 43
In legalize Op43
5
0
0
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 29
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 29
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 29
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 29
In LegalizeDAG() 29
In LegalizeDAG() 162
In legalize Op162
0
In LegalizeDAG() 36
In legalize Op36
5
In LegalizeDAG() 10
In legalize Op10
5
In LegalizeDAG() 44
In legalize Op44
5
In LegalizeDAG() 14
In legalize Op14
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 1
In legalize Op1
0
Legalized selection DAG: BB#0 'putchar:entry'
SelectionDAG has 29 nodes:
  0x2fbf468: ch = EntryToken [ORD=5] [ID=0]

  0x2fe5e50: i64 = FrameIndex<0> [ORD=4] [ID=2]

  0x2fe96d0: i64 = Constant<1> [ORD=7] [ID=4]

  0x2fe5a50: i64 = Register %RAX [ORD=7] [ID=9]

  0x2fe5d50: i32 = TargetConstant<9> [ORD=7] [ID=10]

  0x2fe6050: i64 = Register %RDI [ORD=7] [ID=11]

  0x2fe6450: i64 = Register %RSI [ORD=7] [ID=12]

  0x2fe5850: i64 = Register %RDX [ORD=7] [ID=13]

  0x2fe6250: i32 = TargetConstant<12> [ORD=7] [ID=14]

      0x2fbf468: <multiple use>
        0x2fbf468: <multiple use>
        0x2fe93d0: i64 = Register %vreg0 [ORD=5] [ID=1]

      0x2fe6150: i64,ch = CopyFromReg 0x2fbf468, 0x2fe93d0 [ORD=5] [ID=19]

      0x2fe5e50: <multiple use>
      0x2fe95d0: i64 = undef [ORD=5] [ID=3]

    0x2fe94d0: ch = store 0x2fbf468, 0x2fe6150, 0x2fe5e50, 0x2fe95d0<ST8[%arrayidx1](tbaa=!"long long")> [ORD=5] [ID=20]

    0x2fe5a50: <multiple use>
    0x2fe96d0: <multiple use>
  0x2fe5b50: ch,glue = CopyToReg 0x2fe94d0, 0x2fe5a50, 0x2fe96d0 [ORD=7] [ID=21]

    0x2fe5b50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe96d0: <multiple use>
    0x2fe5b50: <multiple use>
  0x2fe6350: ch,glue = CopyToReg 0x2fe5b50, 0x2fe6050, 0x2fe96d0, 0x2fe5b50:1 [ORD=7] [ID=22]

    0x2fe6350: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5e50: <multiple use>
    0x2fe6350: <multiple use>
  0x2fe92d0: ch,glue = CopyToReg 0x2fe6350, 0x2fe6450, 0x2fe5e50, 0x2fe6350:1 [ORD=7] [ID=23]

    0x2fe92d0: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe96d0: <multiple use>
    0x2fe92d0: <multiple use>
  0x2fe5f50: ch,glue = CopyToReg 0x2fe92d0, 0x2fe5850, 0x2fe96d0, 0x2fe92d0:1 [ORD=7] [ID=24]

    0x2fe5f50: <multiple use>
    0x2fe6550: i64 = TargetExternalSymbol'syscall' [ORD=7] [ID=5]

    0x2fe90d0: ch = MDNode<0x2f9dfd0> [ORD=7] [ID=6]

    0x2fe97d0: i64 = TargetConstant<1> [ORD=7] [ID=7]

    0x2fe5950: i32 = TargetConstant<10> [ORD=7] [ID=8]

    0x2fe5a50: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5a50: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe6250: <multiple use>
    0x2fe8fd0: i64 = Register %RCX [ORD=7] [ID=15]

    0x2fe6250: <multiple use>
    0x2fe91d0: i64 = Register %R11 [ORD=7] [ID=16]

    0x2fe6250: <multiple use>
    0x2fe5c50: i64 = Register %EFLAGS [ID=18]

    0x2fe5f50: <multiple use>
  0x2fe8dd0: ch,glue = inlineasm 0x2fe5f50, 0x2fe6550, 0x2fe90d0, 0x2fe97d0, 0x2fe5950, 0x2fe5a50, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe6050, 0x2fe5d50, 0x2fe6450, 0x2fe5d50, 0x2fe5850, 0x2fe6250, 0x2fe8fd0, 0x2fe6250, 0x2fe91d0, 0x2fe6250, 0x2fe5c50, 0x2fe5f50:1 [ORD=7] [ID=25]

    0x2fe8dd0: <multiple use>
    0x2fe5a50: <multiple use>
    0x2fe8dd0: <multiple use>
  0x2fe5750: i64,ch,glue = CopyFromReg 0x2fe8dd0, 0x2fe5a50, 0x2fe8dd0:1 [ORD=7] [ID=26]

    0x2fe5750: <multiple use>
    0x2fe5a50: <multiple use>
    0x2fe5750: <multiple use>
  0x2fe99d0: ch,glue = CopyToReg 0x2fe5750:1, 0x2fe5a50, 0x2fe5750 [ID=27]

    0x2fe99d0: <multiple use>
    0x2fe98d0: i64 = TargetConstant<0> [ID=17]

    0x2fe99d0: <multiple use>
  0x2fe9ad0: ch = X86ISD::RET_FLAG 0x2fe99d0, 0x2fe98d0, 0x2fe99d0:1 [ID=28]


Optimized legalized selection DAG: BB#0 'putchar:entry'
SelectionDAG has 29 nodes:
  0x2fbf468: ch = EntryToken [ORD=5] [ID=0]

  0x2fe5e50: i64 = FrameIndex<0> [ORD=4] [ID=2]

  0x2fe96d0: i64 = Constant<1> [ORD=7] [ID=4]

  0x2fe5a50: i64 = Register %RAX [ORD=7] [ID=9]

  0x2fe5d50: i32 = TargetConstant<9> [ORD=7] [ID=10]

  0x2fe6050: i64 = Register %RDI [ORD=7] [ID=11]

  0x2fe6450: i64 = Register %RSI [ORD=7] [ID=12]

  0x2fe5850: i64 = Register %RDX [ORD=7] [ID=13]

  0x2fe6250: i32 = TargetConstant<12> [ORD=7] [ID=14]

      0x2fbf468: <multiple use>
        0x2fbf468: <multiple use>
        0x2fe93d0: i64 = Register %vreg0 [ORD=5] [ID=1]

      0x2fe6150: i64,ch = CopyFromReg 0x2fbf468, 0x2fe93d0 [ORD=5] [ID=19]

      0x2fe5e50: <multiple use>
      0x2fe95d0: i64 = undef [ORD=5] [ID=3]

    0x2fe94d0: ch = store 0x2fbf468, 0x2fe6150, 0x2fe5e50, 0x2fe95d0<ST8[%arrayidx1](tbaa=!"long long")> [ORD=5] [ID=20]

    0x2fe5a50: <multiple use>
    0x2fe96d0: <multiple use>
  0x2fe5b50: ch,glue = CopyToReg 0x2fe94d0, 0x2fe5a50, 0x2fe96d0 [ORD=7] [ID=21]

    0x2fe5b50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe96d0: <multiple use>
    0x2fe5b50: <multiple use>
  0x2fe6350: ch,glue = CopyToReg 0x2fe5b50, 0x2fe6050, 0x2fe96d0, 0x2fe5b50:1 [ORD=7] [ID=22]

    0x2fe6350: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5e50: <multiple use>
    0x2fe6350: <multiple use>
  0x2fe92d0: ch,glue = CopyToReg 0x2fe6350, 0x2fe6450, 0x2fe5e50, 0x2fe6350:1 [ORD=7] [ID=23]

    0x2fe92d0: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe96d0: <multiple use>
    0x2fe92d0: <multiple use>
  0x2fe5f50: ch,glue = CopyToReg 0x2fe92d0, 0x2fe5850, 0x2fe96d0, 0x2fe92d0:1 [ORD=7] [ID=24]

    0x2fe5f50: <multiple use>
    0x2fe6550: i64 = TargetExternalSymbol'syscall' [ORD=7] [ID=5]

    0x2fe90d0: ch = MDNode<0x2f9dfd0> [ORD=7] [ID=6]

    0x2fe97d0: i64 = TargetConstant<1> [ORD=7] [ID=7]

    0x2fe5950: i32 = TargetConstant<10> [ORD=7] [ID=8]

    0x2fe5a50: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5a50: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe6250: <multiple use>
    0x2fe8fd0: i64 = Register %RCX [ORD=7] [ID=15]

    0x2fe6250: <multiple use>
    0x2fe91d0: i64 = Register %R11 [ORD=7] [ID=16]

    0x2fe6250: <multiple use>
    0x2fe5c50: i64 = Register %EFLAGS [ID=18]

    0x2fe5f50: <multiple use>
  0x2fe8dd0: ch,glue = inlineasm 0x2fe5f50, 0x2fe6550, 0x2fe90d0, 0x2fe97d0, 0x2fe5950, 0x2fe5a50, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe6050, 0x2fe5d50, 0x2fe6450, 0x2fe5d50, 0x2fe5850, 0x2fe6250, 0x2fe8fd0, 0x2fe6250, 0x2fe91d0, 0x2fe6250, 0x2fe5c50, 0x2fe5f50:1 [ORD=7] [ID=25]

    0x2fe8dd0: <multiple use>
    0x2fe5a50: <multiple use>
    0x2fe8dd0: <multiple use>
  0x2fe5750: i64,ch,glue = CopyFromReg 0x2fe8dd0, 0x2fe5a50, 0x2fe8dd0:1 [ORD=7] [ID=26]

    0x2fe5750: <multiple use>
    0x2fe5a50: <multiple use>
    0x2fe5750: <multiple use>
  0x2fe99d0: ch,glue = CopyToReg 0x2fe5750:1, 0x2fe5a50, 0x2fe5750 [ID=27]

    0x2fe99d0: <multiple use>
    0x2fe98d0: i64 = TargetConstant<0> [ID=17]

    0x2fe99d0: <multiple use>
  0x2fe9ad0: ch = X86ISD::RET_FLAG 0x2fe99d0, 0x2fe98d0, 0x2fe99d0:1 [ID=28]


===== Instruction selection begins: BB#0 'entry'
Selecting: 0x2fe9ad0: ch = X86ISD::RET_FLAG 0x2fe99d0, 0x2fe98d0, 0x2fe99d0:1 [ID=28]

ISEL: Starting pattern match on root node: 0x2fe9ad0: ch = X86ISD::RET_FLAG 0x2fe99d0, 0x2fe98d0, 0x2fe99d0:1 [ID=28]

  Initial Opcode index to 81356
  Morphed node: 0x2fe9ad0: ch = RET 0x2fe99d0, 0x2fe99d0:1

ISEL: Match complete!
=> 0x2fe9ad0: ch = RET 0x2fe99d0, 0x2fe99d0:1

Selecting: 0x2fe99d0: ch,glue = CopyToReg 0x2fe5750:1, 0x2fe5a50, 0x2fe5750 [ID=27]

=> 0x2fe99d0: ch,glue = CopyToReg 0x2fe5750:1, 0x2fe5a50, 0x2fe5750

Selecting: 0x2fe5750: i64,ch,glue = CopyFromReg 0x2fe8dd0, 0x2fe5a50, 0x2fe8dd0:1 [ORD=7] [ID=26]

=> 0x2fe5750: i64,ch,glue = CopyFromReg 0x2fe8dd0, 0x2fe5a50, 0x2fe8dd0:1 [ORD=7]

Selecting: 0x2fe8dd0: ch,glue = inlineasm 0x2fe5f50, 0x2fe6550, 0x2fe90d0, 0x2fe97d0, 0x2fe5950, 0x2fe5a50, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe6050, 0x2fe5d50, 0x2fe6450, 0x2fe5d50, 0x2fe5850, 0x2fe6250, 0x2fe8fd0, 0x2fe6250, 0x2fe91d0, 0x2fe6250, 0x2fe5c50, 0x2fe5f50:1 [ORD=7] [ID=25]

=> 0x2fe98d0: ch,glue = inlineasm 0x2fe5f50, 0x2fe6550, 0x2fe90d0, 0x2fe97d0, 0x2fe5950, 0x2fe5a50, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe6050, 0x2fe5d50, 0x2fe6450, 0x2fe5d50, 0x2fe5850, 0x2fe6250, 0x2fe8fd0, 0x2fe6250, 0x2fe91d0, 0x2fe6250, 0x2fe5c50, 0x2fe5f50:1

Selecting: 0x2fe5f50: ch,glue = CopyToReg 0x2fe92d0, 0x2fe5850, 0x2fe96d0, 0x2fe92d0:1 [ORD=7] [ID=24]

=> 0x2fe5f50: ch,glue = CopyToReg 0x2fe92d0, 0x2fe5850, 0x2fe96d0, 0x2fe92d0:1 [ORD=7]

Selecting: 0x2fe92d0: ch,glue = CopyToReg 0x2fe6350, 0x2fe6450, 0x2fe5e50, 0x2fe6350:1 [ORD=7] [ID=23]

=> 0x2fe92d0: ch,glue = CopyToReg 0x2fe6350, 0x2fe6450, 0x2fe5e50, 0x2fe6350:1 [ORD=7]

Selecting: 0x2fe6350: ch,glue = CopyToReg 0x2fe5b50, 0x2fe6050, 0x2fe96d0, 0x2fe5b50:1 [ORD=7] [ID=22]

=> 0x2fe6350: ch,glue = CopyToReg 0x2fe5b50, 0x2fe6050, 0x2fe96d0, 0x2fe5b50:1 [ORD=7]

Selecting: 0x2fe5b50: ch,glue = CopyToReg 0x2fe94d0, 0x2fe5a50, 0x2fe96d0 [ORD=7] [ID=21]

=> 0x2fe5b50: ch,glue = CopyToReg 0x2fe94d0, 0x2fe5a50, 0x2fe96d0 [ORD=7]

Selecting: 0x2fe94d0: ch = store 0x2fbf468, 0x2fe6150, 0x2fe5e50, 0x2fe95d0<ST8[%arrayidx1](tbaa=!"long long")> [ORD=5] [ID=20]

ISEL: Starting pattern match on root node: 0x2fe94d0: ch = store 0x2fbf468, 0x2fe6150, 0x2fe5e50, 0x2fe95d0<ST8[%arrayidx1](tbaa=!"long long")> [ORD=5] [ID=20]

  Initial Opcode index to 5
  Skipped scope entry (due to false predicate) at index 13, continuing at 58
  Skipped scope entry (due to false predicate) at index 59, continuing at 104
  Skipped scope entry (due to false predicate) at index 105, continuing at 150
  Skipped scope entry (due to false predicate) at index 151, continuing at 174
  Skipped scope entry (due to false predicate) at index 175, continuing at 198
  Skipped scope entry (due to false predicate) at index 199, continuing at 222
  Skipped scope entry (due to false predicate) at index 223, continuing at 246
  Match failed at index 250
  Continuing at 270
  Continuing at 271
  Match failed at index 275
  Continuing at 11364
  Match failed at index 11369
  Continuing at 11681
  Match failed at index 11685
  Continuing at 12065
  Match failed at index 12069
  Continuing at 12186
  Match failed at index 12190
  Continuing at 12382
  Skipped scope entry (due to false predicate) at index 12387, continuing at 12454
  Skipped scope entry (due to false predicate) at index 12455, continuing at 12549
  Skipped scope entry (due to false predicate) at index 12550, continuing at 12622
  Skipped scope entry (due to false predicate) at index 12623, continuing at 12648
  Skipped scope entry (due to false predicate) at index 12649, continuing at 12674
  Skipped scope entry (due to false predicate) at index 12675, continuing at 12700
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Morphed node: 0x2fe94d0: ch = MOV64mr 0x2fe8ed0, 0x2fe9bd0, 0x2fe8dd0, 0x3003e20, 0x3003f20, 0x2fe6150, 0x2fbf468<Mem:ST8[%arrayidx1](tbaa=!"long long")> [ORD=5]

ISEL: Match complete!
=> 0x2fe94d0: ch = MOV64mr 0x2fe8ed0, 0x2fe9bd0, 0x2fe8dd0, 0x3003e20, 0x3003f20, 0x2fe6150, 0x2fbf468<Mem:ST8[%arrayidx1](tbaa=!"long long")> [ORD=5]

Selecting: 0x2fe6150: i64,ch = CopyFromReg 0x2fbf468, 0x2fe93d0 [ORD=5] [ID=19]

=> 0x2fe6150: i64,ch = CopyFromReg 0x2fbf468, 0x2fe93d0 [ORD=5]

Selecting: 0x2fe5c50: i64 = Register %EFLAGS [ID=18]

=> 0x2fe5c50: i64 = Register %EFLAGS

Selecting: 0x2fe91d0: i64 = Register %R11 [ORD=7] [ID=16]

=> 0x2fe91d0: i64 = Register %R11 [ORD=7]

Selecting: 0x2fe8fd0: i64 = Register %RCX [ORD=7] [ID=15]

=> 0x2fe8fd0: i64 = Register %RCX [ORD=7]

Selecting: 0x2fe6250: i32 = TargetConstant<12> [ORD=7] [ID=14]

=> 0x2fe6250: i32 = TargetConstant<12> [ORD=7]

Selecting: 0x2fe5850: i64 = Register %RDX [ORD=7] [ID=13]

=> 0x2fe5850: i64 = Register %RDX [ORD=7]

Selecting: 0x2fe6450: i64 = Register %RSI [ORD=7] [ID=12]

=> 0x2fe6450: i64 = Register %RSI [ORD=7]

Selecting: 0x2fe6050: i64 = Register %RDI [ORD=7] [ID=11]

=> 0x2fe6050: i64 = Register %RDI [ORD=7]

Selecting: 0x2fe5d50: i32 = TargetConstant<9> [ORD=7] [ID=10]

=> 0x2fe5d50: i32 = TargetConstant<9> [ORD=7]

Selecting: 0x2fe5a50: i64 = Register %RAX [ORD=7] [ID=9]

=> 0x2fe5a50: i64 = Register %RAX [ORD=7]

Selecting: 0x2fe5950: i32 = TargetConstant<10> [ORD=7] [ID=8]

=> 0x2fe5950: i32 = TargetConstant<10> [ORD=7]

Selecting: 0x2fe97d0: i64 = TargetConstant<1> [ORD=7] [ID=7]

=> 0x2fe97d0: i64 = TargetConstant<1> [ORD=7]

Selecting: 0x2fe90d0: ch = MDNode<0x2f9dfd0> [ORD=7] [ID=6]

=> 0x2fe90d0: ch = MDNode<0x2f9dfd0> [ORD=7]

Selecting: 0x2fe6550: i64 = TargetExternalSymbol'syscall' [ORD=7] [ID=5]

=> 0x2fe6550: i64 = TargetExternalSymbol'syscall' [ORD=7]

Selecting: 0x2fe96d0: i64 = Constant<1> [ORD=7] [ID=4]

ISEL: Starting pattern match on root node: 0x2fe96d0: i64 = Constant<1> [ORD=7] [ID=4]

  Initial Opcode index to 83167
  Skipped scope entry (due to false predicate) at index 83169, continuing at 83219
  TypeSwitch[i64] from 83221 to 83224
  Morphed node: 0x2fe96d0: i64 = MOV64ri64i32 0x2fe97d0 [ORD=7]

ISEL: Match complete!
=> 0x2fe96d0: i64 = MOV64ri64i32 0x2fe97d0 [ORD=7]

Selecting: 0x2fe5e50: i64 = FrameIndex<0> [ORD=4] [ID=2]

ISEL: Starting pattern match on root node: 0x2fe5e50: i64 = FrameIndex<0> [ORD=4] [ID=2]

  Initial Opcode index to 77242
  TypeSwitch[i64] from 77243 to 77286
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Morphed node: 0x2fe5e50: i64 = LEA64r 0x2fe8ed0, 0x2fe9bd0, 0x2fe8dd0, 0x3003e20, 0x3003f20 [ORD=4]

ISEL: Match complete!
=> 0x2fe5e50: i64 = LEA64r 0x2fe8ed0, 0x2fe9bd0, 0x2fe8dd0, 0x3003e20, 0x3003f20 [ORD=4]

Selecting: 0x2fe93d0: i64 = Register %vreg0 [ORD=5] [ID=1]

=> 0x2fe93d0: i64 = Register %vreg0 [ORD=5]

Selecting: 0x2fbf468: ch = EntryToken [ORD=5] [ID=0]

=> 0x2fbf468: ch = EntryToken [ORD=5]

===== Instruction selection ends:
Selected selection DAG: BB#0 'putchar:entry'
SelectionDAG has 32 nodes:
  0x2fbf468: ch = EntryToken [ORD=5]

    0x2fe97d0: <multiple use>
  0x2fe96d0: i64 = MOV64ri64i32 0x2fe97d0 [ORD=7]

  0x2fe97d0: i64 = TargetConstant<1> [ORD=7]

  0x2fe5a50: i64 = Register %RAX [ORD=7]

  0x2fe5d50: i32 = TargetConstant<9> [ORD=7]

  0x2fe6050: i64 = Register %RDI [ORD=7]

  0x2fe6450: i64 = Register %RSI [ORD=7]

  0x2fe5850: i64 = Register %RDX [ORD=7]

  0x2fe6250: i32 = TargetConstant<12> [ORD=7]

      0x2fe8ed0: <multiple use>
      0x2fe9bd0: <multiple use>
      0x2fe8dd0: <multiple use>
      0x3003e20: <multiple use>
      0x3003f20: <multiple use>
        0x2fbf468: <multiple use>
        0x2fe93d0: i64 = Register %vreg0 [ORD=5]

      0x2fe6150: i64,ch = CopyFromReg 0x2fbf468, 0x2fe93d0 [ORD=5]

      0x2fbf468: <multiple use>
    0x2fe94d0: ch = MOV64mr 0x2fe8ed0, 0x2fe9bd0, 0x2fe8dd0, 0x3003e20, 0x3003f20, 0x2fe6150, 0x2fbf468<Mem:ST8[%arrayidx1](tbaa=!"long long")> [ORD=5]

    0x2fe5a50: <multiple use>
    0x2fe96d0: <multiple use>
  0x2fe5b50: ch,glue = CopyToReg 0x2fe94d0, 0x2fe5a50, 0x2fe96d0 [ORD=7]

    0x2fe5b50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe96d0: <multiple use>
    0x2fe5b50: <multiple use>
  0x2fe6350: ch,glue = CopyToReg 0x2fe5b50, 0x2fe6050, 0x2fe96d0, 0x2fe5b50:1 [ORD=7]

    0x2fe6350: <multiple use>
    0x2fe6450: <multiple use>
      0x2fe8ed0: <multiple use>
      0x2fe9bd0: <multiple use>
      0x2fe8dd0: <multiple use>
      0x3003e20: <multiple use>
      0x3003f20: <multiple use>
    0x2fe5e50: i64 = LEA64r 0x2fe8ed0, 0x2fe9bd0, 0x2fe8dd0, 0x3003e20, 0x3003f20 [ORD=4]

    0x2fe6350: <multiple use>
  0x2fe92d0: ch,glue = CopyToReg 0x2fe6350, 0x2fe6450, 0x2fe5e50, 0x2fe6350:1 [ORD=7]

    0x2fe92d0: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe96d0: <multiple use>
    0x2fe92d0: <multiple use>
  0x2fe5f50: ch,glue = CopyToReg 0x2fe92d0, 0x2fe5850, 0x2fe96d0, 0x2fe92d0:1 [ORD=7]

    0x2fe98d0: <multiple use>
    0x2fe5a50: <multiple use>
    0x2fe98d0: <multiple use>
  0x2fe5750: i64,ch,glue = CopyFromReg 0x2fe98d0, 0x2fe5a50, 0x2fe98d0:1 [ORD=7]

    0x2fe5750: <multiple use>
    0x2fe5a50: <multiple use>
    0x2fe5750: <multiple use>
  0x2fe99d0: ch,glue = CopyToReg 0x2fe5750:1, 0x2fe5a50, 0x2fe5750

    0x2fe5f50: <multiple use>
    0x2fe6550: i64 = TargetExternalSymbol'syscall' [ORD=7]

    0x2fe90d0: ch = MDNode<0x2f9dfd0> [ORD=7]

    0x2fe97d0: <multiple use>
    0x2fe5950: i32 = TargetConstant<10> [ORD=7]

    0x2fe5a50: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5a50: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe6050: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe6250: <multiple use>
    0x2fe8fd0: i64 = Register %RCX [ORD=7]

    0x2fe6250: <multiple use>
    0x2fe91d0: i64 = Register %R11 [ORD=7]

    0x2fe6250: <multiple use>
    0x2fe5c50: i64 = Register %EFLAGS

    0x2fe5f50: <multiple use>
  0x2fe98d0: ch,glue = inlineasm 0x2fe5f50, 0x2fe6550, 0x2fe90d0, 0x2fe97d0, 0x2fe5950, 0x2fe5a50, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe6050, 0x2fe5d50, 0x2fe6450, 0x2fe5d50, 0x2fe5850, 0x2fe6250, 0x2fe8fd0, 0x2fe6250, 0x2fe91d0, 0x2fe6250, 0x2fe5c50, 0x2fe5f50:1

  0x2fe8dd0: i64 = Register %noreg

  0x2fe8ed0: i64 = TargetFrameIndex<0>

  0x2fe9bd0: i8 = TargetConstant<1>

  0x3003e20: i32 = TargetConstant<0>

  0x3003f20: i32 = Register %noreg

    0x2fe99d0: <multiple use>
    0x2fe99d0: <multiple use>
  0x2fe9ad0: ch = RET 0x2fe99d0, 0x2fe99d0:1


********** List Scheduling BB#0 'entry' **********
SU(0): 0x2fe9ad0: ch = RET 0x2fe99d0, 0x2fe99d0:1 [ID=0]

    0x2fe99d0: ch,glue = CopyToReg 0x2fe5750:1, 0x2fe5a50, 0x2fe5750 [ID=0]

  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1
   val SU(1): Latency=1

SU(1): 0x2fe5750: i64,ch,glue = CopyFromReg 0x2fe98d0, 0x2fe5a50, 0x2fe98d0:1 [ORD=7] [ID=1]

    0x2fe5b50: ch,glue = CopyToReg 0x2fe94d0, 0x2fe5a50, 0x2fe96d0 [ORD=7] [ID=1]

    0x2fe6350: ch,glue = CopyToReg 0x2fe5b50, 0x2fe6050, 0x2fe96d0, 0x2fe5b50:1 [ORD=7] [ID=1]

    0x2fe92d0: ch,glue = CopyToReg 0x2fe6350, 0x2fe6450, 0x2fe5e50, 0x2fe6350:1 [ORD=7] [ID=1]

    0x2fe5f50: ch,glue = CopyToReg 0x2fe92d0, 0x2fe5850, 0x2fe96d0, 0x2fe92d0:1 [ORD=7] [ID=1]

    0x2fe98d0: ch,glue = inlineasm 0x2fe5f50, 0x2fe6550, 0x2fe90d0, 0x2fe97d0, 0x2fe5950, 0x2fe5a50, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe6050, 0x2fe5d50, 0x2fe6450, 0x2fe5d50, 0x2fe5850, 0x2fe6250, 0x2fe8fd0, 0x2fe6250, 0x2fe91d0, 0x2fe6250, 0x2fe5c50, 0x2fe5f50:1 [ID=1]

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(2): Latency=1
   val SU(3): Latency=1
   ch  SU(4): Latency=1
  Successors:
   ch  SU(0): Latency=1
   val SU(0): Latency=1

SU(2): 0x2fe96d0: i64 = MOV64ri64i32 0x2fe97d0 [ORD=7] [ID=2]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
   val SU(1): Latency=1

SU(3): 0x2fe5e50: i64 = LEA64r 0x2fe8ed0, 0x2fe9bd0, 0x2fe8dd0, 0x3003e20, 0x3003f20 [ORD=4] [ID=3]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
   val SU(1): Latency=1

SU(4): 0x2fe94d0: ch = MOV64mr 0x2fe8ed0, 0x2fe9bd0, 0x2fe8dd0, 0x3003e20, 0x3003f20, 0x2fe6150, 0x2fbf468<Mem:ST8[%arrayidx1](tbaa=!"long long")> [ORD=5] [ID=4]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(5): Latency=1
  Successors:
   ch  SU(1): Latency=1

SU(5): 0x2fe6150: i64,ch = CopyFromReg 0x2fbf468, 0x2fe93d0 [ORD=5] [ID=5]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
   val SU(4): Latency=1


Examining Available:
Height 0: SU(0): 0x2fe9ad0: ch = RET 0x2fe99d0, 0x2fe99d0:1 [ID=0]

    0x2fe99d0: ch,glue = CopyToReg 0x2fe5750:1, 0x2fe5a50, 0x2fe5750 [ID=0]


*** Scheduling [0]: SU(0): 0x2fe9ad0: ch = RET 0x2fe99d0, 0x2fe99d0:1 [ID=0]

    0x2fe99d0: ch,glue = CopyToReg 0x2fe5750:1, 0x2fe5a50, 0x2fe5750 [ID=0]

GR64: 1 / 12

Examining Available:
Height 1: SU(1): 0x2fe5750: i64,ch,glue = CopyFromReg 0x2fe98d0, 0x2fe5a50, 0x2fe98d0:1 [ORD=7] [ID=1]

    0x2fe5b50: ch,glue = CopyToReg 0x2fe94d0, 0x2fe5a50, 0x2fe96d0 [ORD=7] [ID=1]

    0x2fe6350: ch,glue = CopyToReg 0x2fe5b50, 0x2fe6050, 0x2fe96d0, 0x2fe5b50:1 [ORD=7] [ID=1]

    0x2fe92d0: ch,glue = CopyToReg 0x2fe6350, 0x2fe6450, 0x2fe5e50, 0x2fe6350:1 [ORD=7] [ID=1]

    0x2fe5f50: ch,glue = CopyToReg 0x2fe92d0, 0x2fe5850, 0x2fe96d0, 0x2fe92d0:1 [ORD=7] [ID=1]

    0x2fe98d0: ch,glue = inlineasm 0x2fe5f50, 0x2fe6550, 0x2fe90d0, 0x2fe97d0, 0x2fe5950, 0x2fe5a50, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe6050, 0x2fe5d50, 0x2fe6450, 0x2fe5d50, 0x2fe5850, 0x2fe6250, 0x2fe8fd0, 0x2fe6250, 0x2fe91d0, 0x2fe6250, 0x2fe5c50, 0x2fe5f50:1 [ID=1]


*** Scheduling [1]: SU(1): 0x2fe5750: i64,ch,glue = CopyFromReg 0x2fe98d0, 0x2fe5a50, 0x2fe98d0:1 [ORD=7] [ID=1]

    0x2fe5b50: ch,glue = CopyToReg 0x2fe94d0, 0x2fe5a50, 0x2fe96d0 [ORD=7] [ID=1]

    0x2fe6350: ch,glue = CopyToReg 0x2fe5b50, 0x2fe6050, 0x2fe96d0, 0x2fe5b50:1 [ORD=7] [ID=1]

    0x2fe92d0: ch,glue = CopyToReg 0x2fe6350, 0x2fe6450, 0x2fe5e50, 0x2fe6350:1 [ORD=7] [ID=1]

    0x2fe5f50: ch,glue = CopyToReg 0x2fe92d0, 0x2fe5850, 0x2fe96d0, 0x2fe92d0:1 [ORD=7] [ID=1]

    0x2fe98d0: ch,glue = inlineasm 0x2fe5f50, 0x2fe6550, 0x2fe90d0, 0x2fe97d0, 0x2fe5950, 0x2fe5a50, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe6050, 0x2fe5d50, 0x2fe6450, 0x2fe5d50, 0x2fe5850, 0x2fe6250, 0x2fe8fd0, 0x2fe6250, 0x2fe91d0, 0x2fe6250, 0x2fe5c50, 0x2fe5f50:1 [ID=1]

GR64: 2 / 12

Examining Available:
Height 2: SU(2): 0x2fe96d0: i64 = MOV64ri64i32 0x2fe97d0 [ORD=7] [ID=2]

Height 2: SU(3): 0x2fe5e50: i64 = LEA64r 0x2fe8ed0, 0x2fe9bd0, 0x2fe8dd0, 0x3003e20, 0x3003f20 [ORD=4] [ID=3]

Height 2: SU(4): 0x2fe94d0: ch = MOV64mr 0x2fe8ed0, 0x2fe9bd0, 0x2fe8dd0, 0x3003e20, 0x3003f20, 0x2fe6150, 0x2fbf468<Mem:ST8[%arrayidx1](tbaa=!"long long")> [ORD=5] [ID=4]


*** Scheduling [2]: SU(2): 0x2fe96d0: i64 = MOV64ri64i32 0x2fe97d0 [ORD=7] [ID=2]

GR64: 1 / 12

Examining Available:
Height 2: SU(3): 0x2fe5e50: i64 = LEA64r 0x2fe8ed0, 0x2fe9bd0, 0x2fe8dd0, 0x3003e20, 0x3003f20 [ORD=4] [ID=3]

Height 2: SU(4): 0x2fe94d0: ch = MOV64mr 0x2fe8ed0, 0x2fe9bd0, 0x2fe8dd0, 0x3003e20, 0x3003f20, 0x2fe6150, 0x2fbf468<Mem:ST8[%arrayidx1](tbaa=!"long long")> [ORD=5] [ID=4]


*** Scheduling [3]: SU(3): 0x2fe5e50: i64 = LEA64r 0x2fe8ed0, 0x2fe9bd0, 0x2fe8dd0, 0x3003e20, 0x3003f20 [ORD=4] [ID=3]


Examining Available:
Height 2: SU(4): 0x2fe94d0: ch = MOV64mr 0x2fe8ed0, 0x2fe9bd0, 0x2fe8dd0, 0x3003e20, 0x3003f20, 0x2fe6150, 0x2fbf468<Mem:ST8[%arrayidx1](tbaa=!"long long")> [ORD=5] [ID=4]


*** Scheduling [4]: SU(4): 0x2fe94d0: ch = MOV64mr 0x2fe8ed0, 0x2fe9bd0, 0x2fe8dd0, 0x3003e20, 0x3003f20, 0x2fe6150, 0x2fbf468<Mem:ST8[%arrayidx1](tbaa=!"long long")> [ORD=5] [ID=4]

GR64: 1 / 12

Examining Available:
Height 5: SU(5): 0x2fe6150: i64,ch = CopyFromReg 0x2fbf468, 0x2fe93d0 [ORD=5] [ID=5]


*** Scheduling [5]: SU(5): 0x2fe6150: i64,ch = CopyFromReg 0x2fbf468, 0x2fe93d0 [ORD=5] [ID=5]

*** Final schedule ***
SU(5): 0x2fe6150: i64,ch = CopyFromReg 0x2fbf468, 0x2fe93d0 [ORD=5] [ID=5]

SU(4): 0x2fe94d0: ch = MOV64mr 0x2fe8ed0, 0x2fe9bd0, 0x2fe8dd0, 0x3003e20, 0x3003f20, 0x2fe6150, 0x2fbf468<Mem:ST8[%arrayidx1](tbaa=!"long long")> [ORD=5] [ID=4]

SU(3): 0x2fe5e50: i64 = LEA64r 0x2fe8ed0, 0x2fe9bd0, 0x2fe8dd0, 0x3003e20, 0x3003f20 [ORD=4] [ID=3]

SU(2): 0x2fe96d0: i64 = MOV64ri64i32 0x2fe97d0 [ORD=7] [ID=2]

SU(1): 0x2fe5750: i64,ch,glue = CopyFromReg 0x2fe98d0, 0x2fe5a50, 0x2fe98d0:1 [ORD=7] [ID=1]

    0x2fe5b50: ch,glue = CopyToReg 0x2fe94d0, 0x2fe5a50, 0x2fe96d0 [ORD=7] [ID=1]

    0x2fe6350: ch,glue = CopyToReg 0x2fe5b50, 0x2fe6050, 0x2fe96d0, 0x2fe5b50:1 [ORD=7] [ID=1]

    0x2fe92d0: ch,glue = CopyToReg 0x2fe6350, 0x2fe6450, 0x2fe5e50, 0x2fe6350:1 [ORD=7] [ID=1]

    0x2fe5f50: ch,glue = CopyToReg 0x2fe92d0, 0x2fe5850, 0x2fe96d0, 0x2fe92d0:1 [ORD=7] [ID=1]

    0x2fe98d0: ch,glue = inlineasm 0x2fe5f50, 0x2fe6550, 0x2fe90d0, 0x2fe97d0, 0x2fe5950, 0x2fe5a50, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe6050, 0x2fe5d50, 0x2fe6450, 0x2fe5d50, 0x2fe5850, 0x2fe6250, 0x2fe8fd0, 0x2fe6250, 0x2fe91d0, 0x2fe6250, 0x2fe5c50, 0x2fe5f50:1 [ID=1]

SU(0): 0x2fe9ad0: ch = RET 0x2fe99d0, 0x2fe99d0:1 [ID=0]

    0x2fe99d0: ch,glue = CopyToReg 0x2fe5750:1, 0x2fe5a50, 0x2fe5750 [ID=0]


TADA
Total amount of phi nodes to update: 0
# Machine code for function putchar: SSA
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: %RDI in %vreg0
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg0<def> = COPY %RDI; GR64:%vreg0
32B		MOV64mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST8[%arrayidx1](tbaa=!"long long") GR64:%vreg0
48B		%vreg1<def> = LEA64r <fi#0>, 1, %noreg, 0, %noreg; GR64:%vreg1
64B		%vreg2<def> = MOV64ri64i32 1; GR64:%vreg2
80B		%RAX<def> = COPY %vreg2; GR64:%vreg2
96B		%RDI<def> = COPY %vreg2; GR64:%vreg2
112B		%RSI<def> = COPY %vreg1; GR64:%vreg1
128B		%RDX<def> = COPY %vreg2; GR64:%vreg2
144B		INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def>, $1:[reguse], %RAX, $2:[reguse], %RDI, $3:[reguse], %RSI, $4:[reguse], %RDX, $5:[clobber], %RCX<earlyclobber,imp-def>, $6:[clobber], %R11<earlyclobber,imp-def>, $7:[clobber], %EFLAGS<earlyclobber,imp-def>, <<badref>>
160B		%vreg3<def> = COPY %RAX; GR64:%vreg3
176B		%RAX<def> = COPY %vreg3; GR64:%vreg3
192B		RET

# End machine code for function putchar.

********** Stack Coloring **********
********** Function: putchar
Found 0 markers and 1 slots
Slot structure:
Slot #0 - 8 bytes.
Total Stack size: 8 bytes

Will not try to merge slots.
Removed 0 markers.
******** Pre-regalloc Machine LICM: putchar ********
Entering: entry
Exiting: entry
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: putchar
********** PROCESS IMPLICIT DEFS **********
********** Function: putchar
********** REWRITING TWO-ADDR INSTRS **********
********** Function: putchar
# Machine code for function putchar: Post SSA
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: %RDI in %vreg0
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg0<def> = COPY %RDI<kill>; GR64:%vreg0
32B		MOV64mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0<kill>; mem:ST8[%arrayidx1](tbaa=!"long long") GR64:%vreg0
48B		%vreg1<def> = LEA64r <fi#0>, 1, %noreg, 0, %noreg; GR64:%vreg1
64B		%vreg2<def> = MOV64ri64i32 1; GR64:%vreg2
80B		%RAX<def> = COPY %vreg2; GR64:%vreg2
96B		%RDI<def> = COPY %vreg2; GR64:%vreg2
112B		%RSI<def> = COPY %vreg1<kill>; GR64:%vreg1
128B		%RDX<def> = COPY %vreg2<kill>; GR64:%vreg2
144B		INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI<kill>, $3:[reguse], %RSI<kill>, $4:[reguse], %RDX<kill>, $5:[clobber], %RCX<earlyclobber,imp-def,dead>, $6:[clobber], %R11<earlyclobber,imp-def,dead>, $7:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
160B		%vreg3<def> = COPY %RAX<kill>; GR64:%vreg3
176B		%RAX<def> = COPY %vreg3<kill>; GR64:%vreg3
192B		RET %RAX<imp-use,kill>

# End machine code for function putchar.

********** COMPUTING LIVE INTERVALS **********
********** Function: putchar
BB#0:		# derived from entry
16B	%vreg0<def> = COPY %RDI<kill>; GR64:%vreg0
		register: %vreg0 +[16r,32r:0)
32B	MOV64mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0<kill>; mem:ST8[%arrayidx1](tbaa=!"long long") GR64:%vreg0
48B	%vreg1<def> = LEA64r <fi#0>, 1, %noreg, 0, %noreg; GR64:%vreg1
		register: %vreg1 +[48r,112r:0)
64B	%vreg2<def> = MOV64ri64i32 1; GR64:%vreg2
		register: %vreg2 +[64r,128r:0)
80B	%RAX<def> = COPY %vreg2; GR64:%vreg2
96B	%RDI<def> = COPY %vreg2; GR64:%vreg2
112B	%RSI<def> = COPY %vreg1<kill>; GR64:%vreg1
128B	%RDX<def> = COPY %vreg2<kill>; GR64:%vreg2
144B	INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI<kill>, $3:[reguse], %RSI<kill>, $4:[reguse], %RDX<kill>, $5:[clobber], %RCX<earlyclobber,imp-def,dead>, $6:[clobber], %R11<earlyclobber,imp-def,dead>, $7:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
160B	%vreg3<def> = COPY %RAX<kill>; GR64:%vreg3
		register: %vreg3 +[160r,176r:0)
176B	%RAX<def> = COPY %vreg3<kill>; GR64:%vreg3
192B	RET %RAX<imp-use,kill>
Computing live-in reg-units in ABI blocks.
0B	BB#0 DIL#0
Created 1 new intervals.
********** INTERVALS **********
DIL = [0B,16r:0)[96r,144r:1)  0@0B-phi 1@96r
%vreg0 = [16r,32r:0)  0@16r
%vreg1 = [48r,112r:0)  0@48r
%vreg2 = [64r,128r:0)  0@64r
%vreg3 = [160r,176r:0)  0@160r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function putchar: Post SSA
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: %RDI in %vreg0
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg0<def> = COPY %RDI; GR64:%vreg0
32B		MOV64mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0<kill>; mem:ST8[%arrayidx1](tbaa=!"long long") GR64:%vreg0
48B		%vreg1<def> = LEA64r <fi#0>, 1, %noreg, 0, %noreg; GR64:%vreg1
64B		%vreg2<def> = MOV64ri64i32 1; GR64:%vreg2
80B		%RAX<def> = COPY %vreg2; GR64:%vreg2
96B		%RDI<def> = COPY %vreg2; GR64:%vreg2
112B		%RSI<def> = COPY %vreg1<kill>; GR64:%vreg1
128B		%RDX<def> = COPY %vreg2<kill>; GR64:%vreg2
144B		INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI, $3:[reguse], %RSI<kill>, $4:[reguse], %RDX<kill>, $5:[clobber], %RCX<earlyclobber,imp-def,dead>, $6:[clobber], %R11<earlyclobber,imp-def,dead>, $7:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
160B		%vreg3<def> = COPY %RAX<kill>; GR64:%vreg3
176B		%RAX<def> = COPY %vreg3<kill>; GR64:%vreg3
192B		RET %RAX<imp-use,kill>

# End machine code for function putchar.

********** COMPUTING LIVE DEBUG VARIABLES: putchar **********
********** DEBUG VARIABLES **********
********** SIMPLE REGISTER COALESCING **********
********** Function: putchar
********** JOINING INTERVALS ***********
entry:
16B	%vreg0<def> = COPY %RDI; GR64:%vreg0
	Considering merging %vreg0 with %RDI
	Can only merge into reserved registers.
80B	%RAX<def> = COPY %vreg2; GR64:%vreg2
	Considering merging %vreg2 with %RAX
	Can only merge into reserved registers.
Remat: %RAX<def> = MOV64ri64i32 1
Shrink: [64r,128r:0)  0@64r
Shrunk: [64r,128r:0)  0@64r
96B	%RDI<def> = COPY %vreg2; GR64:%vreg2
	Considering merging %vreg2 with %RDI
	Can only merge into reserved registers.
Remat: %RDI<def> = MOV64ri64i32 1
Shrink: [64r,128r:0)  0@64r
Shrunk: [64r,128r:0)  0@64r
112B	%RSI<def> = COPY %vreg1<kill>; GR64:%vreg1
	Considering merging %vreg1 with %RSI
	Can only merge into reserved registers.
128B	%RDX<def> = COPY %vreg2<kill>; GR64:%vreg2
	Considering merging %vreg2 with %RDX
	Can only merge into reserved registers.
Remat: %RDX<def> = MOV64ri64i32 1
Shrink: [64r,128r:0)  0@64r
All defs dead: 64r	%vreg2<def,dead> = MOV64ri64i32 1; GR64:%vreg2
Shrunk: [64r,64d:0)  0@64r
Deleting dead def 64r	%vreg2<def,dead> = MOV64ri64i32 1; GR64:%vreg2
160B	%vreg3<def> = COPY %RAX<kill>; GR64:%vreg3
	Considering merging %vreg3 with %RAX
	Can only merge into reserved registers.
176B	%RAX<def> = COPY %vreg3<kill>; GR64:%vreg3
	Considering merging %vreg3 with %RAX
	Can only merge into reserved registers.
Trying to inflate 0 regs.
********** INTERVALS **********
DIL = [0B,16r:0)[96r,144r:1)  0@0B-phi 1@96r
%vreg0 = [16r,32r:0)  0@16r
%vreg1 = [48r,112r:0)  0@48r
%vreg3 = [160r,176r:0)  0@160r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function putchar: Post SSA
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: %RDI in %vreg0
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg0<def> = COPY %RDI; GR64:%vreg0
32B		MOV64mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0<kill>; mem:ST8[%arrayidx1](tbaa=!"long long") GR64:%vreg0
48B		%vreg1<def> = LEA64r <fi#0>, 1, %noreg, 0, %noreg; GR64:%vreg1
80B		%RAX<def> = MOV64ri64i32 1
96B		%RDI<def> = MOV64ri64i32 1
112B		%RSI<def> = COPY %vreg1<kill>; GR64:%vreg1
128B		%RDX<def> = MOV64ri64i32 1
144B		INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI, $3:[reguse], %RSI<kill>, $4:[reguse], %RDX<kill>, $5:[clobber], %RCX<earlyclobber,imp-def,dead>, $6:[clobber], %R11<earlyclobber,imp-def,dead>, $7:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
160B		%vreg3<def> = COPY %RAX<kill>; GR64:%vreg3
176B		%RAX<def> = COPY %vreg3<kill>; GR64:%vreg3
192B		RET %RAX<imp-use,kill>

# End machine code for function putchar.

********** DEBUG VARIABLES **********
********** Compute Spill Weights **********
********** Function: putchar
********** GREEDY REGISTER ALLOCATION **********
********** Function: putchar

selectOrSplit GR64:%vreg1 [48r,112r:0)  0@48r
hints: %RSI
assigning %vreg1 to %RSI: SIL

selectOrSplit GR64:%vreg0 [16r,32r:0)  0@16r
hints: %RDI
assigning %vreg0 to %RDI: DIL

selectOrSplit GR64:%vreg3 [160r,176r:0)  0@160r
hints: %RAX
assigning %vreg3 to %RAX: AH AL
********** REWRITE VIRTUAL REGISTERS **********
********** Function: putchar
********** REGISTER MAP **********
[%vreg0 -> %RDI] GR64
[%vreg1 -> %RSI] GR64
[%vreg3 -> %RAX] GR64

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg0<def> = COPY %RDI; GR64:%vreg0
32B		MOV64mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0<kill>; mem:ST8[%arrayidx1](tbaa=!"long long") GR64:%vreg0
48B		%vreg1<def> = LEA64r <fi#0>, 1, %noreg, 0, %noreg; GR64:%vreg1
80B		%RAX<def> = MOV64ri64i32 1
96B		%RDI<def> = MOV64ri64i32 1
112B		%RSI<def> = COPY %vreg1<kill>; GR64:%vreg1
128B		%RDX<def> = MOV64ri64i32 1
144B		INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def>, $1:[reguse], %RAX, $2:[reguse], %RDI, $3:[reguse], %RSI, $4:[reguse], %RDX<kill>, $5:[clobber], %RCX<earlyclobber,imp-def,dead>, $6:[clobber], %R11<earlyclobber,imp-def,dead>, $7:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
160B		%vreg3<def> = COPY %RAX; GR64:%vreg3
176B		%RAX<def> = COPY %vreg3<kill>; GR64:%vreg3
192B		RET %RAX<imp-use>
> %RDI<def> = COPY %RDI
Deleting identity copy.
> MOV64mr <fi#0>, 1, %noreg, 0, %noreg, %RDI<kill>; mem:ST8[%arrayidx1](tbaa=!"long long")
> %RSI<def> = LEA64r <fi#0>, 1, %noreg, 0, %noreg
> %RAX<def> = MOV64ri64i32 1
> %RDI<def> = MOV64ri64i32 1
> %RSI<def> = COPY %RSI<kill>
Deleting identity copy.
> %RDX<def> = MOV64ri64i32 1
> INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def>, $1:[reguse], %RAX, $2:[reguse], %RDI, $3:[reguse], %RSI, $4:[reguse], %RDX<kill>, $5:[clobber], %RCX<earlyclobber,imp-def,dead>, $6:[clobber], %R11<earlyclobber,imp-def,dead>, $7:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
> %RAX<def> = COPY %RAX
Deleting identity copy.
> %RAX<def> = COPY %RAX<kill>
Deleting identity copy.
> RET %RAX<imp-use>
********** EMITTING LIVE DEBUG VARIABLES **********
********** Stack Slot Coloring **********
********** Function: putchar
******** Post-regalloc Machine LICM: putchar ********
alloc FI(0) at SP[-16]
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: putchar
RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0
Frequency(BB#0 derived from LLVM BB entry) = 1024
********** FIX EXECUTION DEPENDENCIES: VR128 **********
The instruction being printed 1499 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 1113 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 1504 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 1504 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 1504 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 2234 1501 1647 1642 1506 1648 1643 1645 1640CGP: Found      local addrmode: [GV:@current_brk]
CGP: Found      local addrmode: [GV:@current_brk]
CGP: Found      local addrmode: [GV:@current_brk]
Computing probabilities for entry



=== malloc
5
is64bit 1
5 4 {ax}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
5 0x2105940
5 4 {ax}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
5 0x2105940
5 4 {di}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
5 0x2105940
0 5 {rcx}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x2105940
0 5 {r11}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x2105940
0 8 {memory}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x0
0 9 {dirflag}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x0
0 6 {fpsr}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x0
0 7 {flags}
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
No legal RC found.
0 0x0
I've changed this to i64 from i16! Might break returns!Initial selection DAG: BB#0 'malloc:entry'
SelectionDAG has 35 nodes:
  0x2fbf468: ch = EntryToken [ORD=8]

        0x2fbf468: <multiple use>
        0x3003f20: i64 = Register %vreg0 [ORD=8]

      0x3003e20: i64,ch = CopyFromReg 0x2fbf468, 0x3003f20 [ORD=8]

      0x2fe9bd0: i64 = Constant<7> [ORD=8]

    0x2fe8ed0: i64 = add 0x3003e20, 0x2fe9bd0 [ORD=8]

    0x2fe8dd0: i64 = Constant<-8> [ORD=9]

  0x2fe98d0: i64 = and 0x2fe8ed0, 0x2fe8dd0 [ORD=9]

  0x2fe9ad0: i64 = GlobalAddress<i8** @current_brk> 0 [ORD=10]

  0x2fe5750: i64 = undef [ORD=10]

    0x2fbf468: <multiple use>
    0x2fe9ad0: <multiple use>
    0x2fe5750: <multiple use>
  0x2fe5f50: i64,ch = load 0x2fbf468, 0x2fe9ad0, 0x2fe5750<LD8[@current_brk](tbaa=!"any pointer")> [ORD=10]

    0x2fe5f50: <multiple use>
    0x2fe98d0: <multiple use>
  0x2fe92d0: i64 = add 0x2fe5f50, 0x2fe98d0 [ORD=11]

  0x2fe8fd0: i64 = Register %RAX [ORD=14]

      0x2fe5f50: <multiple use>
      0x2fe92d0: <multiple use>
      0x2fe9ad0: <multiple use>
      0x2fe5750: <multiple use>
    0x2fe6350: ch = store 0x2fe5f50:1, 0x2fe92d0, 0x2fe9ad0, 0x2fe5750<ST8[@current_brk](tbaa=!"any pointer")> [ORD=12]

    0x2fe8fd0: <multiple use>
    0x2fe5b50: i64 = Constant<12> [ORD=14]

  0x2fe6250: ch,glue = CopyToReg 0x2fe6350, 0x2fe8fd0, 0x2fe5b50 [ORD=14]

  0x2fe5850: i32 = TargetConstant<9> [ORD=14]

  0x2fe6450: i64 = Register %RDI [ORD=14]

    0x2fe6250: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe6250: <multiple use>
  0x2fe6050: ch,glue = CopyToReg 0x2fe6250, 0x2fe6450, 0x2fe92d0, 0x2fe6250:1 [ORD=14]

  0x2fe5d50: i32 = TargetConstant<12> [ORD=14]

    0x2fe6050: <multiple use>
    0x2fe94d0: i64 = TargetExternalSymbol'syscall' [ORD=14]

    0x2fe6150: ch = MDNode<0x2f9f510> [ORD=14]

    0x2fe5c50: i64 = TargetConstant<1> [ORD=14]

    0x2fe91d0: i32 = TargetConstant<10> [ORD=14]

    0x2fe8fd0: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe8fd0: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5a50: i64 = Register %RCX [ORD=14]

    0x2fe5d50: <multiple use>
    0x2fe5950: i64 = Register %R11 [ORD=14]

    0x2fe5d50: <multiple use>
    0x2fe97d0: i32 = Register %EFLAGS [ORD=14]

    0x2fe6050: <multiple use>
  0x2fe90d0: ch,glue = inlineasm 0x2fe6050, 0x2fe94d0, 0x2fe6150, 0x2fe5c50, 0x2fe91d0, 0x2fe8fd0, 0x2fe5850, 0x2fe8fd0, 0x2fe5850, 0x2fe6450, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe5950, 0x2fe5d50, 0x2fe97d0, 0x2fe6050:1 [ORD=14]

    0x2fe90d0: <multiple use>
    0x2fe8fd0: <multiple use>
    0x2fe90d0: <multiple use>
  0x2fe6550: i64,ch,glue = CopyFromReg 0x2fe90d0, 0x2fe8fd0, 0x2fe90d0:1 [ORD=14]

    0x2fe6550: <multiple use>
    0x2fe8fd0: <multiple use>
        0x2fe6550: <multiple use>
        0x2fe9ad0: <multiple use>
        0x2fe5750: <multiple use>
      0x2fe96d0: i64,ch = load 0x2fe6550:1, 0x2fe9ad0, 0x2fe5750<LD8[@current_brk](tbaa=!"any pointer")> [ORD=15]

        0x2fe99d0: i64 = Constant<0> [ORD=16]

        0x2fe98d0: <multiple use>
      0x2fe5e50: i64 = sub 0x2fe99d0, 0x2fe98d0 [ORD=16]

    0x2fe93d0: i64 = add 0x2fe96d0, 0x2fe5e50 [ORD=17]

  0x3004020: ch,glue = CopyToReg 0x2fe6550:1, 0x2fe8fd0, 0x2fe93d0

    0x3004020: <multiple use>
    0x2fe95d0: i64 = TargetConstant<0>

    0x3004020: <multiple use>
  0x3004120: ch = X86ISD::RET_FLAG 0x3004020, 0x2fe95d0, 0x3004020:1



Replacing.3 0x2fe93d0: i64 = add 0x2fe96d0, 0x2fe5e50 [ORD=17]

With: 0x3004220: i64 = sub 0x2fe96d0, 0x2fe98d0

Optimized lowered selection DAG: BB#0 'malloc:entry'
SelectionDAG has 33 nodes:
  0x2fbf468: ch = EntryToken [ORD=8]

        0x2fbf468: <multiple use>
        0x3003f20: i64 = Register %vreg0 [ORD=8]

      0x3003e20: i64,ch = CopyFromReg 0x2fbf468, 0x3003f20 [ORD=8]

      0x2fe9bd0: i64 = Constant<7> [ORD=8]

    0x2fe8ed0: i64 = add 0x3003e20, 0x2fe9bd0 [ORD=8]

    0x2fe8dd0: i64 = Constant<-8> [ORD=9]

  0x2fe98d0: i64 = and 0x2fe8ed0, 0x2fe8dd0 [ORD=9]

  0x2fe9ad0: i64 = GlobalAddress<i8** @current_brk> 0 [ORD=10]

  0x2fe5750: i64 = undef [ORD=10]

    0x2fbf468: <multiple use>
    0x2fe9ad0: <multiple use>
    0x2fe5750: <multiple use>
  0x2fe5f50: i64,ch = load 0x2fbf468, 0x2fe9ad0, 0x2fe5750<LD8[@current_brk](tbaa=!"any pointer")> [ORD=10]

    0x2fe5f50: <multiple use>
    0x2fe98d0: <multiple use>
  0x2fe92d0: i64 = add 0x2fe5f50, 0x2fe98d0 [ORD=11]

  0x2fe8fd0: i64 = Register %RAX [ORD=14]

      0x2fe5f50: <multiple use>
      0x2fe92d0: <multiple use>
      0x2fe9ad0: <multiple use>
      0x2fe5750: <multiple use>
    0x2fe6350: ch = store 0x2fe5f50:1, 0x2fe92d0, 0x2fe9ad0, 0x2fe5750<ST8[@current_brk](tbaa=!"any pointer")> [ORD=12]

    0x2fe8fd0: <multiple use>
    0x2fe5b50: i64 = Constant<12> [ORD=14]

  0x2fe6250: ch,glue = CopyToReg 0x2fe6350, 0x2fe8fd0, 0x2fe5b50 [ORD=14]

  0x2fe5850: i32 = TargetConstant<9> [ORD=14]

  0x2fe6450: i64 = Register %RDI [ORD=14]

    0x2fe6250: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe6250: <multiple use>
  0x2fe6050: ch,glue = CopyToReg 0x2fe6250, 0x2fe6450, 0x2fe92d0, 0x2fe6250:1 [ORD=14]

  0x2fe5d50: i32 = TargetConstant<12> [ORD=14]

    0x2fe6050: <multiple use>
    0x2fe94d0: i64 = TargetExternalSymbol'syscall' [ORD=14]

    0x2fe6150: ch = MDNode<0x2f9f510> [ORD=14]

    0x2fe5c50: i64 = TargetConstant<1> [ORD=14]

    0x2fe91d0: i32 = TargetConstant<10> [ORD=14]

    0x2fe8fd0: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe8fd0: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5a50: i64 = Register %RCX [ORD=14]

    0x2fe5d50: <multiple use>
    0x2fe5950: i64 = Register %R11 [ORD=14]

    0x2fe5d50: <multiple use>
    0x2fe97d0: i32 = Register %EFLAGS [ORD=14]

    0x2fe6050: <multiple use>
  0x2fe90d0: ch,glue = inlineasm 0x2fe6050, 0x2fe94d0, 0x2fe6150, 0x2fe5c50, 0x2fe91d0, 0x2fe8fd0, 0x2fe5850, 0x2fe8fd0, 0x2fe5850, 0x2fe6450, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe5950, 0x2fe5d50, 0x2fe97d0, 0x2fe6050:1 [ORD=14]

    0x2fe90d0: <multiple use>
    0x2fe8fd0: <multiple use>
    0x2fe90d0: <multiple use>
  0x2fe6550: i64,ch,glue = CopyFromReg 0x2fe90d0, 0x2fe8fd0, 0x2fe90d0:1 [ORD=14]

    0x2fe6550: <multiple use>
    0x2fe8fd0: <multiple use>
        0x2fe6550: <multiple use>
        0x2fe9ad0: <multiple use>
        0x2fe5750: <multiple use>
      0x2fe96d0: i64,ch = load 0x2fe6550:1, 0x2fe9ad0, 0x2fe5750<LD8[@current_brk](tbaa=!"any pointer")> [ORD=15]

      0x2fe98d0: <multiple use>
    0x3004220: i64 = sub 0x2fe96d0, 0x2fe98d0

  0x3004020: ch,glue = CopyToReg 0x2fe6550:1, 0x2fe8fd0, 0x3004220

    0x3004020: <multiple use>
    0x2fe95d0: i64 = TargetConstant<0>

    0x3004020: <multiple use>
  0x3004120: ch = X86ISD::RET_FLAG 0x3004020, 0x2fe95d0, 0x3004020:1


Legally typed node: 0x2fe95d0: i64 = TargetConstant<0> [ID=0]

Promote integer result: 0x2fe97d0: i32 = Register %EFLAGS [ORD=14] [ID=0]

In Custom Lowering 8 4 1
Replacing Node Results. Node has OpCode
85
Legally typed node: 0x2fe99d0: i64 = Register %EFLAGS [ID=0]

Legally typed node: 0x2fe5950: i64 = Register %R11 [ORD=14] [ID=0]

Legally typed node: 0x2fe5a50: i64 = Register %RCX [ORD=14] [ID=0]

Legally typed node: 0x2fe5d50: i32 = TargetConstant<12> [ORD=14] [ID=0]

Legally typed node: 0x2fe6450: i64 = Register %RDI [ORD=14] [ID=0]

Legally typed node: 0x2fe5850: i32 = TargetConstant<9> [ORD=14] [ID=0]

Legally typed node: 0x2fe8fd0: i64 = Register %RAX [ORD=14] [ID=0]

Legally typed node: 0x2fe91d0: i32 = TargetConstant<10> [ORD=14] [ID=0]

Legally typed node: 0x2fe5c50: i64 = TargetConstant<1> [ORD=14] [ID=0]

Legally typed node: 0x2fe6150: ch = MDNode<0x2f9f510> [ORD=14] [ID=0]

Legally typed node: 0x2fe94d0: i64 = TargetExternalSymbol'syscall' [ORD=14] [ID=0]

Legally typed node: 0x2fe5b50: i64 = Constant<12> [ORD=14] [ID=0]

Legally typed node: 0x2fe5750: i64 = undef [ORD=10] [ID=0]

Legally typed node: 0x2fe9ad0: i64 = GlobalAddress<i8** @current_brk> 0 [ORD=10] [ID=0]

Legally typed node: 0x2fe8dd0: i64 = Constant<-8> [ORD=9] [ID=0]

Legally typed node: 0x2fe9bd0: i64 = Constant<7> [ORD=8] [ID=0]

Legally typed node: 0x3003f20: i64 = Register %vreg0 [ORD=8] [ID=0]

Legally typed node: 0x2fbf468: ch = EntryToken [ORD=8] [ID=0]

Legally typed node: 0x3003e20: i64,ch = CopyFromReg 0x2fbf468, 0x3003f20 [ORD=8] [ID=0]

Legally typed node: 0x2fe8ed0: i64 = add 0x3003e20, 0x2fe9bd0 [ORD=8] [ID=0]

Legally typed node: 0x2fe98d0: i64 = and 0x2fe8ed0, 0x2fe8dd0 [ORD=9] [ID=0]

Legally typed node: 0x2fe5f50: i64,ch = load 0x2fbf468, 0x2fe9ad0, 0x2fe5750<LD8[@current_brk](tbaa=!"any pointer")> [ORD=10] [ID=0]

Legally typed node: 0x2fe92d0: i64 = add 0x2fe5f50, 0x2fe98d0 [ORD=11] [ID=0]

Legally typed node: 0x2fe6350: ch = store 0x2fe5f50:1, 0x2fe92d0, 0x2fe9ad0, 0x2fe5750<ST8[@current_brk](tbaa=!"any pointer")> [ORD=12] [ID=0]

Legally typed node: 0x2fe6250: ch,glue = CopyToReg 0x2fe6350, 0x2fe8fd0, 0x2fe5b50 [ORD=14] [ID=0]

Legally typed node: 0x2fe6050: ch,glue = CopyToReg 0x2fe6250, 0x2fe6450, 0x2fe92d0, 0x2fe6250:1 [ORD=14] [ID=0]

Legally typed node: 0x2fe90d0: ch,glue = inlineasm 0x2fe6050, 0x2fe94d0, 0x2fe6150, 0x2fe5c50, 0x2fe91d0, 0x2fe8fd0, 0x2fe5850, 0x2fe8fd0, 0x2fe5850, 0x2fe6450, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe5950, 0x2fe5d50, 0x2fe99d0, 0x2fe6050:1 [ORD=14] [ID=0]

Legally typed node: 0x2fe6550: i64,ch,glue = CopyFromReg 0x2fe90d0, 0x2fe8fd0, 0x2fe90d0:1 [ORD=14] [ID=0]

Legally typed node: 0x2fe96d0: i64,ch = load 0x2fe6550:1, 0x2fe9ad0, 0x2fe5750<LD8[@current_brk](tbaa=!"any pointer")> [ORD=15] [ID=0]

Legally typed node: 0x3004220: i64 = sub 0x2fe96d0, 0x2fe98d0 [ID=0]

Legally typed node: 0x3004020: ch,glue = CopyToReg 0x2fe6550:1, 0x2fe8fd0, 0x3004220 [ID=0]

Legally typed node: 0x3004120: ch = X86ISD::RET_FLAG 0x3004020, 0x2fe95d0, 0x3004020:1 [ID=0]

Legally typed node: 0x7fff8d52a470: ch = handlenode 0x3004120 [ID=0]

Type-legalized selection DAG: BB#0 'malloc:entry'
SelectionDAG has 33 nodes:
  0x2fbf468: ch = EntryToken [ORD=8] [ID=-3]

        0x2fbf468: <multiple use>
        0x3003f20: i64 = Register %vreg0 [ORD=8] [ID=-3]

      0x3003e20: i64,ch = CopyFromReg 0x2fbf468, 0x3003f20 [ORD=8] [ID=-3]

      0x2fe9bd0: i64 = Constant<7> [ORD=8] [ID=-3]

    0x2fe8ed0: i64 = add 0x3003e20, 0x2fe9bd0 [ORD=8] [ID=-3]

    0x2fe8dd0: i64 = Constant<-8> [ORD=9] [ID=-3]

  0x2fe98d0: i64 = and 0x2fe8ed0, 0x2fe8dd0 [ORD=9] [ID=-3]

  0x2fe9ad0: i64 = GlobalAddress<i8** @current_brk> 0 [ORD=10] [ID=-3]

  0x2fe5750: i64 = undef [ORD=10] [ID=-3]

    0x2fbf468: <multiple use>
    0x2fe9ad0: <multiple use>
    0x2fe5750: <multiple use>
  0x2fe5f50: i64,ch = load 0x2fbf468, 0x2fe9ad0, 0x2fe5750<LD8[@current_brk](tbaa=!"any pointer")> [ORD=10] [ID=-3]

    0x2fe5f50: <multiple use>
    0x2fe98d0: <multiple use>
  0x2fe92d0: i64 = add 0x2fe5f50, 0x2fe98d0 [ORD=11] [ID=-3]

  0x2fe8fd0: i64 = Register %RAX [ORD=14] [ID=-3]

      0x2fe5f50: <multiple use>
      0x2fe92d0: <multiple use>
      0x2fe9ad0: <multiple use>
      0x2fe5750: <multiple use>
    0x2fe6350: ch = store 0x2fe5f50:1, 0x2fe92d0, 0x2fe9ad0, 0x2fe5750<ST8[@current_brk](tbaa=!"any pointer")> [ORD=12] [ID=-3]

    0x2fe8fd0: <multiple use>
    0x2fe5b50: i64 = Constant<12> [ORD=14] [ID=-3]

  0x2fe6250: ch,glue = CopyToReg 0x2fe6350, 0x2fe8fd0, 0x2fe5b50 [ORD=14] [ID=-3]

  0x2fe5850: i32 = TargetConstant<9> [ORD=14] [ID=-3]

  0x2fe6450: i64 = Register %RDI [ORD=14] [ID=-3]

    0x2fe6250: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe6250: <multiple use>
  0x2fe6050: ch,glue = CopyToReg 0x2fe6250, 0x2fe6450, 0x2fe92d0, 0x2fe6250:1 [ORD=14] [ID=-3]

  0x2fe5d50: i32 = TargetConstant<12> [ORD=14] [ID=-3]

    0x2fe6050: <multiple use>
    0x2fe94d0: i64 = TargetExternalSymbol'syscall' [ORD=14] [ID=-3]

    0x2fe6150: ch = MDNode<0x2f9f510> [ORD=14] [ID=-3]

    0x2fe5c50: i64 = TargetConstant<1> [ORD=14] [ID=-3]

    0x2fe91d0: i32 = TargetConstant<10> [ORD=14] [ID=-3]

    0x2fe8fd0: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe8fd0: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5a50: i64 = Register %RCX [ORD=14] [ID=-3]

    0x2fe5d50: <multiple use>
    0x2fe5950: i64 = Register %R11 [ORD=14] [ID=-3]

    0x2fe5d50: <multiple use>
    0x2fe99d0: i64 = Register %EFLAGS [ID=-3]

    0x2fe6050: <multiple use>
  0x2fe90d0: ch,glue = inlineasm 0x2fe6050, 0x2fe94d0, 0x2fe6150, 0x2fe5c50, 0x2fe91d0, 0x2fe8fd0, 0x2fe5850, 0x2fe8fd0, 0x2fe5850, 0x2fe6450, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe5950, 0x2fe5d50, 0x2fe99d0, 0x2fe6050:1 [ORD=14] [ID=-3]

    0x2fe90d0: <multiple use>
    0x2fe8fd0: <multiple use>
    0x2fe90d0: <multiple use>
  0x2fe6550: i64,ch,glue = CopyFromReg 0x2fe90d0, 0x2fe8fd0, 0x2fe90d0:1 [ORD=14] [ID=-3]

    0x2fe6550: <multiple use>
    0x2fe8fd0: <multiple use>
        0x2fe6550: <multiple use>
        0x2fe9ad0: <multiple use>
        0x2fe5750: <multiple use>
      0x2fe96d0: i64,ch = load 0x2fe6550:1, 0x2fe9ad0, 0x2fe5750<LD8[@current_brk](tbaa=!"any pointer")> [ORD=15] [ID=-3]

      0x2fe98d0: <multiple use>
    0x3004220: i64 = sub 0x2fe96d0, 0x2fe98d0 [ID=-3]

  0x3004020: ch,glue = CopyToReg 0x2fe6550:1, 0x2fe8fd0, 0x3004220 [ID=-3]

    0x3004020: <multiple use>
    0x2fe95d0: i64 = TargetConstant<0> [ID=-3]

    0x3004020: <multiple use>
  0x3004120: ch = X86ISD::RET_FLAG 0x3004020, 0x2fe95d0, 0x3004020:1 [ID=-3]


Optimized type-legalized selection DAG: BB#0 'malloc:entry'
SelectionDAG has 33 nodes:
  0x2fbf468: ch = EntryToken [ORD=8] [ID=-3]

        0x2fbf468: <multiple use>
        0x3003f20: i64 = Register %vreg0 [ORD=8] [ID=-3]

      0x3003e20: i64,ch = CopyFromReg 0x2fbf468, 0x3003f20 [ORD=8] [ID=-3]

      0x2fe9bd0: i64 = Constant<7> [ORD=8] [ID=-3]

    0x2fe8ed0: i64 = add 0x3003e20, 0x2fe9bd0 [ORD=8] [ID=-3]

    0x2fe8dd0: i64 = Constant<-8> [ORD=9] [ID=-3]

  0x2fe98d0: i64 = and 0x2fe8ed0, 0x2fe8dd0 [ORD=9] [ID=-3]

  0x2fe9ad0: i64 = GlobalAddress<i8** @current_brk> 0 [ORD=10] [ID=-3]

  0x2fe5750: i64 = undef [ORD=10] [ID=-3]

    0x2fbf468: <multiple use>
    0x2fe9ad0: <multiple use>
    0x2fe5750: <multiple use>
  0x2fe5f50: i64,ch = load 0x2fbf468, 0x2fe9ad0, 0x2fe5750<LD8[@current_brk](tbaa=!"any pointer")> [ORD=10] [ID=-3]

    0x2fe5f50: <multiple use>
    0x2fe98d0: <multiple use>
  0x2fe92d0: i64 = add 0x2fe5f50, 0x2fe98d0 [ORD=11] [ID=-3]

  0x2fe8fd0: i64 = Register %RAX [ORD=14] [ID=-3]

      0x2fe5f50: <multiple use>
      0x2fe92d0: <multiple use>
      0x2fe9ad0: <multiple use>
      0x2fe5750: <multiple use>
    0x2fe6350: ch = store 0x2fe5f50:1, 0x2fe92d0, 0x2fe9ad0, 0x2fe5750<ST8[@current_brk](tbaa=!"any pointer")> [ORD=12] [ID=-3]

    0x2fe8fd0: <multiple use>
    0x2fe5b50: i64 = Constant<12> [ORD=14] [ID=-3]

  0x2fe6250: ch,glue = CopyToReg 0x2fe6350, 0x2fe8fd0, 0x2fe5b50 [ORD=14] [ID=-3]

  0x2fe5850: i32 = TargetConstant<9> [ORD=14] [ID=-3]

  0x2fe6450: i64 = Register %RDI [ORD=14] [ID=-3]

    0x2fe6250: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe6250: <multiple use>
  0x2fe6050: ch,glue = CopyToReg 0x2fe6250, 0x2fe6450, 0x2fe92d0, 0x2fe6250:1 [ORD=14] [ID=-3]

  0x2fe5d50: i32 = TargetConstant<12> [ORD=14] [ID=-3]

    0x2fe6050: <multiple use>
    0x2fe94d0: i64 = TargetExternalSymbol'syscall' [ORD=14] [ID=-3]

    0x2fe6150: ch = MDNode<0x2f9f510> [ORD=14] [ID=-3]

    0x2fe5c50: i64 = TargetConstant<1> [ORD=14] [ID=-3]

    0x2fe91d0: i32 = TargetConstant<10> [ORD=14] [ID=-3]

    0x2fe8fd0: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe8fd0: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5a50: i64 = Register %RCX [ORD=14] [ID=-3]

    0x2fe5d50: <multiple use>
    0x2fe5950: i64 = Register %R11 [ORD=14] [ID=-3]

    0x2fe5d50: <multiple use>
    0x2fe99d0: i64 = Register %EFLAGS [ID=-3]

    0x2fe6050: <multiple use>
  0x2fe90d0: ch,glue = inlineasm 0x2fe6050, 0x2fe94d0, 0x2fe6150, 0x2fe5c50, 0x2fe91d0, 0x2fe8fd0, 0x2fe5850, 0x2fe8fd0, 0x2fe5850, 0x2fe6450, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe5950, 0x2fe5d50, 0x2fe99d0, 0x2fe6050:1 [ORD=14] [ID=-3]

    0x2fe90d0: <multiple use>
    0x2fe8fd0: <multiple use>
    0x2fe90d0: <multiple use>
  0x2fe6550: i64,ch,glue = CopyFromReg 0x2fe90d0, 0x2fe8fd0, 0x2fe90d0:1 [ORD=14] [ID=-3]

    0x2fe6550: <multiple use>
    0x2fe8fd0: <multiple use>
        0x2fe6550: <multiple use>
        0x2fe9ad0: <multiple use>
        0x2fe5750: <multiple use>
      0x2fe96d0: i64,ch = load 0x2fe6550:1, 0x2fe9ad0, 0x2fe5750<LD8[@current_brk](tbaa=!"any pointer")> [ORD=15] [ID=-3]

      0x2fe98d0: <multiple use>
    0x3004220: i64 = sub 0x2fe96d0, 0x2fe98d0 [ID=-3]

  0x3004020: ch,glue = CopyToReg 0x2fe6550:1, 0x2fe8fd0, 0x3004220 [ID=-3]

    0x3004020: <multiple use>
    0x2fe95d0: i64 = TargetConstant<0> [ID=-3]

    0x3004020: <multiple use>
  0x3004120: ch = X86ISD::RET_FLAG 0x3004020, 0x2fe95d0, 0x3004020:1 [ID=-3]


In LegalizeDAG() 211
In legalize Op211
0
0
5
50
In LegalizeDAG() 42
In legalize Op42
0
50
0
5
5
In LegalizeDAG() 49
In legalize Op49
5
5
5
In LegalizeDAG() 143
In legalize Op143
5
0
0
5
5
In LegalizeDAG() 43
In legalize Op43
5
0
50
0
5
50
In LegalizeDAG() 151
In legalize Op151
0
50
0
5
0
5
4
5
4
5
4
5
4
5
4
5
4
5
50
In LegalizeDAG() 42
In legalize Op42
0
50
0
5
5
50
In LegalizeDAG() 42
In legalize Op42
0
50
0
5
5
In LegalizeDAG() 144
In legalize Op144
0
0
5
5
5
In LegalizeDAG() 48
In legalize Op48
5
5
5
In LegalizeDAG() 88
In legalize Op88
5
5
5
In LegalizeDAG() 48
In legalize Op48
5
5
5
In LegalizeDAG() 143
In legalize Op143
5
0
0
5
5
In LegalizeDAG() 43
In legalize Op43
5
0
0
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 29
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 29
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 29
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 29
In LegalizeDAG() 29
In LegalizeDAG() 162
In legalize Op162
0
In LegalizeDAG() 36
In legalize Op36
5
In LegalizeDAG() 10
In legalize Op10
5
In LegalizeDAG() 44
In legalize Op44
5
In LegalizeDAG() 12
In legalize Op12
5
In LegalizeDAG() 10
In legalize Op10
5
In LegalizeDAG() 10
In legalize Op10
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 1
In legalize Op1
0
In LegalizeDAG() 215
In legalize Op215
5
5
In LegalizeDAG() 31
In legalize Op31
5
Legalized selection DAG: BB#0 'malloc:entry'
SelectionDAG has 34 nodes:
  0x2fbf468: ch = EntryToken [ORD=8] [ID=0]

  0x2fe5750: i64 = undef [ORD=10] [ID=5]

  0x2fe8fd0: i64 = Register %RAX [ORD=14] [ID=11]

  0x2fe5850: i32 = TargetConstant<9> [ORD=14] [ID=12]

  0x2fe6450: i64 = Register %RDI [ORD=14] [ID=13]

  0x2fe5d50: i32 = TargetConstant<12> [ORD=14] [ID=14]

    0x2fbf468: <multiple use>
    0x2fe5e50: <multiple use>
    0x2fe5750: <multiple use>
  0x2fe5f50: i64,ch = load 0x2fbf468, 0x2fe5e50, 0x2fe5750<LD8[@current_brk](tbaa=!"any pointer")> [ORD=10] [ID=20]

        0x2fbf468: <multiple use>
        0x3003f20: i64 = Register %vreg0 [ORD=8] [ID=1]

      0x3003e20: i64,ch = CopyFromReg 0x2fbf468, 0x3003f20 [ORD=8] [ID=19]

      0x2fe9bd0: i64 = Constant<7> [ORD=8] [ID=2]

    0x2fe8ed0: i64 = add 0x3003e20, 0x2fe9bd0 [ORD=8] [ID=21]

    0x2fe8dd0: i64 = Constant<-8> [ORD=9] [ID=3]

  0x2fe98d0: i64 = and 0x2fe8ed0, 0x2fe8dd0 [ORD=9] [ID=22]

    0x2fe5f50: <multiple use>
    0x2fe98d0: <multiple use>
  0x2fe92d0: i64 = add 0x2fe5f50, 0x2fe98d0 [ORD=11] [ID=23]

      0x2fe5f50: <multiple use>
      0x2fe92d0: <multiple use>
      0x2fe5e50: <multiple use>
      0x2fe5750: <multiple use>
    0x2fe6350: ch = store 0x2fe5f50:1, 0x2fe92d0, 0x2fe5e50, 0x2fe5750<ST8[@current_brk](tbaa=!"any pointer")> [ORD=12] [ID=24]

    0x2fe8fd0: <multiple use>
    0x2fe5b50: i64 = Constant<12> [ORD=14] [ID=6]

  0x2fe6250: ch,glue = CopyToReg 0x2fe6350, 0x2fe8fd0, 0x2fe5b50 [ORD=14] [ID=25]

    0x2fe6250: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe6250: <multiple use>
  0x2fe6050: ch,glue = CopyToReg 0x2fe6250, 0x2fe6450, 0x2fe92d0, 0x2fe6250:1 [ORD=14] [ID=26]

    0x2fe6050: <multiple use>
    0x2fe94d0: i64 = TargetExternalSymbol'syscall' [ORD=14] [ID=7]

    0x2fe6150: ch = MDNode<0x2f9f510> [ORD=14] [ID=8]

    0x2fe5c50: i64 = TargetConstant<1> [ORD=14] [ID=9]

    0x2fe91d0: i32 = TargetConstant<10> [ORD=14] [ID=10]

    0x2fe8fd0: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe8fd0: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5a50: i64 = Register %RCX [ORD=14] [ID=15]

    0x2fe5d50: <multiple use>
    0x2fe5950: i64 = Register %R11 [ORD=14] [ID=16]

    0x2fe5d50: <multiple use>
    0x2fe99d0: i64 = Register %EFLAGS [ID=18]

    0x2fe6050: <multiple use>
  0x2fe90d0: ch,glue = inlineasm 0x2fe6050, 0x2fe94d0, 0x2fe6150, 0x2fe5c50, 0x2fe91d0, 0x2fe8fd0, 0x2fe5850, 0x2fe8fd0, 0x2fe5850, 0x2fe6450, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe5950, 0x2fe5d50, 0x2fe99d0, 0x2fe6050:1 [ORD=14] [ID=27]

    0x2fe90d0: <multiple use>
    0x2fe8fd0: <multiple use>
    0x2fe90d0: <multiple use>
  0x2fe6550: i64,ch,glue = CopyFromReg 0x2fe90d0, 0x2fe8fd0, 0x2fe90d0:1 [ORD=14] [ID=28]

    0x2fe6550: <multiple use>
    0x2fe8fd0: <multiple use>
        0x2fe6550: <multiple use>
        0x2fe5e50: <multiple use>
        0x2fe5750: <multiple use>
      0x2fe96d0: i64,ch = load 0x2fe6550:1, 0x2fe5e50, 0x2fe5750<LD8[@current_brk](tbaa=!"any pointer")> [ORD=15] [ID=29]

      0x2fe98d0: <multiple use>
    0x3004220: i64 = sub 0x2fe96d0, 0x2fe98d0 [ID=30]

  0x3004020: ch,glue = CopyToReg 0x2fe6550:1, 0x2fe8fd0, 0x3004220 [ID=31]

    0x2fe97d0: i64 = TargetGlobalAddress<i8** @current_brk> 0

  0x2fe5e50: i64 = X86ISD::Wrapper 0x2fe97d0

    0x3004020: <multiple use>
    0x2fe95d0: i64 = TargetConstant<0> [ID=17]

    0x3004020: <multiple use>
  0x3004120: ch = X86ISD::RET_FLAG 0x3004020, 0x2fe95d0, 0x3004020:1 [ID=32]


Optimized legalized selection DAG: BB#0 'malloc:entry'
SelectionDAG has 34 nodes:
  0x2fbf468: ch = EntryToken [ORD=8] [ID=0]

  0x2fe5750: i64 = undef [ORD=10] [ID=5]

  0x2fe8fd0: i64 = Register %RAX [ORD=14] [ID=11]

  0x2fe5850: i32 = TargetConstant<9> [ORD=14] [ID=12]

  0x2fe6450: i64 = Register %RDI [ORD=14] [ID=13]

  0x2fe5d50: i32 = TargetConstant<12> [ORD=14] [ID=14]

    0x2fbf468: <multiple use>
    0x2fe5e50: <multiple use>
    0x2fe5750: <multiple use>
  0x2fe5f50: i64,ch = load 0x2fbf468, 0x2fe5e50, 0x2fe5750<LD8[@current_brk](tbaa=!"any pointer")> [ORD=10] [ID=20]

        0x2fbf468: <multiple use>
        0x3003f20: i64 = Register %vreg0 [ORD=8] [ID=1]

      0x3003e20: i64,ch = CopyFromReg 0x2fbf468, 0x3003f20 [ORD=8] [ID=19]

      0x2fe9bd0: i64 = Constant<7> [ORD=8] [ID=2]

    0x2fe8ed0: i64 = add 0x3003e20, 0x2fe9bd0 [ORD=8] [ID=21]

    0x2fe8dd0: i64 = Constant<-8> [ORD=9] [ID=3]

  0x2fe98d0: i64 = and 0x2fe8ed0, 0x2fe8dd0 [ORD=9] [ID=22]

    0x2fe5f50: <multiple use>
    0x2fe98d0: <multiple use>
  0x2fe92d0: i64 = add 0x2fe5f50, 0x2fe98d0 [ORD=11] [ID=23]

      0x2fe5f50: <multiple use>
      0x2fe92d0: <multiple use>
      0x2fe5e50: <multiple use>
      0x2fe5750: <multiple use>
    0x2fe6350: ch = store 0x2fe5f50:1, 0x2fe92d0, 0x2fe5e50, 0x2fe5750<ST8[@current_brk](tbaa=!"any pointer")> [ORD=12] [ID=24]

    0x2fe8fd0: <multiple use>
    0x2fe5b50: i64 = Constant<12> [ORD=14] [ID=6]

  0x2fe6250: ch,glue = CopyToReg 0x2fe6350, 0x2fe8fd0, 0x2fe5b50 [ORD=14] [ID=25]

    0x2fe6250: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe6250: <multiple use>
  0x2fe6050: ch,glue = CopyToReg 0x2fe6250, 0x2fe6450, 0x2fe92d0, 0x2fe6250:1 [ORD=14] [ID=26]

    0x2fe6050: <multiple use>
    0x2fe94d0: i64 = TargetExternalSymbol'syscall' [ORD=14] [ID=7]

    0x2fe6150: ch = MDNode<0x2f9f510> [ORD=14] [ID=8]

    0x2fe5c50: i64 = TargetConstant<1> [ORD=14] [ID=9]

    0x2fe91d0: i32 = TargetConstant<10> [ORD=14] [ID=10]

    0x2fe8fd0: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe8fd0: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5a50: i64 = Register %RCX [ORD=14] [ID=15]

    0x2fe5d50: <multiple use>
    0x2fe5950: i64 = Register %R11 [ORD=14] [ID=16]

    0x2fe5d50: <multiple use>
    0x2fe99d0: i64 = Register %EFLAGS [ID=18]

    0x2fe6050: <multiple use>
  0x2fe90d0: ch,glue = inlineasm 0x2fe6050, 0x2fe94d0, 0x2fe6150, 0x2fe5c50, 0x2fe91d0, 0x2fe8fd0, 0x2fe5850, 0x2fe8fd0, 0x2fe5850, 0x2fe6450, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe5950, 0x2fe5d50, 0x2fe99d0, 0x2fe6050:1 [ORD=14] [ID=27]

    0x2fe90d0: <multiple use>
    0x2fe8fd0: <multiple use>
    0x2fe90d0: <multiple use>
  0x2fe6550: i64,ch,glue = CopyFromReg 0x2fe90d0, 0x2fe8fd0, 0x2fe90d0:1 [ORD=14] [ID=28]

    0x2fe6550: <multiple use>
    0x2fe8fd0: <multiple use>
        0x2fe6550: <multiple use>
        0x2fe5e50: <multiple use>
        0x2fe5750: <multiple use>
      0x2fe96d0: i64,ch = load 0x2fe6550:1, 0x2fe5e50, 0x2fe5750<LD8[@current_brk](tbaa=!"any pointer")> [ORD=15] [ID=29]

      0x2fe98d0: <multiple use>
    0x3004220: i64 = sub 0x2fe96d0, 0x2fe98d0 [ID=30]

  0x3004020: ch,glue = CopyToReg 0x2fe6550:1, 0x2fe8fd0, 0x3004220 [ID=31]

    0x2fe97d0: i64 = TargetGlobalAddress<i8** @current_brk> 0

  0x2fe5e50: i64 = X86ISD::Wrapper 0x2fe97d0

    0x3004020: <multiple use>
    0x2fe95d0: i64 = TargetConstant<0> [ID=17]

    0x3004020: <multiple use>
  0x3004120: ch = X86ISD::RET_FLAG 0x3004020, 0x2fe95d0, 0x3004020:1 [ID=32]


===== Instruction selection begins: BB#0 'entry'
Selecting: 0x3004120: ch = X86ISD::RET_FLAG 0x3004020, 0x2fe95d0, 0x3004020:1 [ID=33]

ISEL: Starting pattern match on root node: 0x3004120: ch = X86ISD::RET_FLAG 0x3004020, 0x2fe95d0, 0x3004020:1 [ID=33]

  Initial Opcode index to 81356
  Morphed node: 0x3004120: ch = RET 0x3004020, 0x3004020:1

ISEL: Match complete!
=> 0x3004120: ch = RET 0x3004020, 0x3004020:1

Selecting: 0x3004020: ch,glue = CopyToReg 0x2fe6550:1, 0x2fe8fd0, 0x3004220 [ID=32]

=> 0x3004020: ch,glue = CopyToReg 0x2fe6550:1, 0x2fe8fd0, 0x3004220

Selecting: 0x3004220: i64 = sub 0x2fe96d0, 0x2fe98d0 [ID=31]

ISEL: Starting pattern match on root node: 0x3004220: i64 = sub 0x2fe96d0, 0x2fe98d0 [ID=31]

  Initial Opcode index to 69025
  OpcodeSwitch from 69031 to 69142
  Match failed at index 69144
  Continuing at 69223
  TypeSwitch[i64] from 69225 to 69268
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Match failed at index 69268
  Continuing at 69284
  Match failed at index 69288
  Continuing at 69360
  Match failed at index 69363
  Continuing at 69419
  Match failed at index 69430
  Continuing at 69553
  Match failed at index 69554
  Continuing at 69566
  Match failed at index 69567
  Continuing at 69579
  Match failed at index 69580
  Continuing at 69592
  Morphed node: 0x3004220: i64,i32 = SUB64rr 0x2fe96d0, 0x2fe98d0

ISEL: Match complete!
=> 0x3004220: i64,i32 = SUB64rr 0x2fe96d0, 0x2fe98d0

Selecting: 0x2fe96d0: i64,ch = load 0x2fe6550:1, 0x2fe5e50, 0x2fe5750<LD8[@current_brk](tbaa=!"any pointer")> [ORD=15] [ID=30]

ISEL: Starting pattern match on root node: 0x2fe96d0: i64,ch = load 0x2fe6550:1, 0x2fe5e50, 0x2fe5750<LD8[@current_brk](tbaa=!"any pointer")> [ORD=15] [ID=30]

  Initial Opcode index to 72777
  Match failed at index 72789
  Continuing at 72809
  Match failed at index 72812
  Continuing at 72832
  Match failed at index 72835
  Continuing at 72855
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Morphed node: 0x2fe96d0: i64,ch = MOV64rm 0x2fe93d0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe95d0, 0x2fe6550:1<Mem:LD8[@current_brk](tbaa=!"any pointer")> [ORD=15]

ISEL: Match complete!
=> 0x2fe96d0: i64,ch = MOV64rm 0x2fe93d0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe95d0, 0x2fe6550:1<Mem:LD8[@current_brk](tbaa=!"any pointer")> [ORD=15]

Selecting: 0x2fe6550: i64,ch,glue = CopyFromReg 0x2fe90d0, 0x2fe8fd0, 0x2fe90d0:1 [ORD=14] [ID=29]

=> 0x2fe6550: i64,ch,glue = CopyFromReg 0x2fe90d0, 0x2fe8fd0, 0x2fe90d0:1 [ORD=14]

Selecting: 0x2fe90d0: ch,glue = inlineasm 0x2fe6050, 0x2fe94d0, 0x2fe6150, 0x2fe5c50, 0x2fe91d0, 0x2fe8fd0, 0x2fe5850, 0x2fe8fd0, 0x2fe5850, 0x2fe6450, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe5950, 0x2fe5d50, 0x2fe99d0, 0x2fe6050:1 [ORD=14] [ID=28]

=> 0x3004520: ch,glue = inlineasm 0x2fe6050, 0x2fe94d0, 0x2fe6150, 0x2fe5c50, 0x2fe91d0, 0x2fe8fd0, 0x2fe5850, 0x2fe8fd0, 0x2fe5850, 0x2fe6450, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe5950, 0x2fe5d50, 0x2fe99d0, 0x2fe6050:1

Selecting: 0x2fe6050: ch,glue = CopyToReg 0x2fe6250, 0x2fe6450, 0x2fe92d0, 0x2fe6250:1 [ORD=14] [ID=27]

=> 0x2fe6050: ch,glue = CopyToReg 0x2fe6250, 0x2fe6450, 0x2fe92d0, 0x2fe6250:1 [ORD=14]

Selecting: 0x2fe6250: ch,glue = CopyToReg 0x2fe6350, 0x2fe8fd0, 0x2fe5b50 [ORD=14] [ID=26]

=> 0x2fe6250: ch,glue = CopyToReg 0x2fe6350, 0x2fe8fd0, 0x2fe5b50 [ORD=14]

Selecting: 0x2fe6350: ch = store 0x2fe5f50:1, 0x2fe92d0, 0x2fe5e50, 0x2fe5750<ST8[@current_brk](tbaa=!"any pointer")> [ORD=12] [ID=25]

ISEL: Starting pattern match on root node: 0x2fe6350: ch = store 0x2fe5f50:1, 0x2fe92d0, 0x2fe5e50, 0x2fe5750<ST8[@current_brk](tbaa=!"any pointer")> [ORD=12] [ID=25]

  Initial Opcode index to 5
  Skipped scope entry (due to false predicate) at index 13, continuing at 58
  Skipped scope entry (due to false predicate) at index 59, continuing at 104
  Skipped scope entry (due to false predicate) at index 105, continuing at 150
  Skipped scope entry (due to false predicate) at index 151, continuing at 174
  Skipped scope entry (due to false predicate) at index 175, continuing at 198
  Skipped scope entry (due to false predicate) at index 199, continuing at 222
  Skipped scope entry (due to false predicate) at index 223, continuing at 246
  Match failed at index 250
  Continuing at 270
  Continuing at 271
  OpcodeSwitch from 275 to 3975
  Match failed at index 3985
  Continuing at 5191
  Match failed at index 5196
  Continuing at 5344
  Continuing at 11364
  Match failed at index 11369
  Continuing at 11681
  Match failed at index 11685
  Continuing at 12065
  Match failed at index 12069
  Continuing at 12186
  Match failed at index 12190
  Continuing at 12382
  Skipped scope entry (due to false predicate) at index 12387, continuing at 12454
  Skipped scope entry (due to false predicate) at index 12455, continuing at 12549
  Skipped scope entry (due to false predicate) at index 12550, continuing at 12622
  Skipped scope entry (due to false predicate) at index 12623, continuing at 12648
  Skipped scope entry (due to false predicate) at index 12649, continuing at 12674
  Skipped scope entry (due to false predicate) at index 12675, continuing at 12700
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Morphed node: 0x2fe6350: ch = MOV64mr 0x2fe93d0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe95d0, 0x2fe92d0, 0x2fe5f50:1<Mem:ST8[@current_brk](tbaa=!"any pointer")> [ORD=12]

ISEL: Match complete!
=> 0x2fe6350: ch = MOV64mr 0x2fe93d0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe95d0, 0x2fe92d0, 0x2fe5f50:1<Mem:ST8[@current_brk](tbaa=!"any pointer")> [ORD=12]

Selecting: 0x2fe92d0: i64 = add 0x2fe5f50, 0x2fe98d0 [ORD=11] [ID=24]

ISEL: Starting pattern match on root node: 0x2fe92d0: i64 = add 0x2fe5f50, 0x2fe98d0 [ORD=11] [ID=24]

  Initial Opcode index to 67013
  Match failed at index 67018
  Continuing at 67125
  OpcodeSwitch from 67129 to 67133
  Match failed at index 67145
  Continuing at 67165
  Match failed at index 67170
  Continuing at 67190
  Match failed at index 67195
  Continuing at 67215
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Morphed node: 0x2fe92d0: i64,i32,ch = ADD64rm 0x2fe98d0, 0x2fe93d0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe95d0, 0x2fbf468<Mem:LD8[@current_brk](tbaa=!"any pointer")> [ORD=11]

ISEL: Match complete!
=> 0x2fe92d0: i64,i32,ch = ADD64rm 0x2fe98d0, 0x2fe93d0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe95d0, 0x2fbf468<Mem:LD8[@current_brk](tbaa=!"any pointer")> [ORD=11]

Selecting: 0x2fe98d0: i64 = and 0x2fe8ed0, 0x2fe8dd0 [ORD=9] [ID=23]

ISEL: Starting pattern match on root node: 0x2fe98d0: i64 = and 0x2fe8ed0, 0x2fe8dd0 [ORD=9] [ID=23]

  Initial Opcode index to 50420
  Match failed at index 50425
  Continuing at 50616
  Match failed at index 50620
  Continuing at 50727
  Match failed at index 50730
  Continuing at 50841
  Match failed at index 50843
  Continuing at 50990
  Match failed at index 50993
  Continuing at 51074
  Match failed at index 51078
  Continuing at 51127
  Match failed at index 51128
  Continuing at 51157
  Match failed at index 51158
  Continuing at 51189
  Match failed at index 51190
  Continuing at 51219
  Match failed at index 51221
  Continuing at 51399
  Match failed at index 51416
  Continuing at 51430
  Match failed at index 51434
  Continuing at 51448
  Morphed node: 0x2fe98d0: i64,i32 = AND64ri8 0x2fe8ed0, 0x2fe97d0 [ORD=9]

ISEL: Match complete!
=> 0x2fe98d0: i64,i32 = AND64ri8 0x2fe8ed0, 0x2fe97d0 [ORD=9]

Selecting: 0x2fe8ed0: i64 = add 0x3003e20, 0x2fe9bd0 [ORD=8] [ID=21]

ISEL: Starting pattern match on root node: 0x2fe8ed0: i64 = add 0x3003e20, 0x2fe9bd0 [ORD=8] [ID=21]

  Initial Opcode index to 67013
  Match failed at index 67018
  Continuing at 67125
  Match failed at index 67129
  Continuing at 67324
  Match failed at index 67328
  Continuing at 67409
  TypeSwitch[i64] from 67411 to 67454
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg 0x3003e20: i64,ch = CopyFromReg 0x2fbf468, 0x3003f20 [ID=19]
 Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Match failed at index 67454
  Continuing at 67470
  Match failed at index 67474
  Continuing at 67596
  Match failed at index 67600
  Continuing at 67728
  Skipped scope entry (due to false predicate) at index 67738, continuing at 67821
  Skipped scope entry (due to false predicate) at index 67822, continuing at 67914
  Skipped scope entry (due to false predicate) at index 67915, continuing at 67997
  Skipped scope entry (due to false predicate) at index 67998, continuing at 68029
  Match failed at index 67736
  Continuing at 68030
  Match failed at index 68045
  Continuing at 68059
  Match failed at index 68063
  Continuing at 68077
  Morphed node: 0x2fe8ed0: i64,i32 = ADD64ri8 0x3003e20, 0x2fe8dd0 [ORD=8]

ISEL: Match complete!
=> 0x2fe8ed0: i64,i32 = ADD64ri8 0x3003e20, 0x2fe8dd0 [ORD=8]

Selecting: 0x3003e20: i64,ch = CopyFromReg 0x2fbf468, 0x3003f20 [ORD=8] [ID=19]

=> 0x3003e20: i64,ch = CopyFromReg 0x2fbf468, 0x3003f20 [ORD=8]

Selecting: 0x2fe99d0: i64 = Register %EFLAGS [ID=17]

=> 0x2fe99d0: i64 = Register %EFLAGS

Selecting: 0x2fe5950: i64 = Register %R11 [ORD=14] [ID=15]

=> 0x2fe5950: i64 = Register %R11 [ORD=14]

Selecting: 0x2fe5a50: i64 = Register %RCX [ORD=14] [ID=14]

=> 0x2fe5a50: i64 = Register %RCX [ORD=14]

Selecting: 0x2fe5d50: i32 = TargetConstant<12> [ORD=14] [ID=13]

=> 0x2fe5d50: i32 = TargetConstant<12> [ORD=14]

Selecting: 0x2fe6450: i64 = Register %RDI [ORD=14] [ID=12]

=> 0x2fe6450: i64 = Register %RDI [ORD=14]

Selecting: 0x2fe5850: i32 = TargetConstant<9> [ORD=14] [ID=11]

=> 0x2fe5850: i32 = TargetConstant<9> [ORD=14]

Selecting: 0x2fe8fd0: i64 = Register %RAX [ORD=14] [ID=10]

=> 0x2fe8fd0: i64 = Register %RAX [ORD=14]

Selecting: 0x2fe91d0: i32 = TargetConstant<10> [ORD=14] [ID=9]

=> 0x2fe91d0: i32 = TargetConstant<10> [ORD=14]

Selecting: 0x2fe5c50: i64 = TargetConstant<1> [ORD=14] [ID=8]

=> 0x2fe5c50: i64 = TargetConstant<1> [ORD=14]

Selecting: 0x2fe6150: ch = MDNode<0x2f9f510> [ORD=14] [ID=7]

=> 0x2fe6150: ch = MDNode<0x2f9f510> [ORD=14]

Selecting: 0x2fe94d0: i64 = TargetExternalSymbol'syscall' [ORD=14] [ID=6]

=> 0x2fe94d0: i64 = TargetExternalSymbol'syscall' [ORD=14]

Selecting: 0x2fe5b50: i64 = Constant<12> [ORD=14] [ID=5]

ISEL: Starting pattern match on root node: 0x2fe5b50: i64 = Constant<12> [ORD=14] [ID=5]

  Initial Opcode index to 83167
  Skipped scope entry (due to false predicate) at index 83169, continuing at 83219
  TypeSwitch[i64] from 83221 to 83224
  Morphed node: 0x2fe5b50: i64 = MOV64ri64i32 0x2fe9bd0 [ORD=14]

ISEL: Match complete!
=> 0x2fe5b50: i64 = MOV64ri64i32 0x2fe9bd0 [ORD=14]

Selecting: 0x3003f20: i64 = Register %vreg0 [ORD=8] [ID=1]

=> 0x3003f20: i64 = Register %vreg0 [ORD=8]

Selecting: 0x2fbf468: ch = EntryToken [ORD=8] [ID=0]

=> 0x2fbf468: ch = EntryToken [ORD=8]

===== Instruction selection ends:
Selected selection DAG: BB#0 'malloc:entry'
SelectionDAG has 35 nodes:
  0x2fbf468: ch = EntryToken [ORD=8]

  0x2fe8fd0: i64 = Register %RAX [ORD=14]

  0x2fe5850: i32 = TargetConstant<9> [ORD=14]

  0x2fe6450: i64 = Register %RDI [ORD=14]

  0x2fe5d50: i32 = TargetConstant<12> [ORD=14]

        0x2fbf468: <multiple use>
        0x3003f20: i64 = Register %vreg0 [ORD=8]

      0x3003e20: i64,ch = CopyFromReg 0x2fbf468, 0x3003f20 [ORD=8]

      0x2fe8dd0: i64 = TargetConstant<7>

    0x2fe8ed0: i64,i32 = ADD64ri8 0x3003e20, 0x2fe8dd0 [ORD=8]

    0x2fe97d0: i64 = TargetConstant<-8>

  0x2fe98d0: i64,i32 = AND64ri8 0x2fe8ed0, 0x2fe97d0 [ORD=9]

    0x2fe98d0: <multiple use>
    0x2fe93d0: <multiple use>
    0x3004320: <multiple use>
    0x2fe9ad0: <multiple use>
    0x3004420: <multiple use>
    0x2fe95d0: <multiple use>
    0x2fbf468: <multiple use>
  0x2fe92d0: i64,i32,ch = ADD64rm 0x2fe98d0, 0x2fe93d0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe95d0, 0x2fbf468<Mem:LD8[@current_brk](tbaa=!"any pointer")> [ORD=11]

      0x2fe93d0: <multiple use>
      0x3004320: <multiple use>
      0x2fe9ad0: <multiple use>
      0x3004420: <multiple use>
      0x2fe95d0: <multiple use>
      0x2fe92d0: <multiple use>
      0x2fe92d0: <multiple use>
    0x2fe6350: ch = MOV64mr 0x2fe93d0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe95d0, 0x2fe92d0, 0x2fe92d0:2<Mem:ST8[@current_brk](tbaa=!"any pointer")> [ORD=12]

    0x2fe8fd0: <multiple use>
      0x2fe9bd0: i64 = TargetConstant<12>

    0x2fe5b50: i64 = MOV64ri64i32 0x2fe9bd0 [ORD=14]

  0x2fe6250: ch,glue = CopyToReg 0x2fe6350, 0x2fe8fd0, 0x2fe5b50 [ORD=14]

    0x2fe6250: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe92d0: <multiple use>
    0x2fe6250: <multiple use>
  0x2fe6050: ch,glue = CopyToReg 0x2fe6250, 0x2fe6450, 0x2fe92d0, 0x2fe6250:1 [ORD=14]

    0x3004520: <multiple use>
    0x2fe8fd0: <multiple use>
    0x3004520: <multiple use>
  0x2fe6550: i64,ch,glue = CopyFromReg 0x3004520, 0x2fe8fd0, 0x3004520:1 [ORD=14]

    0x2fe6550: <multiple use>
    0x2fe8fd0: <multiple use>
        0x2fe93d0: <multiple use>
        0x3004320: <multiple use>
        0x2fe9ad0: <multiple use>
        0x3004420: <multiple use>
        0x2fe95d0: <multiple use>
        0x2fe6550: <multiple use>
      0x2fe96d0: i64,ch = MOV64rm 0x2fe93d0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe95d0, 0x2fe6550:1<Mem:LD8[@current_brk](tbaa=!"any pointer")> [ORD=15]

      0x2fe98d0: <multiple use>
    0x3004220: i64,i32 = SUB64rr 0x2fe96d0, 0x2fe98d0

  0x3004020: ch,glue = CopyToReg 0x2fe6550:1, 0x2fe8fd0, 0x3004220

  0x2fe95d0: i32 = Register %noreg

  0x2fe9ad0: i64 = Register %noreg

  0x2fe93d0: i64 = Register %RIP

  0x3004320: i8 = TargetConstant<1>

  0x3004420: i32 = TargetGlobalAddress<i8** @current_brk> 0

    0x2fe6050: <multiple use>
    0x2fe94d0: i64 = TargetExternalSymbol'syscall' [ORD=14]

    0x2fe6150: ch = MDNode<0x2f9f510> [ORD=14]

    0x2fe5c50: i64 = TargetConstant<1> [ORD=14]

    0x2fe91d0: i32 = TargetConstant<10> [ORD=14]

    0x2fe8fd0: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe8fd0: <multiple use>
    0x2fe5850: <multiple use>
    0x2fe6450: <multiple use>
    0x2fe5d50: <multiple use>
    0x2fe5a50: i64 = Register %RCX [ORD=14]

    0x2fe5d50: <multiple use>
    0x2fe5950: i64 = Register %R11 [ORD=14]

    0x2fe5d50: <multiple use>
    0x2fe99d0: i64 = Register %EFLAGS

    0x2fe6050: <multiple use>
  0x3004520: ch,glue = inlineasm 0x2fe6050, 0x2fe94d0, 0x2fe6150, 0x2fe5c50, 0x2fe91d0, 0x2fe8fd0, 0x2fe5850, 0x2fe8fd0, 0x2fe5850, 0x2fe6450, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe5950, 0x2fe5d50, 0x2fe99d0, 0x2fe6050:1

    0x3004020: <multiple use>
    0x3004020: <multiple use>
  0x3004120: ch = RET 0x3004020, 0x3004020:1


********** List Scheduling BB#0 'entry' **********
SU(0): 0x3004120: ch = RET 0x3004020, 0x3004020:1 [ID=0]

    0x3004020: ch,glue = CopyToReg 0x2fe6550:1, 0x2fe8fd0, 0x3004220 [ID=0]

  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   ch  SU(6): Latency=1
   val SU(1): Latency=1

SU(1): 0x3004220: i64,i32 = SUB64rr 0x2fe96d0, 0x2fe98d0 [ID=1]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(5): Latency=1
   val SU(2): Latency=1
  Successors:
   val SU(0): Latency=1

SU(2): 0x2fe98d0: i64,i32 = AND64ri8 0x2fe8ed0, 0x2fe97d0 [ORD=9] [ID=2]

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(3): Latency=1
  Successors:
   val SU(1): Latency=1
   val SU(7): Latency=1

SU(3): 0x2fe8ed0: i64,i32 = ADD64ri8 0x3003e20, 0x2fe8dd0 [ORD=8] [ID=3]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(4): Latency=1
  Successors:
   val SU(2): Latency=1

SU(4): 0x3003e20: i64,ch = CopyFromReg 0x2fbf468, 0x3003f20 [ORD=8] [ID=4]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
   val SU(3): Latency=1

SU(5): 0x2fe96d0: i64,ch = MOV64rm 0x2fe93d0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe95d0, 0x2fe6550:1<Mem:LD8[@current_brk](tbaa=!"any pointer")> [ORD=15] [ID=5]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   ch  SU(6): Latency=1
  Successors:
   val SU(1): Latency=1

SU(6): 0x2fe6550: i64,ch,glue = CopyFromReg 0x3004520, 0x2fe8fd0, 0x3004520:1 [ORD=14] [ID=6]

    0x2fe6250: ch,glue = CopyToReg 0x2fe6350, 0x2fe8fd0, 0x2fe5b50 [ORD=14] [ID=6]

    0x2fe6050: ch,glue = CopyToReg 0x2fe6250, 0x2fe6450, 0x2fe92d0, 0x2fe6250:1 [ORD=14] [ID=6]

    0x3004520: ch,glue = inlineasm 0x2fe6050, 0x2fe94d0, 0x2fe6150, 0x2fe5c50, 0x2fe91d0, 0x2fe8fd0, 0x2fe5850, 0x2fe8fd0, 0x2fe5850, 0x2fe6450, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe5950, 0x2fe5d50, 0x2fe99d0, 0x2fe6050:1 [ID=6]

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(7): Latency=1
   ch  SU(9): Latency=1
   val SU(8): Latency=1
  Successors:
   ch  SU(0): Latency=1
   ch  SU(5): Latency=1

SU(7): 0x2fe92d0: i64,i32,ch = ADD64rm 0x2fe98d0, 0x2fe93d0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe95d0, 0x2fbf468<Mem:LD8[@current_brk](tbaa=!"any pointer")> [ORD=11] [ID=7]

  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(2): Latency=1
  Successors:
   val SU(6): Latency=1
   val SU(9): Latency=1
   ch  SU(9): Latency=1

SU(8): 0x2fe5b50: i64 = MOV64ri64i32 0x2fe9bd0 [ORD=14] [ID=8]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
   val SU(6): Latency=1

SU(9): 0x2fe6350: ch = MOV64mr 0x2fe93d0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe95d0, 0x2fe92d0, 0x2fe92d0:2<Mem:ST8[@current_brk](tbaa=!"any pointer")> [ORD=12] [ID=9]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(7): Latency=1
   ch  SU(7): Latency=1
  Successors:
   ch  SU(6): Latency=1


Examining Available:
Height 0: SU(0): 0x3004120: ch = RET 0x3004020, 0x3004020:1 [ID=0]

    0x3004020: ch,glue = CopyToReg 0x2fe6550:1, 0x2fe8fd0, 0x3004220 [ID=0]


*** Scheduling [0]: SU(0): 0x3004120: ch = RET 0x3004020, 0x3004020:1 [ID=0]

    0x3004020: ch,glue = CopyToReg 0x2fe6550:1, 0x2fe8fd0, 0x3004220 [ID=0]

GR64: 1 / 12

Examining Available:
Height 1: SU(1): 0x3004220: i64,i32 = SUB64rr 0x2fe96d0, 0x2fe98d0 [ID=1]


*** Scheduling [1]: SU(1): 0x3004220: i64,i32 = SUB64rr 0x2fe96d0, 0x2fe98d0 [ID=1]

GR64: 2 / 12

Examining Available:
Height 2: SU(5): 0x2fe96d0: i64,ch = MOV64rm 0x2fe93d0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe95d0, 0x2fe6550:1<Mem:LD8[@current_brk](tbaa=!"any pointer")> [ORD=15] [ID=5]


*** Scheduling [2]: SU(5): 0x2fe96d0: i64,ch = MOV64rm 0x2fe93d0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe95d0, 0x2fe6550:1<Mem:LD8[@current_brk](tbaa=!"any pointer")> [ORD=15] [ID=5]

GR64: 1 / 12

Examining Available:
Height 3: SU(6): 0x2fe6550: i64,ch,glue = CopyFromReg 0x3004520, 0x2fe8fd0, 0x3004520:1 [ORD=14] [ID=6]

    0x2fe6250: ch,glue = CopyToReg 0x2fe6350, 0x2fe8fd0, 0x2fe5b50 [ORD=14] [ID=6]

    0x2fe6050: ch,glue = CopyToReg 0x2fe6250, 0x2fe6450, 0x2fe92d0, 0x2fe6250:1 [ORD=14] [ID=6]

    0x3004520: ch,glue = inlineasm 0x2fe6050, 0x2fe94d0, 0x2fe6150, 0x2fe5c50, 0x2fe91d0, 0x2fe8fd0, 0x2fe5850, 0x2fe8fd0, 0x2fe5850, 0x2fe6450, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe5950, 0x2fe5d50, 0x2fe99d0, 0x2fe6050:1 [ID=6]


*** Scheduling [3]: SU(6): 0x2fe6550: i64,ch,glue = CopyFromReg 0x3004520, 0x2fe8fd0, 0x3004520:1 [ORD=14] [ID=6]

    0x2fe6250: ch,glue = CopyToReg 0x2fe6350, 0x2fe8fd0, 0x2fe5b50 [ORD=14] [ID=6]

    0x2fe6050: ch,glue = CopyToReg 0x2fe6250, 0x2fe6450, 0x2fe92d0, 0x2fe6250:1 [ORD=14] [ID=6]

    0x3004520: ch,glue = inlineasm 0x2fe6050, 0x2fe94d0, 0x2fe6150, 0x2fe5c50, 0x2fe91d0, 0x2fe8fd0, 0x2fe5850, 0x2fe8fd0, 0x2fe5850, 0x2fe6450, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe5950, 0x2fe5d50, 0x2fe99d0, 0x2fe6050:1 [ID=6]

GR64: 3 / 12

Examining Available:
Height 4: SU(8): 0x2fe5b50: i64 = MOV64ri64i32 0x2fe9bd0 [ORD=14] [ID=8]

Height 4: SU(9): 0x2fe6350: ch = MOV64mr 0x2fe93d0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe95d0, 0x2fe92d0, 0x2fe92d0:2<Mem:ST8[@current_brk](tbaa=!"any pointer")> [ORD=12] [ID=9]


*** Scheduling [4]: SU(8): 0x2fe5b50: i64 = MOV64ri64i32 0x2fe9bd0 [ORD=14] [ID=8]

GR64: 2 / 12

Examining Available:
Height 4: SU(9): 0x2fe6350: ch = MOV64mr 0x2fe93d0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe95d0, 0x2fe92d0, 0x2fe92d0:2<Mem:ST8[@current_brk](tbaa=!"any pointer")> [ORD=12] [ID=9]


*** Scheduling [5]: SU(9): 0x2fe6350: ch = MOV64mr 0x2fe93d0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe95d0, 0x2fe92d0, 0x2fe92d0:2<Mem:ST8[@current_brk](tbaa=!"any pointer")> [ORD=12] [ID=9]

GR64: 2 / 12

Examining Available:
Height 6: SU(7): 0x2fe92d0: i64,i32,ch = ADD64rm 0x2fe98d0, 0x2fe93d0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe95d0, 0x2fbf468<Mem:LD8[@current_brk](tbaa=!"any pointer")> [ORD=11] [ID=7]


*** Scheduling [6]: SU(7): 0x2fe92d0: i64,i32,ch = ADD64rm 0x2fe98d0, 0x2fe93d0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe95d0, 0x2fbf468<Mem:LD8[@current_brk](tbaa=!"any pointer")> [ORD=11] [ID=7]

GR64: 1 / 12

Examining Available:
Height 7: SU(2): 0x2fe98d0: i64,i32 = AND64ri8 0x2fe8ed0, 0x2fe97d0 [ORD=9] [ID=2]


*** Scheduling [7]: SU(2): 0x2fe98d0: i64,i32 = AND64ri8 0x2fe8ed0, 0x2fe97d0 [ORD=9] [ID=2]

GR64: 1 / 12

Examining Available:
Height 8: SU(3): 0x2fe8ed0: i64,i32 = ADD64ri8 0x3003e20, 0x2fe8dd0 [ORD=8] [ID=3]


*** Scheduling [8]: SU(3): 0x2fe8ed0: i64,i32 = ADD64ri8 0x3003e20, 0x2fe8dd0 [ORD=8] [ID=3]

GR64: 1 / 12

Examining Available:
Height 9: SU(4): 0x3003e20: i64,ch = CopyFromReg 0x2fbf468, 0x3003f20 [ORD=8] [ID=4]


*** Scheduling [9]: SU(4): 0x3003e20: i64,ch = CopyFromReg 0x2fbf468, 0x3003f20 [ORD=8] [ID=4]

*** Final schedule ***
SU(4): 0x3003e20: i64,ch = CopyFromReg 0x2fbf468, 0x3003f20 [ORD=8] [ID=4]

SU(3): 0x2fe8ed0: i64,i32 = ADD64ri8 0x3003e20, 0x2fe8dd0 [ORD=8] [ID=3]

SU(2): 0x2fe98d0: i64,i32 = AND64ri8 0x2fe8ed0, 0x2fe97d0 [ORD=9] [ID=2]

SU(7): 0x2fe92d0: i64,i32,ch = ADD64rm 0x2fe98d0, 0x2fe93d0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe95d0, 0x2fbf468<Mem:LD8[@current_brk](tbaa=!"any pointer")> [ORD=11] [ID=7]

SU(9): 0x2fe6350: ch = MOV64mr 0x2fe93d0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe95d0, 0x2fe92d0, 0x2fe92d0:2<Mem:ST8[@current_brk](tbaa=!"any pointer")> [ORD=12] [ID=9]

SU(8): 0x2fe5b50: i64 = MOV64ri64i32 0x2fe9bd0 [ORD=14] [ID=8]

SU(6): 0x2fe6550: i64,ch,glue = CopyFromReg 0x3004520, 0x2fe8fd0, 0x3004520:1 [ORD=14] [ID=6]

    0x2fe6250: ch,glue = CopyToReg 0x2fe6350, 0x2fe8fd0, 0x2fe5b50 [ORD=14] [ID=6]

    0x2fe6050: ch,glue = CopyToReg 0x2fe6250, 0x2fe6450, 0x2fe92d0, 0x2fe6250:1 [ORD=14] [ID=6]

    0x3004520: ch,glue = inlineasm 0x2fe6050, 0x2fe94d0, 0x2fe6150, 0x2fe5c50, 0x2fe91d0, 0x2fe8fd0, 0x2fe5850, 0x2fe8fd0, 0x2fe5850, 0x2fe6450, 0x2fe5d50, 0x2fe5a50, 0x2fe5d50, 0x2fe5950, 0x2fe5d50, 0x2fe99d0, 0x2fe6050:1 [ID=6]

SU(5): 0x2fe96d0: i64,ch = MOV64rm 0x2fe93d0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe95d0, 0x2fe6550:1<Mem:LD8[@current_brk](tbaa=!"any pointer")> [ORD=15] [ID=5]

SU(1): 0x3004220: i64,i32 = SUB64rr 0x2fe96d0, 0x2fe98d0 [ID=1]

SU(0): 0x3004120: ch = RET 0x3004020, 0x3004020:1 [ID=0]

    0x3004020: ch,glue = CopyToReg 0x2fe6550:1, 0x2fe8fd0, 0x3004220 [ID=0]


TADA
Total amount of phi nodes to update: 0
# Machine code for function malloc: SSA
Function Live Ins: %RDI in %vreg0
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg0<def> = COPY %RDI; GR64:%vreg0
32B		%vreg1<def,tied1> = ADD64ri8 %vreg0<tied0>, 7, %EFLAGS<imp-def,dead>; GR64:%vreg1,%vreg0
48B		%vreg2<def,tied1> = AND64ri8 %vreg1<tied0>, -8, %EFLAGS<imp-def,dead>; GR64:%vreg2,%vreg1
64B		%vreg3<def,tied1> = ADD64rm %vreg2<tied0>, %RIP, 1, %noreg, <ga:@current_brk>, %noreg, %EFLAGS<imp-def,dead>; mem:LD8[@current_brk](tbaa=!"any pointer") GR64:%vreg3,%vreg2
80B		MOV64mr %RIP, 1, %noreg, <ga:@current_brk>, %noreg, %vreg3; mem:ST8[@current_brk](tbaa=!"any pointer") GR64:%vreg3
96B		%vreg4<def> = MOV64ri64i32 12; GR64:%vreg4
112B		%RAX<def> = COPY %vreg4; GR64:%vreg4
128B		%RDI<def> = COPY %vreg3; GR64:%vreg3
144B		INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def>, $1:[reguse], %RAX, $2:[reguse], %RDI, $3:[clobber], %RCX<earlyclobber,imp-def>, $4:[clobber], %R11<earlyclobber,imp-def>, $5:[clobber], %EFLAGS<earlyclobber,imp-def>, <<badref>>
160B		%vreg5<def> = COPY %RAX; GR64:%vreg5
176B		%vreg6<def> = MOV64rm %RIP, 1, %noreg, <ga:@current_brk>, %noreg; mem:LD8[@current_brk](tbaa=!"any pointer") GR64:%vreg6
192B		%vreg7<def,tied1> = SUB64rr %vreg6<tied0>, %vreg2, %EFLAGS<imp-def,dead>; GR64:%vreg7,%vreg6,%vreg2
208B		%RAX<def> = COPY %vreg7; GR64:%vreg7
224B		RET

# End machine code for function malloc.

********** Stack Coloring **********
********** Function: malloc
DeadMachineInstructionElim: DELETING: %vreg5<def> = COPY %RAX; GR64:%vreg5
******** Pre-regalloc Machine LICM: malloc ********
Entering: entry
Exiting: entry
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: malloc
********** PROCESS IMPLICIT DEFS **********
********** Function: malloc
********** REWRITING TWO-ADDR INSTRS **********
********** Function: malloc
	%vreg1<def,tied1> = ADD64ri8 %vreg0<kill,tied0>, 7, %EFLAGS<imp-def,dead>; GR64:%vreg1,%vreg0
		prepend:	%vreg1<def> = COPY %vreg0; GR64:%vreg1,%vreg0
		rewrite to:	%vreg1<def,tied1> = ADD64ri8 %vreg1<tied0>, 7, %EFLAGS<imp-def,dead>; GR64:%vreg1
	%vreg2<def,tied1> = AND64ri8 %vreg1<kill,tied0>, -8, %EFLAGS<imp-def,dead>; GR64:%vreg2,%vreg1
		prepend:	%vreg2<def> = COPY %vreg1; GR64:%vreg2,%vreg1
		rewrite to:	%vreg2<def,tied1> = AND64ri8 %vreg2<tied0>, -8, %EFLAGS<imp-def,dead>; GR64:%vreg2
	%vreg3<def,tied1> = ADD64rm %vreg2<tied0>, %RIP, 1, %noreg, <ga:@current_brk>, %noreg, %EFLAGS<imp-def,dead>; mem:LD8[@current_brk](tbaa=!"any pointer") GR64:%vreg3,%vreg2
2addr:   UNFOLDING: %vreg3<def,tied1> = ADD64rm %vreg2<tied0>, %RIP, 1, %noreg, <ga:@current_brk>, %noreg, %EFLAGS<imp-def,dead>; mem:LD8[@current_brk](tbaa=!"any pointer") GR64:%vreg3,%vreg2
2addr:    NEW LOAD: %vreg8<def> = MOV64rm %RIP, 1, %noreg, <ga:@current_brk>, %noreg; mem:LD8[@current_brk](tbaa=!"any pointer") GR64:%vreg8
2addr:    NEW INST: %vreg3<def,tied1> = ADD64rr %vreg2<tied0>, %vreg8<kill>, %EFLAGS<imp-def,dead>; GR64:%vreg3,%vreg2,%vreg8
2addr: COMMUTING  : %vreg3<def,tied1> = ADD64rr %vreg2<tied0>, %vreg8<kill>, %EFLAGS<imp-def,dead>; GR64:%vreg3,%vreg2,%vreg8
2addr: COMMUTED TO: %vreg3<def,tied1> = ADD64rr %vreg8<kill,tied0>, %vreg2, %EFLAGS<imp-def,dead>; GR64:%vreg3,%vreg8,%vreg2
		prepend:	%vreg3<def> = COPY %vreg8; GR64:%vreg3,%vreg8
		rewrite to:	%vreg3<def,tied1> = ADD64rr %vreg3<tied0>, %vreg2, %EFLAGS<imp-def,dead>; GR64:%vreg3,%vreg2
	%vreg7<def,tied1> = SUB64rr %vreg6<kill,tied0>, %vreg2<kill>, %EFLAGS<imp-def,dead>; GR64:%vreg7,%vreg6,%vreg2
		prepend:	%vreg7<def> = COPY %vreg6; GR64:%vreg7,%vreg6
		rewrite to:	%vreg7<def,tied1> = SUB64rr %vreg7<tied0>, %vreg2<kill>, %EFLAGS<imp-def,dead>; GR64:%vreg7,%vreg2
# Machine code for function malloc: Post SSA
Function Live Ins: %RDI in %vreg0
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg0<def> = COPY %RDI<kill>; GR64:%vreg0
32B		%vreg1<def> = COPY %vreg0<kill>; GR64:%vreg1,%vreg0
48B		%vreg1<def,tied1> = ADD64ri8 %vreg1<tied0>, 7, %EFLAGS<imp-def,dead>; GR64:%vreg1
64B		%vreg2<def> = COPY %vreg1<kill>; GR64:%vreg2,%vreg1
80B		%vreg2<def,tied1> = AND64ri8 %vreg2<tied0>, -8, %EFLAGS<imp-def,dead>; GR64:%vreg2
96B		%vreg8<def> = MOV64rm %RIP, 1, %noreg, <ga:@current_brk>, %noreg; mem:LD8[@current_brk](tbaa=!"any pointer") GR64:%vreg8
112B		%vreg3<def> = COPY %vreg8<kill>; GR64:%vreg3,%vreg8
128B		%vreg3<def,tied1> = ADD64rr %vreg3<tied0>, %vreg2, %EFLAGS<imp-def,dead>; GR64:%vreg3,%vreg2
144B		MOV64mr %RIP, 1, %noreg, <ga:@current_brk>, %noreg, %vreg3; mem:ST8[@current_brk](tbaa=!"any pointer") GR64:%vreg3
160B		%vreg4<def> = MOV64ri64i32 12; GR64:%vreg4
176B		%RAX<def> = COPY %vreg4<kill>; GR64:%vreg4
192B		%RDI<def> = COPY %vreg3<kill>; GR64:%vreg3
208B		INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def,dead>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI<kill>, $3:[clobber], %RCX<earlyclobber,imp-def,dead>, $4:[clobber], %R11<earlyclobber,imp-def,dead>, $5:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
224B		%vreg6<def> = MOV64rm %RIP, 1, %noreg, <ga:@current_brk>, %noreg; mem:LD8[@current_brk](tbaa=!"any pointer") GR64:%vreg6
240B		%vreg7<def> = COPY %vreg6<kill>; GR64:%vreg7,%vreg6
256B		%vreg7<def,tied1> = SUB64rr %vreg7<tied0>, %vreg2<kill>, %EFLAGS<imp-def,dead>; GR64:%vreg7,%vreg2
272B		%RAX<def> = COPY %vreg7<kill>; GR64:%vreg7
288B		RET %RAX<imp-use,kill>

# End machine code for function malloc.

********** COMPUTING LIVE INTERVALS **********
********** Function: malloc
BB#0:		# derived from entry
16B	%vreg0<def> = COPY %RDI<kill>; GR64:%vreg0
		register: %vreg0 +[16r,32r:0)
32B	%vreg1<def> = COPY %vreg0<kill>; GR64:%vreg1,%vreg0
		register: %vreg1 +[32r,64r:0)
48B	%vreg1<def,tied1> = ADD64ri8 %vreg1<tied0>, 7, %EFLAGS<imp-def,dead>; GR64:%vreg1
		register: %vreg1 replace range with [32r,48r:1) RESULT: [32r,48r:1)[48r,64r:0)  0@48r 1@32r
64B	%vreg2<def> = COPY %vreg1<kill>; GR64:%vreg2,%vreg1
		register: %vreg2 +[64r,256r:0)
80B	%vreg2<def,tied1> = AND64ri8 %vreg2<tied0>, -8, %EFLAGS<imp-def,dead>; GR64:%vreg2
		register: %vreg2 replace range with [64r,80r:1) RESULT: [64r,80r:1)[80r,256r:0)  0@80r 1@64r
96B	%vreg8<def> = MOV64rm %RIP, 1, %noreg, <ga:@current_brk>, %noreg; mem:LD8[@current_brk](tbaa=!"any pointer") GR64:%vreg8
		register: %vreg8 +[96r,112r:0)
112B	%vreg3<def> = COPY %vreg8<kill>; GR64:%vreg3,%vreg8
		register: %vreg3 +[112r,192r:0)
128B	%vreg3<def,tied1> = ADD64rr %vreg3<tied0>, %vreg2, %EFLAGS<imp-def,dead>; GR64:%vreg3,%vreg2
		register: %vreg3 replace range with [112r,128r:1) RESULT: [112r,128r:1)[128r,192r:0)  0@128r 1@112r
144B	MOV64mr %RIP, 1, %noreg, <ga:@current_brk>, %noreg, %vreg3; mem:ST8[@current_brk](tbaa=!"any pointer") GR64:%vreg3
160B	%vreg4<def> = MOV64ri64i32 12; GR64:%vreg4
		register: %vreg4 +[160r,176r:0)
176B	%RAX<def> = COPY %vreg4<kill>; GR64:%vreg4
192B	%RDI<def> = COPY %vreg3<kill>; GR64:%vreg3
208B	INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def,dead>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI<kill>, $3:[clobber], %RCX<earlyclobber,imp-def,dead>, $4:[clobber], %R11<earlyclobber,imp-def,dead>, $5:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
224B	%vreg6<def> = MOV64rm %RIP, 1, %noreg, <ga:@current_brk>, %noreg; mem:LD8[@current_brk](tbaa=!"any pointer") GR64:%vreg6
		register: %vreg6 +[224r,240r:0)
240B	%vreg7<def> = COPY %vreg6<kill>; GR64:%vreg7,%vreg6
		register: %vreg7 +[240r,272r:0)
256B	%vreg7<def,tied1> = SUB64rr %vreg7<tied0>, %vreg2<kill>, %EFLAGS<imp-def,dead>; GR64:%vreg7,%vreg2
		register: %vreg7 replace range with [240r,256r:1) RESULT: [240r,256r:1)[256r,272r:0)  0@256r 1@240r
272B	%RAX<def> = COPY %vreg7<kill>; GR64:%vreg7
288B	RET %RAX<imp-use,kill>
Computing live-in reg-units in ABI blocks.
0B	BB#0 DIL#0
Created 1 new intervals.
********** INTERVALS **********
DIL = [0B,16r:0)[192r,208r:1)  0@0B-phi 1@192r
%vreg0 = [16r,32r:0)  0@16r
%vreg1 = [32r,48r:1)[48r,64r:0)  0@48r 1@32r
%vreg2 = [64r,80r:1)[80r,256r:0)  0@80r 1@64r
%vreg3 = [112r,128r:1)[128r,192r:0)  0@128r 1@112r
%vreg4 = [160r,176r:0)  0@160r
%vreg6 = [224r,240r:0)  0@224r
%vreg7 = [240r,256r:1)[256r,272r:0)  0@256r 1@240r
%vreg8 = [96r,112r:0)  0@96r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function malloc: Post SSA
Function Live Ins: %RDI in %vreg0
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg0<def> = COPY %RDI; GR64:%vreg0
32B		%vreg1<def> = COPY %vreg0<kill>; GR64:%vreg1,%vreg0
48B		%vreg1<def,tied1> = ADD64ri8 %vreg1<tied0>, 7, %EFLAGS<imp-def,dead>; GR64:%vreg1
64B		%vreg2<def> = COPY %vreg1<kill>; GR64:%vreg2,%vreg1
80B		%vreg2<def,tied1> = AND64ri8 %vreg2<tied0>, -8, %EFLAGS<imp-def,dead>; GR64:%vreg2
96B		%vreg8<def> = MOV64rm %RIP, 1, %noreg, <ga:@current_brk>, %noreg; mem:LD8[@current_brk](tbaa=!"any pointer") GR64:%vreg8
112B		%vreg3<def> = COPY %vreg8<kill>; GR64:%vreg3,%vreg8
128B		%vreg3<def,tied1> = ADD64rr %vreg3<tied0>, %vreg2, %EFLAGS<imp-def,dead>; GR64:%vreg3,%vreg2
144B		MOV64mr %RIP, 1, %noreg, <ga:@current_brk>, %noreg, %vreg3; mem:ST8[@current_brk](tbaa=!"any pointer") GR64:%vreg3
160B		%vreg4<def> = MOV64ri64i32 12; GR64:%vreg4
176B		%RAX<def> = COPY %vreg4<kill>; GR64:%vreg4
192B		%RDI<def> = COPY %vreg3<kill>; GR64:%vreg3
208B		INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def,dead>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI, $3:[clobber], %RCX<earlyclobber,imp-def,dead>, $4:[clobber], %R11<earlyclobber,imp-def,dead>, $5:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
224B		%vreg6<def> = MOV64rm %RIP, 1, %noreg, <ga:@current_brk>, %noreg; mem:LD8[@current_brk](tbaa=!"any pointer") GR64:%vreg6
240B		%vreg7<def> = COPY %vreg6<kill>; GR64:%vreg7,%vreg6
256B		%vreg7<def,tied1> = SUB64rr %vreg7<tied0>, %vreg2<kill>, %EFLAGS<imp-def,dead>; GR64:%vreg7,%vreg2
272B		%RAX<def> = COPY %vreg7<kill>; GR64:%vreg7
288B		RET %RAX<imp-use,kill>

# End machine code for function malloc.

********** COMPUTING LIVE DEBUG VARIABLES: malloc **********
********** DEBUG VARIABLES **********
********** SIMPLE REGISTER COALESCING **********
********** Function: malloc
********** JOINING INTERVALS ***********
entry:
16B	%vreg0<def> = COPY %RDI; GR64:%vreg0
	Considering merging %vreg0 with %RDI
	Can only merge into reserved registers.
32B	%vreg1<def> = COPY %vreg0<kill>; GR64:%vreg1,%vreg0
	Considering merging to GR64 with %vreg0 in %vreg1
		RHS = %vreg0 [16r,32r:0)  0@16r
		LHS = %vreg1 [32r,48r:1)[48r,64r:0)  0@48r 1@32r
		merge %vreg1:1@32r into %vreg0:0@16r --> @16r
		erased:	32r	%vreg1<def> = COPY %vreg0<kill>; GR64:%vreg1,%vreg0
AllocationOrder(GR64) = [ %RAX %RCX %RDX %RSI %RDI %R8 %R9 %R10 %R11 %RBX %R14 %R15 %R12 %R13 %RBP ]
		updated: 16B	%vreg1<def> = COPY %RDI; GR64:%vreg1
	Joined. Result = %vreg1[16r,48r:1)[48r,64r:0)  0@48r 1@16r
64B	%vreg2<def> = COPY %vreg1; GR64:%vreg2,%vreg1
	Considering merging to GR64 with %vreg1 in %vreg2
		RHS = %vreg1 [16r,48r:1)[48r,64r:0)  0@48r 1@16r
		LHS = %vreg2 [64r,80r:1)[80r,256r:0)  0@80r 1@64r
		merge %vreg2:1@64r into %vreg1:0@48r --> @48r
		erased:	64r	%vreg2<def> = COPY %vreg1; GR64:%vreg2,%vreg1
		updated: 16B	%vreg2<def> = COPY %RDI; GR64:%vreg2
		updated: 48B	%vreg2<def,tied1> = ADD64ri8 %vreg2<tied0>, 7, %EFLAGS<imp-def,dead>; GR64:%vreg2
	Joined. Result = %vreg2[16r,48r:2)[48r,80r:1)[80r,256r:0)  0@80r 1@48r 2@16r
112B	%vreg3<def> = COPY %vreg8<kill>; GR64:%vreg3,%vreg8
	Considering merging to GR64 with %vreg8 in %vreg3
		RHS = %vreg8 [96r,112r:0)  0@96r
		LHS = %vreg3 [112r,128r:1)[128r,192r:0)  0@128r 1@112r
		merge %vreg3:1@112r into %vreg8:0@96r --> @96r
		erased:	112r	%vreg3<def> = COPY %vreg8<kill>; GR64:%vreg3,%vreg8
		updated: 96B	%vreg3<def> = MOV64rm %RIP, 1, %noreg, <ga:@current_brk>, %noreg; mem:LD8[@current_brk](tbaa=!"any pointer") GR64:%vreg3
	Joined. Result = %vreg3[96r,128r:1)[128r,192r:0)  0@128r 1@96r
176B	%RAX<def> = COPY %vreg4<kill>; GR64:%vreg4
	Considering merging %vreg4 with %RAX
	Can only merge into reserved registers.
Remat: %RAX<def> = MOV64ri64i32 12
Shrink: [160r,176r:0)  0@160r
All defs dead: 160r	%vreg4<def,dead> = MOV64ri64i32 12; GR64:%vreg4
Shrunk: [160r,160d:0)  0@160r
Deleting dead def 160r	%vreg4<def,dead> = MOV64ri64i32 12; GR64:%vreg4
192B	%RDI<def> = COPY %vreg3; GR64:%vreg3
	Considering merging %vreg3 with %RDI
	Can only merge into reserved registers.
240B	%vreg7<def> = COPY %vreg6<kill>; GR64:%vreg7,%vreg6
	Considering merging to GR64 with %vreg6 in %vreg7
		RHS = %vreg6 [224r,240r:0)  0@224r
		LHS = %vreg7 [240r,256r:1)[256r,272r:0)  0@256r 1@240r
		merge %vreg7:1@240r into %vreg6:0@224r --> @224r
		erased:	240r	%vreg7<def> = COPY %vreg6<kill>; GR64:%vreg7,%vreg6
		updated: 224B	%vreg7<def> = MOV64rm %RIP, 1, %noreg, <ga:@current_brk>, %noreg; mem:LD8[@current_brk](tbaa=!"any pointer") GR64:%vreg7
	Joined. Result = %vreg7[224r,256r:1)[256r,272r:0)  0@256r 1@224r
272B	%RAX<def> = COPY %vreg7; GR64:%vreg7
	Considering merging %vreg7 with %RAX
	Can only merge into reserved registers.
Trying to inflate 0 regs.
********** INTERVALS **********
DIL = [0B,16r:0)[192r,208r:1)  0@0B-phi 1@192r
%vreg2 = [16r,48r:2)[48r,80r:1)[80r,256r:0)  0@80r 1@48r 2@16r
%vreg3 = [96r,128r:1)[128r,192r:0)  0@128r 1@96r
%vreg7 = [224r,256r:1)[256r,272r:0)  0@256r 1@224r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function malloc: Post SSA
Function Live Ins: %RDI in %vreg0
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg2<def> = COPY %RDI; GR64:%vreg2
48B		%vreg2<def,tied1> = ADD64ri8 %vreg2<tied0>, 7, %EFLAGS<imp-def,dead>; GR64:%vreg2
80B		%vreg2<def,tied1> = AND64ri8 %vreg2<tied0>, -8, %EFLAGS<imp-def,dead>; GR64:%vreg2
96B		%vreg3<def> = MOV64rm %RIP, 1, %noreg, <ga:@current_brk>, %noreg; mem:LD8[@current_brk](tbaa=!"any pointer") GR64:%vreg3
128B		%vreg3<def,tied1> = ADD64rr %vreg3<tied0>, %vreg2, %EFLAGS<imp-def,dead>; GR64:%vreg3,%vreg2
144B		MOV64mr %RIP, 1, %noreg, <ga:@current_brk>, %noreg, %vreg3; mem:ST8[@current_brk](tbaa=!"any pointer") GR64:%vreg3
176B		%RAX<def> = MOV64ri64i32 12
192B		%RDI<def> = COPY %vreg3; GR64:%vreg3
208B		INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def,dead>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI, $3:[clobber], %RCX<earlyclobber,imp-def,dead>, $4:[clobber], %R11<earlyclobber,imp-def,dead>, $5:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
224B		%vreg7<def> = MOV64rm %RIP, 1, %noreg, <ga:@current_brk>, %noreg; mem:LD8[@current_brk](tbaa=!"any pointer") GR64:%vreg7
256B		%vreg7<def,tied1> = SUB64rr %vreg7<tied0>, %vreg2, %EFLAGS<imp-def,dead>; GR64:%vreg7,%vreg2
272B		%RAX<def> = COPY %vreg7; GR64:%vreg7
288B		RET %RAX<imp-use,kill>

# End machine code for function malloc.

********** DEBUG VARIABLES **********
********** Compute Spill Weights **********
********** Function: malloc
********** GREEDY REGISTER ALLOCATION **********
********** Function: malloc

selectOrSplit GR64:%vreg2 [16r,48r:2)[48r,80r:1)[80r,256r:0)  0@80r 1@48r 2@16r
hints: %RDI
missed hint %RDI
assigning %vreg2 to %RDX: DH DL

selectOrSplit GR64:%vreg3 [96r,128r:1)[128r,192r:0)  0@128r 1@96r
hints: %RDI
assigning %vreg3 to %RDI: DIL

selectOrSplit GR64:%vreg7 [224r,256r:1)[256r,272r:0)  0@256r 1@224r
hints: %RAX
assigning %vreg7 to %RAX: AH AL
********** REWRITE VIRTUAL REGISTERS **********
********** Function: malloc
********** REGISTER MAP **********
[%vreg2 -> %RDX] GR64
[%vreg3 -> %RDI] GR64
[%vreg7 -> %RAX] GR64

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg2<def> = COPY %RDI; GR64:%vreg2
48B		%vreg2<def,tied1> = ADD64ri8 %vreg2<kill,tied0>, 7, %EFLAGS<imp-def,dead>; GR64:%vreg2
80B		%vreg2<def,tied1> = AND64ri8 %vreg2<kill,tied0>, -8, %EFLAGS<imp-def,dead>; GR64:%vreg2
96B		%vreg3<def> = MOV64rm %RIP, 1, %noreg, <ga:@current_brk>, %noreg; mem:LD8[@current_brk](tbaa=!"any pointer") GR64:%vreg3
128B		%vreg3<def,tied1> = ADD64rr %vreg3<kill,tied0>, %vreg2, %EFLAGS<imp-def,dead>; GR64:%vreg3,%vreg2
144B		MOV64mr %RIP, 1, %noreg, <ga:@current_brk>, %noreg, %vreg3; mem:ST8[@current_brk](tbaa=!"any pointer") GR64:%vreg3
176B		%RAX<def> = MOV64ri64i32 12
192B		%RDI<def> = COPY %vreg3<kill>; GR64:%vreg3
208B		INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def,dead>, $1:[reguse], %RAX, $2:[reguse], %RDI, $3:[clobber], %RCX<earlyclobber,imp-def,dead>, $4:[clobber], %R11<earlyclobber,imp-def,dead>, $5:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
224B		%vreg7<def> = MOV64rm %RIP, 1, %noreg, <ga:@current_brk>, %noreg; mem:LD8[@current_brk](tbaa=!"any pointer") GR64:%vreg7
256B		%vreg7<def,tied1> = SUB64rr %vreg7<kill,tied0>, %vreg2<kill>, %EFLAGS<imp-def,dead>; GR64:%vreg7,%vreg2
272B		%RAX<def> = COPY %vreg7<kill>; GR64:%vreg7
288B		RET %RAX<imp-use>
> %RDX<def> = COPY %RDI
> %RDX<def,tied1> = ADD64ri8 %RDX<kill,tied0>, 7, %EFLAGS<imp-def,dead>
> %RDX<def,tied1> = AND64ri8 %RDX<kill,tied0>, -8, %EFLAGS<imp-def,dead>
> %RDI<def> = MOV64rm %RIP, 1, %noreg, <ga:@current_brk>, %noreg; mem:LD8[@current_brk](tbaa=!"any pointer")
> %RDI<def,tied1> = ADD64rr %RDI<kill,tied0>, %RDX, %EFLAGS<imp-def,dead>
> MOV64mr %RIP, 1, %noreg, <ga:@current_brk>, %noreg, %RDI; mem:ST8[@current_brk](tbaa=!"any pointer")
> %RAX<def> = MOV64ri64i32 12
> %RDI<def> = COPY %RDI<kill>
Deleting identity copy.
> INLINEASM <es:syscall> [sideeffect] [attdialect], $0:[regdef], %RAX<imp-def,dead>, $1:[reguse], %RAX, $2:[reguse], %RDI, $3:[clobber], %RCX<earlyclobber,imp-def,dead>, $4:[clobber], %R11<earlyclobber,imp-def,dead>, $5:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
> %RAX<def> = MOV64rm %RIP, 1, %noreg, <ga:@current_brk>, %noreg; mem:LD8[@current_brk](tbaa=!"any pointer")
> %RAX<def,tied1> = SUB64rr %RAX<kill,tied0>, %RDX<kill>, %EFLAGS<imp-def,dead>
> %RAX<def> = COPY %RAX<kill>
Deleting identity copy.
> RET %RAX<imp-use>
********** EMITTING LIVE DEBUG VARIABLES **********
********** Stack Slot Coloring **********
********** Function: malloc
******** Post-regalloc Machine LICM: malloc ********
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: malloc
real copy:   %RDX<def> = COPY %RDI
replaced by: %RDX<def> = MOV64rr %RDI
RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0
Frequency(BB#0 derived from LLVM BB entry) = 1024
********** FIX EXECUTION DEPENDENCIES: VR128 **********
The instruction being printed 1508 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 93 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 182 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 1507 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 96 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 1499 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 1504 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 1507 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 2591 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 2234 1501 1647 1642 1506 1648 1643 1645 1640Computing probabilities for lor.end
Computing probabilities for lor.rhs
Computing probabilities for entry



=== isspace
5
is64bit 1
Inside ICMP! setcc maybe  
Initial selection DAG: BB#0 'isspace:entry'
SelectionDAG has 14 nodes:
  0x2fbf468: ch = EntryToken [ORD=18]

  0x3004320: i1 = Constant<-1>

        0x2fbf468: <multiple use>
        0x2fe9ad0: i64 = Register %vreg3

        0x2fe93d0: i64 = Constant<1>

      0x2fe95d0: ch = CopyToReg 0x2fbf468, 0x2fe9ad0, 0x2fe93d0

          0x2fbf468: <multiple use>
          0x2fe9bd0: i64 = Register %vreg2 [ORD=18]

        0x2fe8dd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=18]

        0x2fe97d0: i64 = Constant<32> [ORD=18]

        0x3004520: ch = seteq [ORD=18]

      0x3004420: i1 = setcc 0x2fe8dd0, 0x2fe97d0, 0x3004520 [ORD=18]

      0x3004120: ch = BasicBlock<lor.end 0x2fe1c00>

    0x3004020: ch = brcond 0x2fe95d0, 0x3004420, 0x3004120

    0x3004220: ch = BasicBlock<lor.rhs 0x2fe1b58>

  0x2fe96d0: ch = br 0x3004020, 0x3004220


Optimized lowered selection DAG: BB#0 'isspace:entry'
SelectionDAG has 13 nodes:
  0x2fbf468: ch = EntryToken [ORD=18]

        0x2fbf468: <multiple use>
        0x2fe9ad0: i64 = Register %vreg3

        0x2fe93d0: i64 = Constant<1>

      0x2fe95d0: ch = CopyToReg 0x2fbf468, 0x2fe9ad0, 0x2fe93d0

          0x2fbf468: <multiple use>
          0x2fe9bd0: i64 = Register %vreg2 [ORD=18]

        0x2fe8dd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=18]

        0x2fe97d0: i64 = Constant<32> [ORD=18]

        0x3004520: ch = seteq [ORD=18]

      0x3004420: i1 = setcc 0x2fe8dd0, 0x2fe97d0, 0x3004520 [ORD=18]

      0x3004120: ch = BasicBlock<lor.end 0x2fe1c00>

    0x3004020: ch = brcond 0x2fe95d0, 0x3004420, 0x3004120

    0x3004220: ch = BasicBlock<lor.rhs 0x2fe1b58>

  0x2fe96d0: ch = br 0x3004020, 0x3004220


Legally typed node: 0x3004220: ch = BasicBlock<lor.rhs 0x2fe1b58> [ID=0]

Legally typed node: 0x3004120: ch = BasicBlock<lor.end 0x2fe1c00> [ID=0]

Legally typed node: 0x2fe9ad0: i64 = Register %vreg3 [ID=0]

Legally typed node: 0x2fe93d0: i64 = Constant<1> [ID=0]

Legally typed node: 0x3004520: ch = seteq [ORD=18] [ID=0]

Legally typed node: 0x2fe97d0: i64 = Constant<32> [ORD=18] [ID=0]

Legally typed node: 0x2fe9bd0: i64 = Register %vreg2 [ORD=18] [ID=0]

Legally typed node: 0x2fbf468: ch = EntryToken [ORD=18] [ID=0]

Legally typed node: 0x2fe8dd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=18] [ID=0]

Promote integer result: 0x3004420: i1 = setcc 0x2fe8dd0, 0x2fe97d0, 0x3004520 [ORD=18] [ID=0]

Set Promoted Integer! Opcode0x3004320: i64 = setcc 0x2fe8dd0, 0x2fe97d0, 0x3004520 [ID=0]
5
Legally typed node: 0x3004320: i64 = setcc 0x2fe8dd0, 0x2fe97d0, 0x3004520 [ID=0]

Legally typed node: 0x2fe95d0: ch = CopyToReg 0x2fbf468, 0x2fe9ad0, 0x2fe93d0 [ID=0]

Promote integer operand: 0x3004020: ch = brcond 0x2fe95d0, 0x3004420, 0x3004120 [ID=0]
149 1 105 1
Res.getNode(), N0x3004020 0x3004020: Promote integer operand: 0x2fe6550: i64 = zero_extend 0x3004420 [ID=0]
110 0 105 1
0x3004420: i1 = setcc 0x2fe8dd0, 0x2fe97d0, 0x3004520 [ID=-3]
 1
105 5
105 5
In PIO_ZERO_EXTEND105 5
Res.getNode(), N0x2fe6050 0x2fe6550: Legally typed node: 0x2fe6050: i64 = and 0x3004320, 0x2fe93d0 [ID=0]

Legally typed node: 0x3004020: ch = brcond 0x2fe95d0, 0x2fe6050, 0x3004120 [ID=0]

Legally typed node: 0x2fe96d0: ch = br 0x3004020, 0x3004220 [ID=0]

Legally typed node: 0x7fff8d52a470: ch = handlenode 0x2fe96d0 [ID=0]

Type-legalized selection DAG: BB#0 'isspace:entry'
SelectionDAG has 14 nodes:
  0x2fbf468: ch = EntryToken [ORD=18] [ID=-3]

  0x2fe93d0: i64 = Constant<1> [ID=-3]

        0x2fbf468: <multiple use>
        0x2fe9ad0: i64 = Register %vreg3 [ID=-3]

        0x2fe93d0: <multiple use>
      0x2fe95d0: ch = CopyToReg 0x2fbf468, 0x2fe9ad0, 0x2fe93d0 [ID=-3]

            0x2fbf468: <multiple use>
            0x2fe9bd0: i64 = Register %vreg2 [ORD=18] [ID=-3]

          0x2fe8dd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=18] [ID=-3]

          0x2fe97d0: i64 = Constant<32> [ORD=18] [ID=-3]

          0x3004520: ch = seteq [ORD=18] [ID=-3]

        0x3004320: i64 = setcc 0x2fe8dd0, 0x2fe97d0, 0x3004520 [ID=-3]

        0x2fe93d0: <multiple use>
      0x2fe6050: i64 = and 0x3004320, 0x2fe93d0 [ID=-3]

      0x3004120: ch = BasicBlock<lor.end 0x2fe1c00> [ID=-3]

    0x3004020: ch = brcond 0x2fe95d0, 0x2fe6050, 0x3004120 [ID=-3]

    0x3004220: ch = BasicBlock<lor.rhs 0x2fe1b58> [ID=-3]

  0x2fe96d0: ch = br 0x3004020, 0x3004220 [ID=-3]



Replacing.2 0x2fe6050: i64 = and 0x3004320, 0x2fe93d0 [ID=-3]

With: 0x3004320: i64 = setcc 0x2fe8dd0, 0x2fe97d0, 0x3004520 [ID=-3]

Optimized type-legalized selection DAG: BB#0 'isspace:entry'
SelectionDAG has 13 nodes:
  0x2fbf468: ch = EntryToken [ORD=18] [ID=-3]

        0x2fbf468: <multiple use>
        0x2fe9ad0: i64 = Register %vreg3 [ID=-3]

        0x2fe93d0: i64 = Constant<1> [ID=-3]

      0x2fe95d0: ch = CopyToReg 0x2fbf468, 0x2fe9ad0, 0x2fe93d0 [ID=-3]

          0x2fbf468: <multiple use>
          0x2fe9bd0: i64 = Register %vreg2 [ORD=18] [ID=-3]

        0x2fe8dd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=18] [ID=-3]

        0x2fe97d0: i64 = Constant<32> [ORD=18] [ID=-3]

        0x3004520: ch = seteq [ORD=18] [ID=-3]

      0x3004320: i64 = setcc 0x2fe8dd0, 0x2fe97d0, 0x3004520 [ID=-3]

      0x3004120: ch = BasicBlock<lor.end 0x2fe1c00> [ID=-3]

    0x3004020: ch = brcond 0x2fe95d0, 0x3004320, 0x3004120 [ID=-3]

    0x3004220: ch = BasicBlock<lor.rhs 0x2fe1b58> [ID=-3]

  0x2fe96d0: ch = br 0x3004020, 0x3004220 [ID=-3]


In LegalizeDAG() 146
In legalize Op146
0
0
0
In LegalizeDAG() 149
In legalize Op149
0
0
5
0
105 105 210
Lowering SETCC to CMP. Here are the operands' types 43 5 10 5
In LegalizeDAG() 42
In legalize Op42
0
0
5
5
In LegalizeDAG() 43
In legalize Op43
5
0
0
5
In LegalizeDAG() 5
In legalize Op5
0
In LegalizeDAG() 5
In legalize Op5
0
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 10
In legalize Op10
5
In LegalizeDAG() 10
In legalize Op10
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 1
In legalize Op1
0
In LegalizeDAG() 210
In legalize Op210
0
0
0
5
5
In LegalizeDAG() 200
In legalize Op200
5
5
5
5
In LegalizeDAG() 10
In legalize Op10
5
Legalized selection DAG: BB#0 'isspace:entry'
SelectionDAG has 13 nodes:
  0x2fbf468: ch = EntryToken [ORD=18] [ID=0]

  0x2fe6050: i64 = Constant<4>

        0x2fbf468: <multiple use>
        0x2fe9ad0: i64 = Register %vreg3 [ID=5]

        0x2fe93d0: i64 = Constant<1> [ID=4]

      0x2fe95d0: ch = CopyToReg 0x2fbf468, 0x2fe9ad0, 0x2fe93d0 [ID=9]

      0x3004120: ch = BasicBlock<lor.end 0x2fe1c00> [ID=6]

      0x2fe6050: <multiple use>
          0x2fbf468: <multiple use>
          0x2fe9bd0: i64 = Register %vreg2 [ORD=18] [ID=1]

        0x2fe8dd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=18] [ID=8]

        0x2fe97d0: i64 = Constant<32> [ORD=18] [ID=2]

        0x2fe6050: <multiple use>
      0x3004420: i64 = X86ISD::CMP 0x2fe8dd0, 0x2fe97d0, 0x2fe6050

    0x2fe6550: ch = X86ISD::BRCOND 0x2fe95d0, 0x3004120, 0x2fe6050, 0x3004420

    0x3004220: ch = BasicBlock<lor.rhs 0x2fe1b58> [ID=7]

  0x2fe96d0: ch = br 0x2fe6550, 0x3004220 [ID=12]


Optimized legalized selection DAG: BB#0 'isspace:entry'
SelectionDAG has 13 nodes:
  0x2fbf468: ch = EntryToken [ORD=18] [ID=0]

  0x2fe6050: i64 = Constant<4>

        0x2fbf468: <multiple use>
        0x2fe9ad0: i64 = Register %vreg3 [ID=5]

        0x2fe93d0: i64 = Constant<1> [ID=4]

      0x2fe95d0: ch = CopyToReg 0x2fbf468, 0x2fe9ad0, 0x2fe93d0 [ID=9]

      0x3004120: ch = BasicBlock<lor.end 0x2fe1c00> [ID=6]

      0x2fe6050: <multiple use>
          0x2fbf468: <multiple use>
          0x2fe9bd0: i64 = Register %vreg2 [ORD=18] [ID=1]

        0x2fe8dd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=18] [ID=8]

        0x2fe97d0: i64 = Constant<32> [ORD=18] [ID=2]

        0x2fe6050: <multiple use>
      0x3004420: i64 = X86ISD::CMP 0x2fe8dd0, 0x2fe97d0, 0x2fe6050

    0x2fe6550: ch = X86ISD::BRCOND 0x2fe95d0, 0x3004120, 0x2fe6050, 0x3004420

    0x3004220: ch = BasicBlock<lor.rhs 0x2fe1b58> [ID=7]

  0x2fe96d0: ch = br 0x2fe6550, 0x3004220 [ID=12]


===== Instruction selection begins: BB#0 'entry'
Selecting: 0x2fe96d0: ch = br 0x2fe6550, 0x3004220 [ID=12]

ISEL: Starting pattern match on root node: 0x2fe96d0: ch = br 0x2fe6550, 0x3004220 [ID=12]

  Initial Opcode index to 120382
  Skipped scope entry (due to false predicate) at index 120392, continuing at 120402
  Morphed node: 0x2fe96d0: ch = JMP64pcrel32 0x3004220, 0x2fe6550

ISEL: Match complete!
=> 0x2fe96d0: ch = JMP64pcrel32 0x3004220, 0x2fe6550

Selecting: 0x2fe6550: ch = X86ISD::BRCOND 0x2fe95d0, 0x3004120, 0x2fe6050, 0x3004420 [ID=11]

ISEL: Starting pattern match on root node: 0x2fe6550: ch = X86ISD::BRCOND 0x2fe95d0, 0x3004120, 0x2fe6050, 0x3004420 [ID=11]

  Initial Opcode index to 81395
  Skipped scope entry (due to false predicate) at index 81407, continuing at 81439
  Skipped scope entry (due to false predicate) at index 81440, continuing at 81472
  Skipped scope entry (due to false predicate) at index 81473, continuing at 81505
  Skipped scope entry (due to false predicate) at index 81506, continuing at 81538
  Skipped scope entry (due to false predicate) at index 81545, continuing at 81558
  Morphed node: 0x2fe6550: ch = JE_64 0x3004120, 0x3004320, 0x3004320:1

ISEL: Match complete!
=> 0x2fe6550: ch = JE_64 0x3004120, 0x3004320, 0x3004320:1

Selecting: 0x3004420: i64 = X86ISD::CMP 0x2fe8dd0, 0x2fe97d0, 0x2fe6050 [ID=10]

ISEL: Starting pattern match on root node: 0x3004420: i64 = X86ISD::CMP 0x2fe8dd0, 0x2fe97d0, 0x2fe6050 [ID=10]

  Initial Opcode index to 15658
  Match failed at index 15663
  Continuing at 16336
  Skipped scope entry (due to false predicate) at index 16341, continuing at 16376
  Skipped scope entry (due to false predicate) at index 16377, continuing at 16412
  Skipped scope entry (due to false predicate) at index 16413, continuing at 16448
  Match failed at index 16453
  Continuing at 16482
  Continuing at 16483
  Match failed at index 16486
  Continuing at 16589
  Skipped scope entry (due to false predicate) at index 16593, continuing at 16651
  Skipped scope entry (due to false predicate) at index 16652, continuing at 16710
  Match failed at index 16591
  Continuing at 16711
  Match failed at index 16715
  Continuing at 16903
  Skipped scope entry (due to false predicate) at index 16908, continuing at 16965
  Skipped scope entry (due to false predicate) at index 16966, continuing at 17043
  Skipped scope entry (due to false predicate) at index 17044, continuing at 17121
  Match failed at index 17128
  Continuing at 17140
  Morphed node: 0x3004420: i32 = CMP64ri8 0x2fe8dd0, 0x3004020

ISEL: Match complete!
=> 0x3004420: i32 = CMP64ri8 0x2fe8dd0, 0x3004020

Selecting: 0x2fe95d0: ch = CopyToReg 0x2fbf468, 0x2fe9ad0, 0x2fe93d0 [ID=9]

=> 0x2fe95d0: ch = CopyToReg 0x2fbf468, 0x2fe9ad0, 0x2fe93d0

Selecting: 0x2fe8dd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=18] [ID=8]

=> 0x2fe8dd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=18]

Selecting: 0x3004220: ch = BasicBlock<lor.rhs 0x2fe1b58> [ID=6]

=> 0x3004220: ch = BasicBlock<lor.rhs 0x2fe1b58>

Selecting: 0x3004120: ch = BasicBlock<lor.end 0x2fe1c00> [ID=5]

=> 0x3004120: ch = BasicBlock<lor.end 0x2fe1c00>

Selecting: 0x2fe9ad0: i64 = Register %vreg3 [ID=4]

=> 0x2fe9ad0: i64 = Register %vreg3

Selecting: 0x2fe93d0: i64 = Constant<1> [ID=3]

ISEL: Starting pattern match on root node: 0x2fe93d0: i64 = Constant<1> [ID=3]

  Initial Opcode index to 83167
  Skipped scope entry (due to false predicate) at index 83169, continuing at 83219
  TypeSwitch[i64] from 83221 to 83224
  Morphed node: 0x2fe93d0: i64 = MOV64ri64i32 0x2fe97d0

ISEL: Match complete!
=> 0x2fe93d0: i64 = MOV64ri64i32 0x2fe97d0

Selecting: 0x2fe9bd0: i64 = Register %vreg2 [ORD=18] [ID=1]

=> 0x2fe9bd0: i64 = Register %vreg2 [ORD=18]

Selecting: 0x2fbf468: ch = EntryToken [ORD=18] [ID=0]

=> 0x2fbf468: ch = EntryToken [ORD=18]

===== Instruction selection ends:
Selected selection DAG: BB#0 'isspace:entry'
SelectionDAG has 15 nodes:
  0x2fbf468: ch = EntryToken [ORD=18]

      0x2fbf468: <multiple use>
      0x2fe9ad0: i64 = Register %vreg3

        0x2fe97d0: i64 = TargetConstant<1>

      0x2fe93d0: i64 = MOV64ri64i32 0x2fe97d0

    0x2fe95d0: ch = CopyToReg 0x2fbf468, 0x2fe9ad0, 0x2fe93d0

    0x3004520: i64 = Register %EFLAGS

        0x2fbf468: <multiple use>
        0x2fe9bd0: i64 = Register %vreg2 [ORD=18]

      0x2fe8dd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=18]

      0x3004020: i64 = TargetConstant<32>

    0x3004420: i32 = CMP64ri8 0x2fe8dd0, 0x3004020

  0x3004320: ch,glue = CopyToReg 0x2fe95d0, 0x3004520, 0x3004420

    0x3004220: ch = BasicBlock<lor.rhs 0x2fe1b58>

      0x3004120: ch = BasicBlock<lor.end 0x2fe1c00>

      0x3004320: <multiple use>
      0x3004320: <multiple use>
    0x2fe6550: ch = JE_64 0x3004120, 0x3004320, 0x3004320:1

  0x2fe96d0: ch = JMP64pcrel32 0x3004220, 0x2fe6550


********** List Scheduling BB#0 'entry' **********
SU(0): 0x2fe96d0: ch = JMP64pcrel32 0x3004220, 0x2fe6550 [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x2fe6550: ch = JE_64 0x3004120, 0x3004320, 0x3004320:1 [ID=1]

    0x3004320: ch,glue = CopyToReg 0x2fe95d0, 0x3004520, 0x3004420 [ID=1]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   ch  SU(4): Latency=1
   val SU(2): Latency=1 Reg=%EFLAGS
  Successors:
   ch  SU(0): Latency=1

SU(2): 0x3004420: i32 = CMP64ri8 0x2fe8dd0, 0x3004020 [ID=2]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(3): Latency=1
  Successors:
   val SU(1): Latency=1

SU(3): 0x2fe8dd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=18] [ID=3]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
   val SU(2): Latency=1

SU(4): 0x2fe95d0: ch = CopyToReg 0x2fbf468, 0x2fe9ad0, 0x2fe93d0 [ID=4]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(5): Latency=1
  Successors:
   ch  SU(1): Latency=1

SU(5): 0x2fe93d0: i64 = MOV64ri64i32 0x2fe97d0 [ID=5]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
   val SU(4): Latency=1


Examining Available:
Height 0: SU(0): 0x2fe96d0: ch = JMP64pcrel32 0x3004220, 0x2fe6550 [ID=0]


*** Scheduling [0]: SU(0): 0x2fe96d0: ch = JMP64pcrel32 0x3004220, 0x2fe6550 [ID=0]


Examining Available:
Height 1: SU(1): 0x2fe6550: ch = JE_64 0x3004120, 0x3004320, 0x3004320:1 [ID=1]

    0x3004320: ch,glue = CopyToReg 0x2fe95d0, 0x3004520, 0x3004420 [ID=1]


*** Scheduling [1]: SU(1): 0x2fe6550: ch = JE_64 0x3004120, 0x3004320, 0x3004320:1 [ID=1]

    0x3004320: ch,glue = CopyToReg 0x2fe95d0, 0x3004520, 0x3004420 [ID=1]


Examining Available:
  SU (4)  has no physreg SU(2)  defines a physreg
Height 2: SU(2): 0x3004420: i32 = CMP64ri8 0x2fe8dd0, 0x3004020 [ID=2]

Height 2: SU(4): 0x2fe95d0: ch = CopyToReg 0x2fbf468, 0x2fe9ad0, 0x2fe93d0 [ID=4]

  SU (4)  has no physreg SU(2)  defines a physreg

*** Scheduling [2]: SU(2): 0x3004420: i32 = CMP64ri8 0x2fe8dd0, 0x3004020 [ID=2]

GR64: 1 / 12

Examining Available:
Height 3: SU(3): 0x2fe8dd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=18] [ID=3]

Height 2: SU(4): 0x2fe95d0: ch = CopyToReg 0x2fbf468, 0x2fe9ad0, 0x2fe93d0 [ID=4]


*** Scheduling [3]: SU(3): 0x2fe8dd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=18] [ID=3]


Examining Available:
Height 2: SU(4): 0x2fe95d0: ch = CopyToReg 0x2fbf468, 0x2fe9ad0, 0x2fe93d0 [ID=4]


*** Scheduling [4]: SU(4): 0x2fe95d0: ch = CopyToReg 0x2fbf468, 0x2fe9ad0, 0x2fe93d0 [ID=4]

GR64: 1 / 12

Examining Available:
Height 5: SU(5): 0x2fe93d0: i64 = MOV64ri64i32 0x2fe97d0 [ID=5]


*** Scheduling [5]: SU(5): 0x2fe93d0: i64 = MOV64ri64i32 0x2fe97d0 [ID=5]

*** Final schedule ***
SU(5): 0x2fe93d0: i64 = MOV64ri64i32 0x2fe97d0 [ID=5]

SU(4): 0x2fe95d0: ch = CopyToReg 0x2fbf468, 0x2fe9ad0, 0x2fe93d0 [ID=4]

SU(3): 0x2fe8dd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=18] [ID=3]

SU(2): 0x3004420: i32 = CMP64ri8 0x2fe8dd0, 0x3004020 [ID=2]

SU(1): 0x2fe6550: ch = JE_64 0x3004120, 0x3004320, 0x3004320:1 [ID=1]

    0x3004320: ch,glue = CopyToReg 0x2fe95d0, 0x3004520, 0x3004420 [ID=1]

SU(0): 0x2fe96d0: ch = JMP64pcrel32 0x3004220, 0x2fe6550 [ID=0]


Total amount of phi nodes to update: 1
Node 0 : (0x2fe1ca8, 2147483651)
Inside ICMP! setcc maybe  
Initial selection DAG: BB#1 'isspace:lor.rhs'
SelectionDAG has 11 nodes:
  0x2fbf468: ch = EntryToken [ORD=19]

    0x2fbf468: <multiple use>
    0x2fe8dd0: i64 = Register %vreg0

            0x2fbf468: <multiple use>
            0x2fe97d0: i64 = Register %vreg2 [ORD=19]

          0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x2fe97d0 [ORD=19]

          0x3004320: i64 = Constant<-9> [ORD=19]

        0x3004520: i64 = add 0x3004020, 0x3004320 [ORD=19]

        0x2fe96d0: i64 = Constant<5> [ORD=20]

        0x2fe6550: ch = setlt [ORD=20]

      0x3004420: i1 = setcc 0x3004520, 0x2fe96d0, 0x2fe6550 [ORD=20]

    0x2fe95d0: i64 = any_extend 0x3004420

  0x3004220: ch = CopyToReg 0x2fbf468, 0x2fe8dd0, 0x2fe95d0


Optimized lowered selection DAG: BB#1 'isspace:lor.rhs'
SelectionDAG has 11 nodes:
  0x2fbf468: ch = EntryToken [ORD=19]

    0x2fbf468: <multiple use>
    0x2fe8dd0: i64 = Register %vreg0

            0x2fbf468: <multiple use>
            0x2fe97d0: i64 = Register %vreg2 [ORD=19]

          0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x2fe97d0 [ORD=19]

          0x3004320: i64 = Constant<-9> [ORD=19]

        0x3004520: i64 = add 0x3004020, 0x3004320 [ORD=19]

        0x2fe96d0: i64 = Constant<5> [ORD=20]

        0x2fe6550: ch = setlt [ORD=20]

      0x3004420: i1 = setcc 0x3004520, 0x2fe96d0, 0x2fe6550 [ORD=20]

    0x2fe95d0: i64 = any_extend 0x3004420

  0x3004220: ch = CopyToReg 0x2fbf468, 0x2fe8dd0, 0x2fe95d0


Legally typed node: 0x2fe8dd0: i64 = Register %vreg0 [ID=0]

Legally typed node: 0x2fe6550: ch = setlt [ORD=20] [ID=0]

Legally typed node: 0x2fe96d0: i64 = Constant<5> [ORD=20] [ID=0]

Legally typed node: 0x3004320: i64 = Constant<-9> [ORD=19] [ID=0]

Legally typed node: 0x2fe97d0: i64 = Register %vreg2 [ORD=19] [ID=0]

Legally typed node: 0x2fbf468: ch = EntryToken [ORD=19] [ID=0]

Legally typed node: 0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x2fe97d0 [ORD=19] [ID=0]

Legally typed node: 0x3004520: i64 = add 0x3004020, 0x3004320 [ORD=19] [ID=0]

Promote integer result: 0x3004420: i1 = setcc 0x3004520, 0x2fe96d0, 0x2fe6550 [ORD=20] [ID=0]

Set Promoted Integer! Opcode0x3004120: i64 = setcc 0x3004520, 0x2fe96d0, 0x2fe6550 [ID=0]
5
Promote integer operand: 0x2fe95d0: i64 = any_extend 0x3004420 [ID=0]
111 0 105 1
0x3004420: i1 = setcc 0x3004520, 0x2fe96d0, 0x2fe6550 [ID=-3]
 1
105 5
105 5
Res.getNode(), N0x3004120 0x2fe95d0: Legally typed node: 0x3004120: i64 = setcc 0x3004520, 0x2fe96d0, 0x2fe6550 [ID=0]

Legally typed node: 0x3004220: ch = CopyToReg 0x2fbf468, 0x2fe8dd0, 0x3004120 [ID=0]

Legally typed node: 0x7fff8d52a470: ch = handlenode 0x3004220 [ID=0]

Type-legalized selection DAG: BB#1 'isspace:lor.rhs'
SelectionDAG has 10 nodes:
  0x2fbf468: ch = EntryToken [ORD=19] [ID=-3]

    0x2fbf468: <multiple use>
    0x2fe8dd0: i64 = Register %vreg0 [ID=-3]

          0x2fbf468: <multiple use>
          0x2fe97d0: i64 = Register %vreg2 [ORD=19] [ID=-3]

        0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x2fe97d0 [ORD=19] [ID=-3]

        0x3004320: i64 = Constant<-9> [ORD=19] [ID=-3]

      0x3004520: i64 = add 0x3004020, 0x3004320 [ORD=19] [ID=-3]

      0x2fe96d0: i64 = Constant<5> [ORD=20] [ID=-3]

      0x2fe6550: ch = setlt [ORD=20] [ID=-3]

    0x3004120: i64 = setcc 0x3004520, 0x2fe96d0, 0x2fe6550 [ID=-3]

  0x3004220: ch = CopyToReg 0x2fbf468, 0x2fe8dd0, 0x3004120 [ID=-3]


Optimized type-legalized selection DAG: BB#1 'isspace:lor.rhs'
SelectionDAG has 10 nodes:
  0x2fbf468: ch = EntryToken [ORD=19] [ID=-3]

    0x2fbf468: <multiple use>
    0x2fe8dd0: i64 = Register %vreg0 [ID=-3]

          0x2fbf468: <multiple use>
          0x2fe97d0: i64 = Register %vreg2 [ORD=19] [ID=-3]

        0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x2fe97d0 [ORD=19] [ID=-3]

        0x3004320: i64 = Constant<-9> [ORD=19] [ID=-3]

      0x3004520: i64 = add 0x3004020, 0x3004320 [ORD=19] [ID=-3]

      0x2fe96d0: i64 = Constant<5> [ORD=20] [ID=-3]

      0x2fe6550: ch = setlt [ORD=20] [ID=-3]

    0x3004120: i64 = setcc 0x3004520, 0x2fe96d0, 0x2fe6550 [ID=-3]

  0x3004220: ch = CopyToReg 0x2fbf468, 0x2fe8dd0, 0x3004120 [ID=-3]


In LegalizeDAG() 42
In legalize Op42
0
0
5
5
In LegalizeDAG() 105
In legalize Op105
5
5
5
0
Lowering SETCC to CMP. Here are the operands' types 48 5 10 5
In LegalizeDAG() 48
In legalize Op48
5
5
5
In LegalizeDAG() 43
In legalize Op43
5
0
0
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 10
In legalize Op10
5
In LegalizeDAG() 10
In legalize Op10
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 1
In legalize Op1
0
In LegalizeDAG() 200
In legalize Op200
5
5
5
5
In LegalizeDAG() 10
In legalize Op10
5
Legalized selection DAG: BB#1 'isspace:lor.rhs'
SelectionDAG has 10 nodes:
  0x2fbf468: ch = EntryToken [ORD=19] [ID=0]

    0x2fbf468: <multiple use>
    0x2fe8dd0: i64 = Register %vreg0 [ID=5]

          0x2fbf468: <multiple use>
          0x2fe97d0: i64 = Register %vreg2 [ORD=19] [ID=1]

        0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x2fe97d0 [ORD=19] [ID=6]

        0x3004320: i64 = Constant<-9> [ORD=19] [ID=2]

      0x3004520: i64 = add 0x3004020, 0x3004320 [ORD=19] [ID=7]

      0x2fe96d0: i64 = Constant<5> [ORD=20] [ID=3]

      0x3004420: i64 = Constant<7>

    0x2fe95d0: i64 = X86ISD::CMP 0x3004520, 0x2fe96d0, 0x3004420

  0x3004220: ch = CopyToReg 0x2fbf468, 0x2fe8dd0, 0x2fe95d0 [ID=9]


Optimized legalized selection DAG: BB#1 'isspace:lor.rhs'
SelectionDAG has 10 nodes:
  0x2fbf468: ch = EntryToken [ORD=19] [ID=0]

    0x2fbf468: <multiple use>
    0x2fe8dd0: i64 = Register %vreg0 [ID=5]

          0x2fbf468: <multiple use>
          0x2fe97d0: i64 = Register %vreg2 [ORD=19] [ID=1]

        0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x2fe97d0 [ORD=19] [ID=6]

        0x3004320: i64 = Constant<-9> [ORD=19] [ID=2]

      0x3004520: i64 = add 0x3004020, 0x3004320 [ORD=19] [ID=7]

      0x2fe96d0: i64 = Constant<5> [ORD=20] [ID=3]

      0x3004420: i64 = Constant<7>

    0x2fe95d0: i64 = X86ISD::CMP 0x3004520, 0x2fe96d0, 0x3004420

  0x3004220: ch = CopyToReg 0x2fbf468, 0x2fe8dd0, 0x2fe95d0 [ID=9]


===== Instruction selection begins: BB#1 'lor.rhs'
Selecting: 0x3004220: ch = CopyToReg 0x2fbf468, 0x2fe8dd0, 0x2fe95d0 [ID=9]

=> 0x3004220: ch = CopyToReg 0x2fbf468, 0x2fe8dd0, 0x2fe95d0

Selecting: 0x2fe95d0: i64 = X86ISD::CMP 0x3004520, 0x2fe96d0, 0x3004420 [ID=8]

ISEL: Starting pattern match on root node: 0x2fe95d0: i64 = X86ISD::CMP 0x3004520, 0x2fe96d0, 0x3004420 [ID=8]

  Initial Opcode index to 15658
  Match failed at index 15663
  Continuing at 16336
  Skipped scope entry (due to false predicate) at index 16341, continuing at 16376
  Skipped scope entry (due to false predicate) at index 16377, continuing at 16412
  Skipped scope entry (due to false predicate) at index 16413, continuing at 16448
  Match failed at index 16453
  Continuing at 16482
  Continuing at 16483
  Match failed at index 16486
  Continuing at 16589
  Skipped scope entry (due to false predicate) at index 16593, continuing at 16651
  Skipped scope entry (due to false predicate) at index 16652, continuing at 16710
  Match failed at index 16591
  Continuing at 16711
  Match failed at index 16715
  Continuing at 16903
  Skipped scope entry (due to false predicate) at index 16908, continuing at 16965
  Skipped scope entry (due to false predicate) at index 16966, continuing at 17043
  Skipped scope entry (due to false predicate) at index 17044, continuing at 17121
  Match failed at index 17128
  Continuing at 17140
  Morphed node: 0x2fe95d0: i32 = CMP64ri8 0x3004520, 0x2fe6550

ISEL: Match complete!
=> 0x2fe95d0: i32 = CMP64ri8 0x3004520, 0x2fe6550

Selecting: 0x3004520: i64 = add 0x3004020, 0x3004320 [ORD=19] [ID=7]

ISEL: Starting pattern match on root node: 0x3004520: i64 = add 0x3004020, 0x3004320 [ORD=19] [ID=7]

  Initial Opcode index to 67013
  Match failed at index 67018
  Continuing at 67125
  Match failed at index 67129
  Continuing at 67324
  Match failed at index 67328
  Continuing at 67409
  TypeSwitch[i64] from 67411 to 67454
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg 0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x2fe97d0 [ID=6]
 Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Match failed at index 67454
  Continuing at 67470
  Match failed at index 67474
  Continuing at 67596
  Match failed at index 67600
  Continuing at 67728
  Skipped scope entry (due to false predicate) at index 67738, continuing at 67821
  Skipped scope entry (due to false predicate) at index 67822, continuing at 67914
  Skipped scope entry (due to false predicate) at index 67915, continuing at 67997
  Skipped scope entry (due to false predicate) at index 67998, continuing at 68029
  Match failed at index 67736
  Continuing at 68030
  Match failed at index 68045
  Continuing at 68059
  Match failed at index 68063
  Continuing at 68077
  Morphed node: 0x3004520: i64,i32 = ADD64ri8 0x3004020, 0x3004120 [ORD=19]

ISEL: Match complete!
=> 0x3004520: i64,i32 = ADD64ri8 0x3004020, 0x3004120 [ORD=19]

Selecting: 0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x2fe97d0 [ORD=19] [ID=6]

=> 0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x2fe97d0 [ORD=19]

Selecting: 0x2fe8dd0: i64 = Register %vreg0 [ID=4]

=> 0x2fe8dd0: i64 = Register %vreg0

Selecting: 0x2fe97d0: i64 = Register %vreg2 [ORD=19] [ID=1]

=> 0x2fe97d0: i64 = Register %vreg2 [ORD=19]

Selecting: 0x2fbf468: ch = EntryToken [ORD=19] [ID=0]

=> 0x2fbf468: ch = EntryToken [ORD=19]

===== Instruction selection ends:
Selected selection DAG: BB#1 'isspace:lor.rhs'
SelectionDAG has 11 nodes:
  0x2fbf468: ch = EntryToken [ORD=19]

  0x2fe96d0: i32 = Register %noreg

  0x3004420: i64 = Register %noreg

    0x2fbf468: <multiple use>
    0x2fe8dd0: i64 = Register %vreg0

          0x2fbf468: <multiple use>
          0x2fe97d0: i64 = Register %vreg2 [ORD=19]

        0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x2fe97d0 [ORD=19]

        0x3004120: i64 = TargetConstant<-9>

      0x3004520: i64,i32 = ADD64ri8 0x3004020, 0x3004120 [ORD=19]

      0x2fe6550: i64 = TargetConstant<5>

    0x2fe95d0: i32 = CMP64ri8 0x3004520, 0x2fe6550

  0x3004220: ch = CopyToReg 0x2fbf468, 0x2fe8dd0, 0x2fe95d0


********** List Scheduling BB#1 'lor.rhs' **********
SU(0): 0x3004220: ch = CopyToReg 0x2fbf468, 0x2fe8dd0, 0x2fe95d0 [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(1): Latency=1

SU(1): 0x2fe95d0: i32 = CMP64ri8 0x3004520, 0x2fe6550 [ID=1]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(2): Latency=1
  Successors:
   val SU(0): Latency=1

SU(2): 0x3004520: i64,i32 = ADD64ri8 0x3004020, 0x3004120 [ORD=19] [ID=2]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(3): Latency=1
  Successors:
   val SU(1): Latency=1

SU(3): 0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x2fe97d0 [ORD=19] [ID=3]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
   val SU(2): Latency=1


Examining Available:
Height 0: SU(0): 0x3004220: ch = CopyToReg 0x2fbf468, 0x2fe8dd0, 0x2fe95d0 [ID=0]


*** Scheduling [0]: SU(0): 0x3004220: ch = CopyToReg 0x2fbf468, 0x2fe8dd0, 0x2fe95d0 [ID=0]


Examining Available:
Height 1: SU(1): 0x2fe95d0: i32 = CMP64ri8 0x3004520, 0x2fe6550 [ID=1]


*** Scheduling [1]: SU(1): 0x2fe95d0: i32 = CMP64ri8 0x3004520, 0x2fe6550 [ID=1]

GR64: 1 / 12

Examining Available:
Height 2: SU(2): 0x3004520: i64,i32 = ADD64ri8 0x3004020, 0x3004120 [ORD=19] [ID=2]


*** Scheduling [2]: SU(2): 0x3004520: i64,i32 = ADD64ri8 0x3004020, 0x3004120 [ORD=19] [ID=2]

GR64: 1 / 12

Examining Available:
Height 3: SU(3): 0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x2fe97d0 [ORD=19] [ID=3]


*** Scheduling [3]: SU(3): 0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x2fe97d0 [ORD=19] [ID=3]

*** Final schedule ***
SU(3): 0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x2fe97d0 [ORD=19] [ID=3]

SU(2): 0x3004520: i64,i32 = ADD64ri8 0x3004020, 0x3004120 [ORD=19] [ID=2]

SU(1): 0x2fe95d0: i32 = CMP64ri8 0x3004520, 0x2fe6550 [ID=1]

SU(0): 0x3004220: ch = CopyToReg 0x2fbf468, 0x2fe8dd0, 0x2fe95d0 [ID=0]


Total amount of phi nodes to update: 1
Node 0 : (0x2fe1ca8, 2147483648)
I've changed this to i64 from i16! Might break returns!Initial selection DAG: BB#2 'isspace:lor.end'
SelectionDAG has 9 nodes:
  0x2fbf468: ch = EntryToken [ORD=21]

    0x2fbf468: <multiple use>
    0x2fe95d0: i64 = Register %RAX

          0x2fbf468: <multiple use>
          0x3004120: i64 = Register %vreg1 [ORD=21]

        0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x3004120 [ORD=21]

      0x2fe96d0: i1 = truncate 0x3004420 [ORD=21]

    0x2fe6550: i64 = zero_extend 0x2fe96d0 [ORD=21]

  0x3004520: ch,glue = CopyToReg 0x2fbf468, 0x2fe95d0, 0x2fe6550

    0x3004520: <multiple use>
    0x3004220: i64 = TargetConstant<0>

    0x3004520: <multiple use>
  0x3004020: ch = X86ISD::RET_FLAG 0x3004520, 0x3004220, 0x3004520:1



Replacing.3 0x2fe6550: i64 = zero_extend 0x2fe96d0 [ORD=21]

With: 0x2fe97d0: i64 = and 0x3004420, 0x2fe8dd0

Optimized lowered selection DAG: BB#2 'isspace:lor.end'
SelectionDAG has 9 nodes:
  0x2fbf468: ch = EntryToken [ORD=21]

    0x2fbf468: <multiple use>
    0x2fe95d0: i64 = Register %RAX

        0x2fbf468: <multiple use>
        0x3004120: i64 = Register %vreg1 [ORD=21]

      0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x3004120 [ORD=21]

      0x2fe8dd0: i64 = Constant<1>

    0x2fe97d0: i64 = and 0x3004420, 0x2fe8dd0

  0x3004520: ch,glue = CopyToReg 0x2fbf468, 0x2fe95d0, 0x2fe97d0

    0x3004520: <multiple use>
    0x3004220: i64 = TargetConstant<0>

    0x3004520: <multiple use>
  0x3004020: ch = X86ISD::RET_FLAG 0x3004520, 0x3004220, 0x3004520:1


Legally typed node: 0x2fe8dd0: i64 = Constant<1> [ID=0]

Legally typed node: 0x2fe95d0: i64 = Register %RAX [ID=0]

Legally typed node: 0x3004220: i64 = TargetConstant<0> [ID=0]

Legally typed node: 0x3004120: i64 = Register %vreg1 [ORD=21] [ID=0]

Legally typed node: 0x2fbf468: ch = EntryToken [ORD=21] [ID=0]

Legally typed node: 0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x3004120 [ORD=21] [ID=0]

Legally typed node: 0x2fe97d0: i64 = and 0x3004420, 0x2fe8dd0 [ID=0]

Legally typed node: 0x3004520: ch,glue = CopyToReg 0x2fbf468, 0x2fe95d0, 0x2fe97d0 [ID=0]

Legally typed node: 0x3004020: ch = X86ISD::RET_FLAG 0x3004520, 0x3004220, 0x3004520:1 [ID=0]

Legally typed node: 0x7fff8d52a470: ch = handlenode 0x3004020 [ID=0]

Type-legalized selection DAG: BB#2 'isspace:lor.end'
SelectionDAG has 9 nodes:
  0x2fbf468: ch = EntryToken [ORD=21] [ID=-3]

    0x2fbf468: <multiple use>
    0x2fe95d0: i64 = Register %RAX [ID=-3]

        0x2fbf468: <multiple use>
        0x3004120: i64 = Register %vreg1 [ORD=21] [ID=-3]

      0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x3004120 [ORD=21] [ID=-3]

      0x2fe8dd0: i64 = Constant<1> [ID=-3]

    0x2fe97d0: i64 = and 0x3004420, 0x2fe8dd0 [ID=-3]

  0x3004520: ch,glue = CopyToReg 0x2fbf468, 0x2fe95d0, 0x2fe97d0 [ID=-3]

    0x3004520: <multiple use>
    0x3004220: i64 = TargetConstant<0> [ID=-3]

    0x3004520: <multiple use>
  0x3004020: ch = X86ISD::RET_FLAG 0x3004520, 0x3004220, 0x3004520:1 [ID=-3]


In LegalizeDAG() 211
In legalize Op211
0
0
5
50
In LegalizeDAG() 42
In legalize Op42
0
50
0
5
5
In LegalizeDAG() 88
In legalize Op88
5
5
5
In LegalizeDAG() 43
In legalize Op43
5
0
0
5
In LegalizeDAG() 10
In legalize Op10
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 29
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 1
In legalize Op1
0
Legalized selection DAG: BB#2 'isspace:lor.end'
SelectionDAG has 9 nodes:
  0x2fbf468: ch = EntryToken [ORD=21] [ID=0]

    0x2fbf468: <multiple use>
    0x2fe95d0: i64 = Register %RAX [ID=3]

        0x2fbf468: <multiple use>
        0x3004120: i64 = Register %vreg1 [ORD=21] [ID=1]

      0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x3004120 [ORD=21] [ID=5]

      0x2fe8dd0: i64 = Constant<1> [ID=4]

    0x2fe97d0: i64 = and 0x3004420, 0x2fe8dd0 [ID=6]

  0x3004520: ch,glue = CopyToReg 0x2fbf468, 0x2fe95d0, 0x2fe97d0 [ID=7]

    0x3004520: <multiple use>
    0x3004220: i64 = TargetConstant<0> [ID=2]

    0x3004520: <multiple use>
  0x3004020: ch = X86ISD::RET_FLAG 0x3004520, 0x3004220, 0x3004520:1 [ID=8]


Optimized legalized selection DAG: BB#2 'isspace:lor.end'
SelectionDAG has 9 nodes:
  0x2fbf468: ch = EntryToken [ORD=21] [ID=0]

    0x2fbf468: <multiple use>
    0x2fe95d0: i64 = Register %RAX [ID=3]

        0x2fbf468: <multiple use>
        0x3004120: i64 = Register %vreg1 [ORD=21] [ID=1]

      0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x3004120 [ORD=21] [ID=5]

      0x2fe8dd0: i64 = Constant<1> [ID=4]

    0x2fe97d0: i64 = and 0x3004420, 0x2fe8dd0 [ID=6]

  0x3004520: ch,glue = CopyToReg 0x2fbf468, 0x2fe95d0, 0x2fe97d0 [ID=7]

    0x3004520: <multiple use>
    0x3004220: i64 = TargetConstant<0> [ID=2]

    0x3004520: <multiple use>
  0x3004020: ch = X86ISD::RET_FLAG 0x3004520, 0x3004220, 0x3004520:1 [ID=8]


===== Instruction selection begins: BB#2 'lor.end'
Selecting: 0x3004020: ch = X86ISD::RET_FLAG 0x3004520, 0x3004220, 0x3004520:1 [ID=8]

ISEL: Starting pattern match on root node: 0x3004020: ch = X86ISD::RET_FLAG 0x3004520, 0x3004220, 0x3004520:1 [ID=8]

  Initial Opcode index to 81356
  Morphed node: 0x3004020: ch = RET 0x3004520, 0x3004520:1

ISEL: Match complete!
=> 0x3004020: ch = RET 0x3004520, 0x3004520:1

Selecting: 0x3004520: ch,glue = CopyToReg 0x2fbf468, 0x2fe95d0, 0x2fe97d0 [ID=7]

=> 0x3004520: ch,glue = CopyToReg 0x2fbf468, 0x2fe95d0, 0x2fe97d0

Selecting: 0x2fe97d0: i64 = and 0x3004420, 0x2fe8dd0 [ID=6]

ISEL: Starting pattern match on root node: 0x2fe97d0: i64 = and 0x3004420, 0x2fe8dd0 [ID=6]

  Initial Opcode index to 50420
  Match failed at index 50425
  Continuing at 50616
  Match failed at index 50620
  Continuing at 50727
  Match failed at index 50730
  Continuing at 50841
  Match failed at index 50843
  Continuing at 50990
  Match failed at index 50993
  Continuing at 51074
  Match failed at index 51078
  Continuing at 51127
  Match failed at index 51128
  Continuing at 51157
  Match failed at index 51158
  Continuing at 51189
  Match failed at index 51190
  Continuing at 51219
  Match failed at index 51221
  Continuing at 51399
  Match failed at index 51416
  Continuing at 51430
  Match failed at index 51434
  Continuing at 51448
  Morphed node: 0x2fe97d0: i64,i32 = AND64ri8 0x3004420, 0x3004220

ISEL: Match complete!
=> 0x2fe97d0: i64,i32 = AND64ri8 0x3004420, 0x3004220

Selecting: 0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x3004120 [ORD=21] [ID=5]

=> 0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x3004120 [ORD=21]

Selecting: 0x2fe95d0: i64 = Register %RAX [ID=3]

=> 0x2fe95d0: i64 = Register %RAX

Selecting: 0x3004120: i64 = Register %vreg1 [ORD=21] [ID=1]

=> 0x3004120: i64 = Register %vreg1 [ORD=21]

Selecting: 0x2fbf468: ch = EntryToken [ORD=21] [ID=0]

=> 0x2fbf468: ch = EntryToken [ORD=21]

===== Instruction selection ends:
Selected selection DAG: BB#2 'isspace:lor.end'
SelectionDAG has 8 nodes:
  0x2fbf468: ch = EntryToken [ORD=21]

    0x2fbf468: <multiple use>
    0x2fe95d0: i64 = Register %RAX

        0x2fbf468: <multiple use>
        0x3004120: i64 = Register %vreg1 [ORD=21]

      0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x3004120 [ORD=21]

      0x3004220: i64 = TargetConstant<1>

    0x2fe97d0: i64,i32 = AND64ri8 0x3004420, 0x3004220

  0x3004520: ch,glue = CopyToReg 0x2fbf468, 0x2fe95d0, 0x2fe97d0

    0x3004520: <multiple use>
    0x3004520: <multiple use>
  0x3004020: ch = RET 0x3004520, 0x3004520:1


********** List Scheduling BB#2 'lor.end' **********
SU(0): 0x3004020: ch = RET 0x3004520, 0x3004520:1 [ID=0]

    0x3004520: ch,glue = CopyToReg 0x2fbf468, 0x2fe95d0, 0x2fe97d0 [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(1): Latency=1

SU(1): 0x2fe97d0: i64,i32 = AND64ri8 0x3004420, 0x3004220 [ID=1]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(2): Latency=1
  Successors:
   val SU(0): Latency=1

SU(2): 0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x3004120 [ORD=21] [ID=2]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
   val SU(1): Latency=1


Examining Available:
Height 0: SU(0): 0x3004020: ch = RET 0x3004520, 0x3004520:1 [ID=0]

    0x3004520: ch,glue = CopyToReg 0x2fbf468, 0x2fe95d0, 0x2fe97d0 [ID=0]


*** Scheduling [0]: SU(0): 0x3004020: ch = RET 0x3004520, 0x3004520:1 [ID=0]

    0x3004520: ch,glue = CopyToReg 0x2fbf468, 0x2fe95d0, 0x2fe97d0 [ID=0]

GR64: 1 / 12

Examining Available:
Height 1: SU(1): 0x2fe97d0: i64,i32 = AND64ri8 0x3004420, 0x3004220 [ID=1]


*** Scheduling [1]: SU(1): 0x2fe97d0: i64,i32 = AND64ri8 0x3004420, 0x3004220 [ID=1]

GR64: 1 / 12

Examining Available:
Height 2: SU(2): 0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x3004120 [ORD=21] [ID=2]


*** Scheduling [2]: SU(2): 0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x3004120 [ORD=21] [ID=2]

*** Final schedule ***
SU(2): 0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x3004120 [ORD=21] [ID=2]

SU(1): 0x2fe97d0: i64,i32 = AND64ri8 0x3004420, 0x3004220 [ID=1]

SU(0): 0x3004020: ch = RET 0x3004520, 0x3004520:1 [ID=0]

    0x3004520: ch,glue = CopyToReg 0x2fbf468, 0x2fe95d0, 0x2fe97d0 [ID=0]


Total amount of phi nodes to update: 0
# Machine code for function isspace: SSA
Function Live Ins: %RDI in %vreg2
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg2<def> = COPY %RDI; GR64:%vreg2
32B		%vreg3<def> = MOV64ri64i32 1; GR64:%vreg3
48B		CMP64ri8 %vreg2, 32, %EFLAGS<imp-def>; GR64:%vreg2
64B		JE_64 <BB#2>, %EFLAGS<imp-use>
80B		JMP64pcrel32 <BB#1>
	    Successors according to CFG: BB#2(16) BB#1(16)

96B	BB#1: derived from LLVM BB %lor.rhs
	    Predecessors according to CFG: BB#0
112B		%vreg4<def,tied1> = ADD64ri8 %vreg2<tied0>, -9, %EFLAGS<imp-def,dead>; GR64:%vreg4,%vreg2
128B		CMP64ri8 %vreg4<kill>, 5, %EFLAGS<imp-def>; GR64:%vreg4
144B		%vreg5<def> = COPY %EFLAGS; GR64:%vreg5
160B		%vreg0<def> = COPY %vreg5; GR64:%vreg0,%vreg5
	    Successors according to CFG: BB#2

176B	BB#2: derived from LLVM BB %lor.end
	    Predecessors according to CFG: BB#0 BB#1
192B		%vreg1<def> = PHI %vreg3, <BB#0>, %vreg0, <BB#1>; GR64:%vreg1,%vreg3,%vreg0
208B		%vreg6<def,tied1> = AND64ri8 %vreg1<tied0>, 1, %EFLAGS<imp-def,dead>; GR64:%vreg6,%vreg1
224B		%RAX<def> = COPY %vreg6; GR64:%vreg6
240B		RET

# End machine code for function isspace.

********** Stack Coloring **********
********** Function: isspace
******** Pre-regalloc Machine LICM: isspace ********
Entering: entry
Entering: lor.rhs
Exiting: lor.rhs
Entering: lor.end
Exiting: lor.end
Exiting: entry
******** Machine Sinking ********
Sink instr %vreg3<def> = MOV64ri64i32 1; GR64:%vreg3
	into block BB#2: derived from LLVM BB %lor.end
    Predecessors according to CFG: BB#0 BB#1
	%vreg1<def> = PHI %vreg3, <BB#0>, %vreg0, <BB#1>; GR64:%vreg1,%vreg3,%vreg0
	%vreg6<def,tied1> = AND64ri8 %vreg1<tied0>, 1, %EFLAGS<imp-def,dead>; GR64:%vreg6,%vreg1
	%RAX<def> = COPY %vreg6; GR64:%vreg6
	RET
Sinking along critical edge.
 *** PUNTING: Not legal or profitable to break critical edge
********** PEEPHOLE OPTIMIZER **********
********** Function: isspace
********** PROCESS IMPLICIT DEFS **********
********** Function: isspace
********** REWRITING TWO-ADDR INSTRS **********
********** Function: isspace
	%vreg4<def,tied1> = ADD64ri8 %vreg2<kill,tied0>, -9, %EFLAGS<imp-def,dead>; GR64:%vreg4,%vreg2
		prepend:	%vreg4<def> = COPY %vreg2; GR64:%vreg4,%vreg2
		rewrite to:	%vreg4<def,tied1> = ADD64ri8 %vreg4<tied0>, -9, %EFLAGS<imp-def,dead>; GR64:%vreg4
	%vreg6<def,tied1> = AND64ri8 %vreg1<kill,tied0>, 1, %EFLAGS<imp-def,dead>; GR64:%vreg6,%vreg1
		prepend:	%vreg6<def> = COPY %vreg1; GR64:%vreg6,%vreg1
		rewrite to:	%vreg6<def,tied1> = AND64ri8 %vreg6<tied0>, 1, %EFLAGS<imp-def,dead>; GR64:%vreg6
# Machine code for function isspace: Post SSA
Function Live Ins: %RDI in %vreg2
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg2<def> = COPY %RDI<kill>; GR64:%vreg2
32B		%vreg3<def> = MOV64ri64i32 1; GR64:%vreg3
48B		CMP64ri8 %vreg2, 32, %EFLAGS<imp-def>; GR64:%vreg2
64B		%vreg7<def> = COPY %vreg3<kill>; GR64:%vreg7,%vreg3
80B		JE_64 <BB#2>, %EFLAGS<imp-use,kill>
96B		JMP64pcrel32 <BB#1>
	    Successors according to CFG: BB#2(16) BB#1(16)

112B	BB#1: derived from LLVM BB %lor.rhs
	    Predecessors according to CFG: BB#0
128B		%vreg4<def> = COPY %vreg2<kill>; GR64:%vreg4,%vreg2
144B		%vreg4<def,tied1> = ADD64ri8 %vreg4<tied0>, -9, %EFLAGS<imp-def,dead>; GR64:%vreg4
160B		CMP64ri8 %vreg4<kill>, 5, %EFLAGS<imp-def>; GR64:%vreg4
176B		%vreg5<def> = COPY %EFLAGS<kill>; GR64:%vreg5
192B		%vreg0<def> = COPY %vreg5<kill>; GR64:%vreg0,%vreg5
208B		%vreg7<def> = COPY %vreg0<kill>; GR64:%vreg7,%vreg0
	    Successors according to CFG: BB#2

224B	BB#2: derived from LLVM BB %lor.end
	    Predecessors according to CFG: BB#0 BB#1
240B		%vreg1<def> = COPY %vreg7<kill>; GR64:%vreg1,%vreg7
256B		%vreg6<def> = COPY %vreg1<kill>; GR64:%vreg6,%vreg1
272B		%vreg6<def,tied1> = AND64ri8 %vreg6<tied0>, 1, %EFLAGS<imp-def,dead>; GR64:%vreg6
288B		%RAX<def> = COPY %vreg6<kill>; GR64:%vreg6
304B		RET %RAX<imp-use,kill>

# End machine code for function isspace.

********** COMPUTING LIVE INTERVALS **********
********** Function: isspace
BB#0:		# derived from entry
16B	%vreg2<def> = COPY %RDI<kill>; GR64:%vreg2
		register: %vreg2 +[16r,112B:0) +[112B,128r:0)
32B	%vreg3<def> = MOV64ri64i32 1; GR64:%vreg3
		register: %vreg3 +[32r,64r:0)
48B	CMP64ri8 %vreg2, 32, %EFLAGS<imp-def>; GR64:%vreg2
64B	%vreg7<def> = COPY %vreg3<kill>; GR64:%vreg7,%vreg3
		register: %vreg7 +[64r,112B:0) phi-join +[224B,240r:1)
80B	JE_64 <BB#2>, %EFLAGS<imp-use,kill>
96B	JMP64pcrel32 <BB#1>
BB#1:		# derived from lor.rhs
128B	%vreg4<def> = COPY %vreg2<kill>; GR64:%vreg4,%vreg2
		register: %vreg4 +[128r,160r:0)
144B	%vreg4<def,tied1> = ADD64ri8 %vreg4<tied0>, -9, %EFLAGS<imp-def,dead>; GR64:%vreg4
		register: %vreg4 replace range with [128r,144r:1) RESULT: [128r,144r:1)[144r,160r:0)  0@144r 1@128r
160B	CMP64ri8 %vreg4<kill>, 5, %EFLAGS<imp-def>; GR64:%vreg4
176B	%vreg5<def> = COPY %EFLAGS<kill>; GR64:%vreg5
		register: %vreg5 +[176r,192r:0)
192B	%vreg0<def> = COPY %vreg5<kill>; GR64:%vreg0,%vreg5
		register: %vreg0 +[192r,208r:0)
208B	%vreg7<def> = COPY %vreg0<kill>; GR64:%vreg7,%vreg0
		register: %vreg7 phi-join +[208r,224B:2)
BB#2:		# derived from lor.end
240B	%vreg1<def> = COPY %vreg7<kill>; GR64:%vreg1,%vreg7
		register: %vreg1 +[240r,256r:0)
256B	%vreg6<def> = COPY %vreg1<kill>; GR64:%vreg6,%vreg1
		register: %vreg6 +[256r,288r:0)
272B	%vreg6<def,tied1> = AND64ri8 %vreg6<tied0>, 1, %EFLAGS<imp-def,dead>; GR64:%vreg6
		register: %vreg6 replace range with [256r,272r:1) RESULT: [256r,272r:1)[272r,288r:0)  0@272r 1@256r
288B	%RAX<def> = COPY %vreg6<kill>; GR64:%vreg6
304B	RET %RAX<imp-use,kill>
Computing live-in reg-units in ABI blocks.
0B	BB#0 DIL#0
Created 1 new intervals.
********** INTERVALS **********
DIL = [0B,16r:0)  0@0B-phi
%vreg0 = [192r,208r:0)  0@192r
%vreg1 = [240r,256r:0)  0@240r
%vreg2 = [16r,128r:0)  0@16r
%vreg3 = [32r,64r:0)  0@32r
%vreg4 = [128r,144r:1)[144r,160r:0)  0@144r 1@128r
%vreg5 = [176r,192r:0)  0@176r
%vreg6 = [256r,272r:1)[272r,288r:0)  0@272r 1@256r
%vreg7 = [64r,112B:0)[208r,224B:2)[224B,240r:1)  0@64r 1@224B-phi 2@208r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function isspace: Post SSA
Function Live Ins: %RDI in %vreg2
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg2<def> = COPY %RDI; GR64:%vreg2
32B		%vreg3<def> = MOV64ri64i32 1; GR64:%vreg3
48B		CMP64ri8 %vreg2, 32, %EFLAGS<imp-def>; GR64:%vreg2
64B		%vreg7<def> = COPY %vreg3<kill>; GR64:%vreg7,%vreg3
80B		JE_64 <BB#2>, %EFLAGS<imp-use,kill>
96B		JMP64pcrel32 <BB#1>
	    Successors according to CFG: BB#2(16) BB#1(16)

112B	BB#1: derived from LLVM BB %lor.rhs
	    Predecessors according to CFG: BB#0
128B		%vreg4<def> = COPY %vreg2<kill>; GR64:%vreg4,%vreg2
144B		%vreg4<def,tied1> = ADD64ri8 %vreg4<tied0>, -9, %EFLAGS<imp-def,dead>; GR64:%vreg4
160B		CMP64ri8 %vreg4<kill>, 5, %EFLAGS<imp-def>; GR64:%vreg4
176B		%vreg5<def> = COPY %EFLAGS<kill>; GR64:%vreg5
192B		%vreg0<def> = COPY %vreg5<kill>; GR64:%vreg0,%vreg5
208B		%vreg7<def> = COPY %vreg0<kill>; GR64:%vreg7,%vreg0
	    Successors according to CFG: BB#2

224B	BB#2: derived from LLVM BB %lor.end
	    Predecessors according to CFG: BB#0 BB#1
240B		%vreg1<def> = COPY %vreg7<kill>; GR64:%vreg1,%vreg7
256B		%vreg6<def> = COPY %vreg1<kill>; GR64:%vreg6,%vreg1
272B		%vreg6<def,tied1> = AND64ri8 %vreg6<tied0>, 1, %EFLAGS<imp-def,dead>; GR64:%vreg6
288B		%RAX<def> = COPY %vreg6<kill>; GR64:%vreg6
304B		RET %RAX<imp-use,kill>

# End machine code for function isspace.

********** COMPUTING LIVE DEBUG VARIABLES: isspace **********
********** DEBUG VARIABLES **********
********** SIMPLE REGISTER COALESCING **********
********** Function: isspace
********** JOINING INTERVALS ***********
entry:
16B	%vreg2<def> = COPY %RDI; GR64:%vreg2
	Considering merging %vreg2 with %RDI
	Can only merge into reserved registers.
64B	%vreg7<def> = COPY %vreg3<kill>; GR64:%vreg7,%vreg3
	Considering merging to GR64 with %vreg3 in %vreg7
		RHS = %vreg3 [32r,64r:0)  0@32r
		LHS = %vreg7 [64r,112B:0)[208r,224B:2)[224B,240r:1)  0@64r 1@224B-phi 2@208r
		merge %vreg7:0@64r into %vreg3:0@32r --> @32r
		erased:	64r	%vreg7<def> = COPY %vreg3<kill>; GR64:%vreg7,%vreg3
		updated: 32B	%vreg7<def> = MOV64ri64i32 1; GR64:%vreg7
	Joined. Result = %vreg7[32r,112B:0)[208r,224B:2)[224B,240r:1)  0@32r 1@224B-phi 2@208r
lor.rhs:
128B	%vreg4<def> = COPY %vreg2<kill>; GR64:%vreg4,%vreg2
	Considering merging to GR64 with %vreg2 in %vreg4
		RHS = %vreg2 [16r,128r:0)  0@16r
		LHS = %vreg4 [128r,144r:1)[144r,160r:0)  0@144r 1@128r
		merge %vreg4:1@128r into %vreg2:0@16r --> @16r
		erased:	128r	%vreg4<def> = COPY %vreg2<kill>; GR64:%vreg4,%vreg2
		updated: 16B	%vreg4<def> = COPY %RDI; GR64:%vreg4
		updated: 48B	CMP64ri8 %vreg4, 32, %EFLAGS<imp-def>; GR64:%vreg4
	Joined. Result = %vreg4[16r,144r:1)[144r,160r:0)  0@144r 1@16r
176B	%vreg5<def> = COPY %EFLAGS<kill>; GR64:%vreg5
	Not coalescable.
192B	%vreg0<def> = COPY %vreg5<kill>; GR64:%vreg0,%vreg5
	Considering merging to GR64 with %vreg5 in %vreg0
		RHS = %vreg5 [176r,192r:0)  0@176r
		LHS = %vreg0 [192r,208r:0)  0@192r
		merge %vreg0:0@192r into %vreg5:0@176r --> @176r
		erased:	192r	%vreg0<def> = COPY %vreg5<kill>; GR64:%vreg0,%vreg5
		updated: 176B	%vreg0<def> = COPY %EFLAGS<kill>; GR64:%vreg0
	Joined. Result = %vreg0[176r,208r:0)  0@176r
208B	%vreg7<def> = COPY %vreg0; GR64:%vreg7,%vreg0
	Considering merging to GR64 with %vreg0 in %vreg7
		RHS = %vreg0 [176r,208r:0)  0@176r
		LHS = %vreg7 [32r,112B:0)[208r,224B:2)[224B,240r:1)  0@32r 1@224B-phi 2@208r
		merge %vreg7:2@208r into %vreg0:0@176r --> @176r
		erased:	208r	%vreg7<def> = COPY %vreg0; GR64:%vreg7,%vreg0
		updated: 176B	%vreg7<def> = COPY %EFLAGS<kill>; GR64:%vreg7
	Joined. Result = %vreg7[32r,112B:0)[176r,224B:2)[224B,240r:1)  0@32r 1@224B-phi 2@176r
lor.end:
240B	%vreg1<def> = COPY %vreg7; GR64:%vreg1,%vreg7
	Considering merging to GR64 with %vreg7 in %vreg1
		RHS = %vreg1 [240r,256r:0)  0@240r
		LHS = %vreg7 [32r,112B:0)[176r,224B:2)[224B,240r:1)  0@32r 1@224B-phi 2@176r
		merge %vreg1:0@240r into %vreg7:1@224B --> @224B
		erased:	240r	%vreg1<def> = COPY %vreg7; GR64:%vreg1,%vreg7
		updated: 256B	%vreg6<def> = COPY %vreg7; GR64:%vreg6,%vreg7
	Joined. Result = %vreg7[32r,112B:0)[176r,224B:2)[224B,256r:1)  0@32r 1@224B-phi 2@176r
256B	%vreg6<def> = COPY %vreg7; GR64:%vreg6,%vreg7
	Considering merging to GR64 with %vreg7 in %vreg6
		RHS = %vreg6 [256r,272r:1)[272r,288r:0)  0@272r 1@256r
		LHS = %vreg7 [32r,112B:0)[176r,224B:2)[224B,256r:1)  0@32r 1@224B-phi 2@176r
		merge %vreg6:1@256r into %vreg7:1@224B --> @224B
		erased:	256r	%vreg6<def> = COPY %vreg7; GR64:%vreg6,%vreg7
		updated: 272B	%vreg7<def,tied1> = AND64ri8 %vreg7<tied0>, 1, %EFLAGS<imp-def,dead>; GR64:%vreg7
		updated: 288B	%RAX<def> = COPY %vreg7; GR64:%vreg7
	Joined. Result = %vreg7[32r,112B:0)[176r,224B:2)[224B,272r:1)[272r,288r:3)  0@32r 1@224B-phi 2@176r 3@272r
288B	%RAX<def> = COPY %vreg7; GR64:%vreg7
	Considering merging %vreg7 with %RAX
	Can only merge into reserved registers.
Trying to inflate 0 regs.
********** INTERVALS **********
DIL = [0B,16r:0)  0@0B-phi
%vreg4 = [16r,144r:1)[144r,160r:0)  0@144r 1@16r
%vreg7 = [32r,112B:0)[176r,224B:2)[224B,272r:1)[272r,288r:3)  0@32r 1@224B-phi 2@176r 3@272r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function isspace: Post SSA
Function Live Ins: %RDI in %vreg2
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg4<def> = COPY %RDI; GR64:%vreg4
32B		%vreg7<def> = MOV64ri64i32 1; GR64:%vreg7
48B		CMP64ri8 %vreg4, 32, %EFLAGS<imp-def>; GR64:%vreg4
80B		JE_64 <BB#2>, %EFLAGS<imp-use,kill>
96B		JMP64pcrel32 <BB#1>
	    Successors according to CFG: BB#2(16) BB#1(16)

112B	BB#1: derived from LLVM BB %lor.rhs
	    Predecessors according to CFG: BB#0
144B		%vreg4<def,tied1> = ADD64ri8 %vreg4<tied0>, -9, %EFLAGS<imp-def,dead>; GR64:%vreg4
160B		CMP64ri8 %vreg4, 5, %EFLAGS<imp-def>; GR64:%vreg4
176B		%vreg7<def> = COPY %EFLAGS<kill>; GR64:%vreg7
	    Successors according to CFG: BB#2

224B	BB#2: derived from LLVM BB %lor.end
	    Predecessors according to CFG: BB#0 BB#1
272B		%vreg7<def,tied1> = AND64ri8 %vreg7<tied0>, 1, %EFLAGS<imp-def,dead>; GR64:%vreg7
288B		%RAX<def> = COPY %vreg7; GR64:%vreg7
304B		RET %RAX<imp-use,kill>

# End machine code for function isspace.

********** DEBUG VARIABLES **********
********** Compute Spill Weights **********
********** Function: isspace
********** GREEDY REGISTER ALLOCATION **********
********** Function: isspace

selectOrSplit GR64:%vreg7 [32r,112B:0)[176r,224B:2)[224B,272r:1)[272r,288r:3)  0@32r 1@224B-phi 2@176r 3@272r
hints: %RAX
assigning %vreg7 to %RAX: AH AL

selectOrSplit GR64:%vreg4 [16r,144r:1)[144r,160r:0)  0@144r 1@16r
hints: %RDI
assigning %vreg4 to %RDI: DIL
********** REWRITE VIRTUAL REGISTERS **********
********** Function: isspace
********** REGISTER MAP **********
[%vreg4 -> %RDI] GR64
[%vreg7 -> %RAX] GR64

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg4<def> = COPY %RDI; GR64:%vreg4
32B		%vreg7<def> = MOV64ri64i32 1; GR64:%vreg7
48B		CMP64ri8 %vreg4, 32, %EFLAGS<imp-def>; GR64:%vreg4
80B		JE_64 <BB#2>, %EFLAGS<imp-use,kill>
96B		JMP64pcrel32 <BB#1>
	    Successors according to CFG: BB#2(16) BB#1(16)
> %RDI<def> = COPY %RDI
Deleting identity copy.
> %RAX<def> = MOV64ri64i32 1
> CMP64ri8 %RDI, 32, %EFLAGS<imp-def>
> JE_64 <BB#2>, %EFLAGS<imp-use,kill>
> JMP64pcrel32 <BB#1>
112B	BB#1: derived from LLVM BB %lor.rhs
	    Live Ins: %RDI
	    Predecessors according to CFG: BB#0
144B		%vreg4<def,tied1> = ADD64ri8 %vreg4<kill,tied0>, -9, %EFLAGS<imp-def,dead>; GR64:%vreg4
160B		CMP64ri8 %vreg4<kill>, 5, %EFLAGS<imp-def>; GR64:%vreg4
176B		%vreg7<def> = COPY %EFLAGS<kill>; GR64:%vreg7
	    Successors according to CFG: BB#2
> %RDI<def,tied1> = ADD64ri8 %RDI<kill,tied0>, -9, %EFLAGS<imp-def,dead>
> CMP64ri8 %RDI<kill>, 5, %EFLAGS<imp-def>
> %RAX<def> = COPY %EFLAGS<kill>
224B	BB#2: derived from LLVM BB %lor.end
	    Live Ins: %RAX
	    Predecessors according to CFG: BB#0 BB#1
272B		%vreg7<def,tied1> = AND64ri8 %vreg7<kill,tied0>, 1, %EFLAGS<imp-def,dead>; GR64:%vreg7
288B		%RAX<def> = COPY %vreg7<kill>; GR64:%vreg7
304B		RET %RAX<imp-use>
> %RAX<def,tied1> = AND64ri8 %RAX<kill,tied0>, 1, %EFLAGS<imp-def,dead>
> %RAX<def> = COPY %RAX<kill>
Deleting identity copy.
> RET %RAX<imp-use>
********** EMITTING LIVE DEBUG VARIABLES **********
********** Stack Slot Coloring **********
********** Function: isspace
******** Post-regalloc Machine LICM: isspace ********

*** Tail-duplicating BB#2
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: isspace
real copy:   %RAX<def> = COPY %EFLAGS<kill>
replaced by: %RAX<def> = POP64r %RSP<imp-def>, %RSP<imp-use>
RPO[BB#0 derived from LLVM BB entry] = 1
RPO[BB#1 derived from LLVM BB lor.rhs] = 2
RPO[BB#2 derived from LLVM BB lor.end] = 3
POT: BB#2 derived from LLVM BB lor.end
POT: BB#1 derived from LLVM BB lor.rhs
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#2 derived from LLVM BB lor.end)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0
Frequency(BB#0 derived from LLVM BB entry) = 1024
doBlock(BB#1 derived from LLVM BB lor.rhs)
Frequency(BB#1 derived from LLVM BB lor.rhs) = 0
Frequency(BB#1 derived from LLVM BB lor.rhs) = 512
doBlock(BB#2 derived from LLVM BB lor.end)
Frequency(BB#2 derived from LLVM BB lor.end) = 0
Frequency(BB#2 derived from LLVM BB lor.end) += 512 --> 512
Frequency(BB#2 derived from LLVM BB lor.end) += 512 --> 1024
Attempting merge from: BB#0 (derived from LLVM BB 'entry')
    BB#2 (derived from LLVM BB 'lor.end') -> CFG conflict
    BB#1 (derived from LLVM BB 'lor.rhs') -> 16 / 32 = 50% (prob)
Merging from BB#0 to BB#1
Attempting merge from: BB#1 (derived from LLVM BB 'lor.rhs')
    BB#2 (derived from LLVM BB 'lor.end') -> 16 / 16 = 100% (prob)
Merging from BB#1 to BB#2
Attempting merge from: BB#2 (derived from LLVM BB 'lor.end')
Finished forming chain for header block BB#0
Placing chain BB#0 (derived from LLVM BB 'entry')
          ... BB#1 (derived from LLVM BB 'lor.rhs')
          ... BB#2 (derived from LLVM BB 'lor.end')
********** FIX EXECUTION DEPENDENCIES: VR128 **********
The instruction being printed 1504 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 530 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 1033 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 1049 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 93 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 530 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 2133 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 2001 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 182 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 2234 1501 1647 1642 1506 1648 1643 1645 1640Computing probabilities for entry



=== isdigit
5
is64bit 1
Inside ICMP! setcc maybe  
I've changed this to i64 from i16! Might break returns!Initial selection DAG: BB#0 'isdigit:entry'
SelectionDAG has 13 nodes:
  0x2fbf468: ch = EntryToken [ORD=22]

    0x2fbf468: <multiple use>
    0x2fe6550: i64 = Register %RAX

            0x2fbf468: <multiple use>
            0x3004220: i64 = Register %vreg0 [ORD=22]

          0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x3004220 [ORD=22]

          0x3004520: i64 = Constant<-48> [ORD=22]

        0x2fe97d0: i64 = add 0x3004020, 0x3004520 [ORD=22]

        0x3004420: i64 = Constant<10> [ORD=23]

        0x2fe95d0: ch = setlt [ORD=23]

      0x3004120: i1 = setcc 0x2fe97d0, 0x3004420, 0x2fe95d0 [ORD=23]

    0x2fe8dd0: i64 = zero_extend 0x3004120 [ORD=24]

  0x3004320: ch,glue = CopyToReg 0x2fbf468, 0x2fe6550, 0x2fe8dd0

    0x3004320: <multiple use>
    0x2fe96d0: i64 = TargetConstant<0>

    0x3004320: <multiple use>
  0x2fe9ad0: ch = X86ISD::RET_FLAG 0x3004320, 0x2fe96d0, 0x3004320:1


Optimized lowered selection DAG: BB#0 'isdigit:entry'
SelectionDAG has 13 nodes:
  0x2fbf468: ch = EntryToken [ORD=22]

    0x2fbf468: <multiple use>
    0x2fe6550: i64 = Register %RAX

            0x2fbf468: <multiple use>
            0x3004220: i64 = Register %vreg0 [ORD=22]

          0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x3004220 [ORD=22]

          0x3004520: i64 = Constant<-48> [ORD=22]

        0x2fe97d0: i64 = add 0x3004020, 0x3004520 [ORD=22]

        0x3004420: i64 = Constant<10> [ORD=23]

        0x2fe95d0: ch = setlt [ORD=23]

      0x3004120: i1 = setcc 0x2fe97d0, 0x3004420, 0x2fe95d0 [ORD=23]

    0x2fe8dd0: i64 = zero_extend 0x3004120 [ORD=24]

  0x3004320: ch,glue = CopyToReg 0x2fbf468, 0x2fe6550, 0x2fe8dd0

    0x3004320: <multiple use>
    0x2fe96d0: i64 = TargetConstant<0>

    0x3004320: <multiple use>
  0x2fe9ad0: ch = X86ISD::RET_FLAG 0x3004320, 0x2fe96d0, 0x3004320:1


Legally typed node: 0x2fe6550: i64 = Register %RAX [ID=0]

Legally typed node: 0x2fe96d0: i64 = TargetConstant<0> [ID=0]

Legally typed node: 0x2fe95d0: ch = setlt [ORD=23] [ID=0]

Legally typed node: 0x3004420: i64 = Constant<10> [ORD=23] [ID=0]

Legally typed node: 0x3004520: i64 = Constant<-48> [ORD=22] [ID=0]

Legally typed node: 0x3004220: i64 = Register %vreg0 [ORD=22] [ID=0]

Legally typed node: 0x2fbf468: ch = EntryToken [ORD=22] [ID=0]

Legally typed node: 0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x3004220 [ORD=22] [ID=0]

Legally typed node: 0x2fe97d0: i64 = add 0x3004020, 0x3004520 [ORD=22] [ID=0]

Promote integer result: 0x3004120: i1 = setcc 0x2fe97d0, 0x3004420, 0x2fe95d0 [ORD=23] [ID=0]

Set Promoted Integer! Opcode0x2fe93d0: i64 = setcc 0x2fe97d0, 0x3004420, 0x2fe95d0 [ID=0]
5
Promote integer operand: 0x2fe8dd0: i64 = zero_extend 0x3004120 [ORD=24] [ID=0]
110 0 105 1
0x3004120: i1 = setcc 0x2fe97d0, 0x3004420, 0x2fe95d0 [ID=-3]
 1
105 5
105 5
In PIO_ZERO_EXTEND105 5
Res.getNode(), N0x2fe6050 0x2fe8dd0: Legally typed node: 0x2fe9bd0: i64 = Constant<1> [ID=0]

Legally typed node: 0x2fe93d0: i64 = setcc 0x2fe97d0, 0x3004420, 0x2fe95d0 [ID=0]

Legally typed node: 0x2fe6050: i64 = and 0x2fe93d0, 0x2fe9bd0 [ID=0]

Legally typed node: 0x3004320: ch,glue = CopyToReg 0x2fbf468, 0x2fe6550, 0x2fe6050 [ID=0]

Legally typed node: 0x2fe9ad0: ch = X86ISD::RET_FLAG 0x3004320, 0x2fe96d0, 0x3004320:1 [ID=0]

Legally typed node: 0x7fff8d52a470: ch = handlenode 0x2fe9ad0 [ID=0]

Type-legalized selection DAG: BB#0 'isdigit:entry'
SelectionDAG has 14 nodes:
  0x2fbf468: ch = EntryToken [ORD=22] [ID=-3]

    0x2fbf468: <multiple use>
    0x2fe6550: i64 = Register %RAX [ID=-3]

            0x2fbf468: <multiple use>
            0x3004220: i64 = Register %vreg0 [ORD=22] [ID=-3]

          0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x3004220 [ORD=22] [ID=-3]

          0x3004520: i64 = Constant<-48> [ORD=22] [ID=-3]

        0x2fe97d0: i64 = add 0x3004020, 0x3004520 [ORD=22] [ID=-3]

        0x3004420: i64 = Constant<10> [ORD=23] [ID=-3]

        0x2fe95d0: ch = setlt [ORD=23] [ID=-3]

      0x2fe93d0: i64 = setcc 0x2fe97d0, 0x3004420, 0x2fe95d0 [ID=-3]

      0x2fe9bd0: i64 = Constant<1> [ID=-3]

    0x2fe6050: i64 = and 0x2fe93d0, 0x2fe9bd0 [ID=-3]

  0x3004320: ch,glue = CopyToReg 0x2fbf468, 0x2fe6550, 0x2fe6050 [ID=-3]

    0x3004320: <multiple use>
    0x2fe96d0: i64 = TargetConstant<0> [ID=-3]

    0x3004320: <multiple use>
  0x2fe9ad0: ch = X86ISD::RET_FLAG 0x3004320, 0x2fe96d0, 0x3004320:1 [ID=-3]



Replacing.2 0x2fe6050: i64 = and 0x2fe93d0, 0x2fe9bd0 [ID=-3]

With: 0x2fe93d0: i64 = setcc 0x2fe97d0, 0x3004420, 0x2fe95d0 [ID=-3]

Optimized type-legalized selection DAG: BB#0 'isdigit:entry'
SelectionDAG has 12 nodes:
  0x2fbf468: ch = EntryToken [ORD=22] [ID=-3]

    0x2fbf468: <multiple use>
    0x2fe6550: i64 = Register %RAX [ID=-3]

          0x2fbf468: <multiple use>
          0x3004220: i64 = Register %vreg0 [ORD=22] [ID=-3]

        0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x3004220 [ORD=22] [ID=-3]

        0x3004520: i64 = Constant<-48> [ORD=22] [ID=-3]

      0x2fe97d0: i64 = add 0x3004020, 0x3004520 [ORD=22] [ID=-3]

      0x3004420: i64 = Constant<10> [ORD=23] [ID=-3]

      0x2fe95d0: ch = setlt [ORD=23] [ID=-3]

    0x2fe93d0: i64 = setcc 0x2fe97d0, 0x3004420, 0x2fe95d0 [ID=-3]

  0x3004320: ch,glue = CopyToReg 0x2fbf468, 0x2fe6550, 0x2fe93d0 [ID=-3]

    0x3004320: <multiple use>
    0x2fe96d0: i64 = TargetConstant<0> [ID=-3]

    0x3004320: <multiple use>
  0x2fe9ad0: ch = X86ISD::RET_FLAG 0x3004320, 0x2fe96d0, 0x3004320:1 [ID=-3]


In LegalizeDAG() 211
In legalize Op211
0
0
5
50
In LegalizeDAG() 42
In legalize Op42
0
50
0
5
5
In LegalizeDAG() 105
In legalize Op105
5
5
5
0
Lowering SETCC to CMP. Here are the operands' types 48 5 10 5
In LegalizeDAG() 48
In legalize Op48
5
5
5
In LegalizeDAG() 43
In legalize Op43
5
0
0
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 29
In LegalizeDAG() 10
In legalize Op10
5
In LegalizeDAG() 10
In legalize Op10
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 1
In legalize Op1
0
In LegalizeDAG() 200
In legalize Op200
5
5
5
5
In LegalizeDAG() 10
In legalize Op10
5
Legalized selection DAG: BB#0 'isdigit:entry'
SelectionDAG has 12 nodes:
  0x2fbf468: ch = EntryToken [ORD=22] [ID=0]

    0x2fbf468: <multiple use>
    0x2fe6550: i64 = Register %RAX [ID=6]

          0x2fbf468: <multiple use>
          0x3004220: i64 = Register %vreg0 [ORD=22] [ID=1]

        0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x3004220 [ORD=22] [ID=7]

        0x3004520: i64 = Constant<-48> [ORD=22] [ID=2]

      0x2fe97d0: i64 = add 0x3004020, 0x3004520 [ORD=22] [ID=8]

      0x3004420: i64 = Constant<10> [ORD=23] [ID=3]

      0x2fe9bd0: i64 = Constant<7>

    0x2fe6050: i64 = X86ISD::CMP 0x2fe97d0, 0x3004420, 0x2fe9bd0

  0x3004320: ch,glue = CopyToReg 0x2fbf468, 0x2fe6550, 0x2fe6050 [ID=10]

    0x3004320: <multiple use>
    0x2fe96d0: i64 = TargetConstant<0> [ID=5]

    0x3004320: <multiple use>
  0x2fe9ad0: ch = X86ISD::RET_FLAG 0x3004320, 0x2fe96d0, 0x3004320:1 [ID=11]


Optimized legalized selection DAG: BB#0 'isdigit:entry'
SelectionDAG has 12 nodes:
  0x2fbf468: ch = EntryToken [ORD=22] [ID=0]

    0x2fbf468: <multiple use>
    0x2fe6550: i64 = Register %RAX [ID=6]

          0x2fbf468: <multiple use>
          0x3004220: i64 = Register %vreg0 [ORD=22] [ID=1]

        0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x3004220 [ORD=22] [ID=7]

        0x3004520: i64 = Constant<-48> [ORD=22] [ID=2]

      0x2fe97d0: i64 = add 0x3004020, 0x3004520 [ORD=22] [ID=8]

      0x3004420: i64 = Constant<10> [ORD=23] [ID=3]

      0x2fe9bd0: i64 = Constant<7>

    0x2fe6050: i64 = X86ISD::CMP 0x2fe97d0, 0x3004420, 0x2fe9bd0

  0x3004320: ch,glue = CopyToReg 0x2fbf468, 0x2fe6550, 0x2fe6050 [ID=10]

    0x3004320: <multiple use>
    0x2fe96d0: i64 = TargetConstant<0> [ID=5]

    0x3004320: <multiple use>
  0x2fe9ad0: ch = X86ISD::RET_FLAG 0x3004320, 0x2fe96d0, 0x3004320:1 [ID=11]


===== Instruction selection begins: BB#0 'entry'
Selecting: 0x2fe9ad0: ch = X86ISD::RET_FLAG 0x3004320, 0x2fe96d0, 0x3004320:1 [ID=11]

ISEL: Starting pattern match on root node: 0x2fe9ad0: ch = X86ISD::RET_FLAG 0x3004320, 0x2fe96d0, 0x3004320:1 [ID=11]

  Initial Opcode index to 81356
  Morphed node: 0x2fe9ad0: ch = RET 0x3004320, 0x3004320:1

ISEL: Match complete!
=> 0x2fe9ad0: ch = RET 0x3004320, 0x3004320:1

Selecting: 0x3004320: ch,glue = CopyToReg 0x2fbf468, 0x2fe6550, 0x2fe6050 [ID=10]

=> 0x3004320: ch,glue = CopyToReg 0x2fbf468, 0x2fe6550, 0x2fe6050

Selecting: 0x2fe6050: i64 = X86ISD::CMP 0x2fe97d0, 0x3004420, 0x2fe9bd0 [ID=9]

ISEL: Starting pattern match on root node: 0x2fe6050: i64 = X86ISD::CMP 0x2fe97d0, 0x3004420, 0x2fe9bd0 [ID=9]

  Initial Opcode index to 15658
  Match failed at index 15663
  Continuing at 16336
  Skipped scope entry (due to false predicate) at index 16341, continuing at 16376
  Skipped scope entry (due to false predicate) at index 16377, continuing at 16412
  Skipped scope entry (due to false predicate) at index 16413, continuing at 16448
  Match failed at index 16453
  Continuing at 16482
  Continuing at 16483
  Match failed at index 16486
  Continuing at 16589
  Skipped scope entry (due to false predicate) at index 16593, continuing at 16651
  Skipped scope entry (due to false predicate) at index 16652, continuing at 16710
  Match failed at index 16591
  Continuing at 16711
  Match failed at index 16715
  Continuing at 16903
  Skipped scope entry (due to false predicate) at index 16908, continuing at 16965
  Skipped scope entry (due to false predicate) at index 16966, continuing at 17043
  Skipped scope entry (due to false predicate) at index 17044, continuing at 17121
  Match failed at index 17128
  Continuing at 17140
  Morphed node: 0x2fe6050: i32 = CMP64ri8 0x2fe97d0, 0x2fe96d0

ISEL: Match complete!
=> 0x2fe6050: i32 = CMP64ri8 0x2fe97d0, 0x2fe96d0

Selecting: 0x2fe97d0: i64 = add 0x3004020, 0x3004520 [ORD=22] [ID=8]

ISEL: Starting pattern match on root node: 0x2fe97d0: i64 = add 0x3004020, 0x3004520 [ORD=22] [ID=8]

  Initial Opcode index to 67013
  Match failed at index 67018
  Continuing at 67125
  Match failed at index 67129
  Continuing at 67324
  Match failed at index 67328
  Continuing at 67409
  TypeSwitch[i64] from 67411 to 67454
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg 0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x3004220 [ID=7]
 Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Match failed at index 67454
  Continuing at 67470
  Match failed at index 67474
  Continuing at 67596
  Match failed at index 67600
  Continuing at 67728
  Skipped scope entry (due to false predicate) at index 67738, continuing at 67821
  Skipped scope entry (due to false predicate) at index 67822, continuing at 67914
  Skipped scope entry (due to false predicate) at index 67915, continuing at 67997
  Skipped scope entry (due to false predicate) at index 67998, continuing at 68029
  Match failed at index 67736
  Continuing at 68030
  Match failed at index 68045
  Continuing at 68059
  Match failed at index 68063
  Continuing at 68077
  Morphed node: 0x2fe97d0: i64,i32 = ADD64ri8 0x3004020, 0x2fe95d0 [ORD=22]

ISEL: Match complete!
=> 0x2fe97d0: i64,i32 = ADD64ri8 0x3004020, 0x2fe95d0 [ORD=22]

Selecting: 0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x3004220 [ORD=22] [ID=7]

=> 0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x3004220 [ORD=22]

Selecting: 0x2fe6550: i64 = Register %RAX [ID=5]

=> 0x2fe6550: i64 = Register %RAX

Selecting: 0x3004220: i64 = Register %vreg0 [ORD=22] [ID=1]

=> 0x3004220: i64 = Register %vreg0 [ORD=22]

Selecting: 0x2fbf468: ch = EntryToken [ORD=22] [ID=0]

=> 0x2fbf468: ch = EntryToken [ORD=22]

===== Instruction selection ends:
Selected selection DAG: BB#0 'isdigit:entry'
SelectionDAG has 12 nodes:
  0x2fbf468: ch = EntryToken [ORD=22]

    0x2fbf468: <multiple use>
    0x2fe6550: i64 = Register %RAX

          0x2fbf468: <multiple use>
          0x3004220: i64 = Register %vreg0 [ORD=22]

        0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x3004220 [ORD=22]

        0x2fe95d0: i64 = TargetConstant<-48>

      0x2fe97d0: i64,i32 = ADD64ri8 0x3004020, 0x2fe95d0 [ORD=22]

      0x2fe96d0: i64 = TargetConstant<10>

    0x2fe6050: i32 = CMP64ri8 0x2fe97d0, 0x2fe96d0

  0x3004320: ch,glue = CopyToReg 0x2fbf468, 0x2fe6550, 0x2fe6050

  0x3004420: i32 = Register %noreg

  0x2fe9bd0: i64 = Register %noreg

    0x3004320: <multiple use>
    0x3004320: <multiple use>
  0x2fe9ad0: ch = RET 0x3004320, 0x3004320:1


********** List Scheduling BB#0 'entry' **********
SU(0): 0x2fe9ad0: ch = RET 0x3004320, 0x3004320:1 [ID=0]

    0x3004320: ch,glue = CopyToReg 0x2fbf468, 0x2fe6550, 0x2fe6050 [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(1): Latency=1

SU(1): 0x2fe6050: i32 = CMP64ri8 0x2fe97d0, 0x2fe96d0 [ID=1]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(2): Latency=1
  Successors:
   val SU(0): Latency=1

SU(2): 0x2fe97d0: i64,i32 = ADD64ri8 0x3004020, 0x2fe95d0 [ORD=22] [ID=2]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(3): Latency=1
  Successors:
   val SU(1): Latency=1

SU(3): 0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x3004220 [ORD=22] [ID=3]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
   val SU(2): Latency=1


Examining Available:
Height 0: SU(0): 0x2fe9ad0: ch = RET 0x3004320, 0x3004320:1 [ID=0]

    0x3004320: ch,glue = CopyToReg 0x2fbf468, 0x2fe6550, 0x2fe6050 [ID=0]


*** Scheduling [0]: SU(0): 0x2fe9ad0: ch = RET 0x3004320, 0x3004320:1 [ID=0]

    0x3004320: ch,glue = CopyToReg 0x2fbf468, 0x2fe6550, 0x2fe6050 [ID=0]


Examining Available:
Height 1: SU(1): 0x2fe6050: i32 = CMP64ri8 0x2fe97d0, 0x2fe96d0 [ID=1]


*** Scheduling [1]: SU(1): 0x2fe6050: i32 = CMP64ri8 0x2fe97d0, 0x2fe96d0 [ID=1]

GR64: 1 / 12

Examining Available:
Height 2: SU(2): 0x2fe97d0: i64,i32 = ADD64ri8 0x3004020, 0x2fe95d0 [ORD=22] [ID=2]


*** Scheduling [2]: SU(2): 0x2fe97d0: i64,i32 = ADD64ri8 0x3004020, 0x2fe95d0 [ORD=22] [ID=2]

GR64: 1 / 12

Examining Available:
Height 3: SU(3): 0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x3004220 [ORD=22] [ID=3]


*** Scheduling [3]: SU(3): 0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x3004220 [ORD=22] [ID=3]

*** Final schedule ***
SU(3): 0x3004020: i64,ch = CopyFromReg 0x2fbf468, 0x3004220 [ORD=22] [ID=3]

SU(2): 0x2fe97d0: i64,i32 = ADD64ri8 0x3004020, 0x2fe95d0 [ORD=22] [ID=2]

SU(1): 0x2fe6050: i32 = CMP64ri8 0x2fe97d0, 0x2fe96d0 [ID=1]

SU(0): 0x2fe9ad0: ch = RET 0x3004320, 0x3004320:1 [ID=0]

    0x3004320: ch,glue = CopyToReg 0x2fbf468, 0x2fe6550, 0x2fe6050 [ID=0]


Total amount of phi nodes to update: 0
# Machine code for function isdigit: SSA
Function Live Ins: %RDI in %vreg0
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg0<def> = COPY %RDI; GR64:%vreg0
32B		%vreg1<def,tied1> = ADD64ri8 %vreg0<tied0>, -48, %EFLAGS<imp-def,dead>; GR64:%vreg1,%vreg0
48B		CMP64ri8 %vreg1<kill>, 10, %EFLAGS<imp-def>; GR64:%vreg1
64B		%vreg2<def> = COPY %EFLAGS; GR64:%vreg2
80B		%RAX<def> = COPY %vreg2; GR64:%vreg2
96B		RET

# End machine code for function isdigit.

********** Stack Coloring **********
********** Function: isdigit
******** Pre-regalloc Machine LICM: isdigit ********
Entering: entry
Exiting: entry
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: isdigit
********** PROCESS IMPLICIT DEFS **********
********** Function: isdigit
********** REWRITING TWO-ADDR INSTRS **********
********** Function: isdigit
	%vreg1<def,tied1> = ADD64ri8 %vreg0<kill,tied0>, -48, %EFLAGS<imp-def,dead>; GR64:%vreg1,%vreg0
		prepend:	%vreg1<def> = COPY %vreg0; GR64:%vreg1,%vreg0
		rewrite to:	%vreg1<def,tied1> = ADD64ri8 %vreg1<tied0>, -48, %EFLAGS<imp-def,dead>; GR64:%vreg1
# Machine code for function isdigit: Post SSA
Function Live Ins: %RDI in %vreg0
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg0<def> = COPY %RDI<kill>; GR64:%vreg0
32B		%vreg1<def> = COPY %vreg0<kill>; GR64:%vreg1,%vreg0
48B		%vreg1<def,tied1> = ADD64ri8 %vreg1<tied0>, -48, %EFLAGS<imp-def,dead>; GR64:%vreg1
64B		CMP64ri8 %vreg1<kill>, 10, %EFLAGS<imp-def>; GR64:%vreg1
80B		%vreg2<def> = COPY %EFLAGS<kill>; GR64:%vreg2
96B		%RAX<def> = COPY %vreg2<kill>; GR64:%vreg2
112B		RET %RAX<imp-use,kill>

# End machine code for function isdigit.

********** COMPUTING LIVE INTERVALS **********
********** Function: isdigit
BB#0:		# derived from entry
16B	%vreg0<def> = COPY %RDI<kill>; GR64:%vreg0
		register: %vreg0 +[16r,32r:0)
32B	%vreg1<def> = COPY %vreg0<kill>; GR64:%vreg1,%vreg0
		register: %vreg1 +[32r,64r:0)
48B	%vreg1<def,tied1> = ADD64ri8 %vreg1<tied0>, -48, %EFLAGS<imp-def,dead>; GR64:%vreg1
		register: %vreg1 replace range with [32r,48r:1) RESULT: [32r,48r:1)[48r,64r:0)  0@48r 1@32r
64B	CMP64ri8 %vreg1<kill>, 10, %EFLAGS<imp-def>; GR64:%vreg1
80B	%vreg2<def> = COPY %EFLAGS<kill>; GR64:%vreg2
		register: %vreg2 +[80r,96r:0)
96B	%RAX<def> = COPY %vreg2<kill>; GR64:%vreg2
112B	RET %RAX<imp-use,kill>
Computing live-in reg-units in ABI blocks.
0B	BB#0 DIL#0
Created 1 new intervals.
********** INTERVALS **********
DIL = [0B,16r:0)  0@0B-phi
%vreg0 = [16r,32r:0)  0@16r
%vreg1 = [32r,48r:1)[48r,64r:0)  0@48r 1@32r
%vreg2 = [80r,96r:0)  0@80r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function isdigit: Post SSA
Function Live Ins: %RDI in %vreg0
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg0<def> = COPY %RDI; GR64:%vreg0
32B		%vreg1<def> = COPY %vreg0<kill>; GR64:%vreg1,%vreg0
48B		%vreg1<def,tied1> = ADD64ri8 %vreg1<tied0>, -48, %EFLAGS<imp-def,dead>; GR64:%vreg1
64B		CMP64ri8 %vreg1<kill>, 10, %EFLAGS<imp-def>; GR64:%vreg1
80B		%vreg2<def> = COPY %EFLAGS<kill>; GR64:%vreg2
96B		%RAX<def> = COPY %vreg2<kill>; GR64:%vreg2
112B		RET %RAX<imp-use,kill>

# End machine code for function isdigit.

********** COMPUTING LIVE DEBUG VARIABLES: isdigit **********
********** DEBUG VARIABLES **********
********** SIMPLE REGISTER COALESCING **********
********** Function: isdigit
********** JOINING INTERVALS ***********
entry:
16B	%vreg0<def> = COPY %RDI; GR64:%vreg0
	Considering merging %vreg0 with %RDI
	Can only merge into reserved registers.
32B	%vreg1<def> = COPY %vreg0<kill>; GR64:%vreg1,%vreg0
	Considering merging to GR64 with %vreg0 in %vreg1
		RHS = %vreg0 [16r,32r:0)  0@16r
		LHS = %vreg1 [32r,48r:1)[48r,64r:0)  0@48r 1@32r
		merge %vreg1:1@32r into %vreg0:0@16r --> @16r
		erased:	32r	%vreg1<def> = COPY %vreg0<kill>; GR64:%vreg1,%vreg0
		updated: 16B	%vreg1<def> = COPY %RDI; GR64:%vreg1
	Joined. Result = %vreg1[16r,48r:1)[48r,64r:0)  0@48r 1@16r
80B	%vreg2<def> = COPY %EFLAGS<kill>; GR64:%vreg2
	Not coalescable.
96B	%RAX<def> = COPY %vreg2<kill>; GR64:%vreg2
	Considering merging %vreg2 with %RAX
	Can only merge into reserved registers.
Trying to inflate 0 regs.
********** INTERVALS **********
DIL = [0B,16r:0)  0@0B-phi
%vreg1 = [16r,48r:1)[48r,64r:0)  0@48r 1@16r
%vreg2 = [80r,96r:0)  0@80r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function isdigit: Post SSA
Function Live Ins: %RDI in %vreg0
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg1<def> = COPY %RDI; GR64:%vreg1
48B		%vreg1<def,tied1> = ADD64ri8 %vreg1<tied0>, -48, %EFLAGS<imp-def,dead>; GR64:%vreg1
64B		CMP64ri8 %vreg1, 10, %EFLAGS<imp-def>; GR64:%vreg1
80B		%vreg2<def> = COPY %EFLAGS<kill>; GR64:%vreg2
96B		%RAX<def> = COPY %vreg2<kill>; GR64:%vreg2
112B		RET %RAX<imp-use,kill>

# End machine code for function isdigit.

********** DEBUG VARIABLES **********
********** Compute Spill Weights **********
********** Function: isdigit
********** GREEDY REGISTER ALLOCATION **********
********** Function: isdigit

selectOrSplit GR64:%vreg1 [16r,48r:1)[48r,64r:0)  0@48r 1@16r
hints: %RDI
assigning %vreg1 to %RDI: DIL

selectOrSplit GR64:%vreg2 [80r,96r:0)  0@80r
hints: %RAX
assigning %vreg2 to %RAX: AH AL
********** REWRITE VIRTUAL REGISTERS **********
********** Function: isdigit
********** REGISTER MAP **********
[%vreg1 -> %RDI] GR64
[%vreg2 -> %RAX] GR64

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg1<def> = COPY %RDI; GR64:%vreg1
48B		%vreg1<def,tied1> = ADD64ri8 %vreg1<kill,tied0>, -48, %EFLAGS<imp-def,dead>; GR64:%vreg1
64B		CMP64ri8 %vreg1<kill>, 10, %EFLAGS<imp-def>; GR64:%vreg1
80B		%vreg2<def> = COPY %EFLAGS<kill>; GR64:%vreg2
96B		%RAX<def> = COPY %vreg2<kill>; GR64:%vreg2
112B		RET %RAX<imp-use>
> %RDI<def> = COPY %RDI
Deleting identity copy.
> %RDI<def,tied1> = ADD64ri8 %RDI<kill,tied0>, -48, %EFLAGS<imp-def,dead>
> CMP64ri8 %RDI<kill>, 10, %EFLAGS<imp-def>
> %RAX<def> = COPY %EFLAGS<kill>
> %RAX<def> = COPY %RAX<kill>
Deleting identity copy.
> RET %RAX<imp-use>
********** EMITTING LIVE DEBUG VARIABLES **********
********** Stack Slot Coloring **********
********** Function: isdigit
******** Post-regalloc Machine LICM: isdigit ********
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: isdigit
real copy:   %RAX<def> = COPY %EFLAGS<kill>
replaced by: %RAX<def> = POP64r %RSP<imp-def>, %RSP<imp-use>
RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0
Frequency(BB#0 derived from LLVM BB entry) = 1024
********** FIX EXECUTION DEPENDENCIES: VR128 **********
The instruction being printed 93 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 530 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 2133 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 2001 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 2234 1501 1647 1642 1506 1648 1643 1645 1640FOUND USER:   %0 = load i8* %s.addr.0, align 1, !tbaa !0
   OF SCEV: {%s,+,1}<nw><%while.cond>

LSR on loop %while.cond:
Collecting IV Chains.
IV Chain#0 Head: (  %0 = load i8* %s.addr.0, align 1, !tbaa !0) IV={%s,+,1}<nw><%while.cond>
IV Chain#0  Inc: (  %s.addr.0 = phi i8* [ %s, %entry ], [ %incdec.ptr, %while.body ]) IV+1
Chain:   %0 = load i8* %s.addr.0, align 1, !tbaa !0 Cost: 0
LSR is examining the following fixup sites:
  UserInst=%0, OperandValToReplace=%s.addr.0, LUIdx=0
LSR found 1 uses:
LSR is examining the following uses:
  LSR Use: Kind=Address of i8, Offsets={0}, widest fixup type: i8*
    reg({%s,+,1}<nw><%while.cond>)

After generating reuse formulae:
LSR is examining the following uses:
  LSR Use: Kind=Address of i8, Offsets={0}, widest fixup type: i8*
    reg({%s,+,1}<nw><%while.cond>)
    reg({0,+,1}<%while.cond>) + reg(%s)
Filtering for use LSR Use: Kind=Address of i8, Offsets={0}, widest fixup type: i8*
  Filtering out formula reg({0,+,1}<%while.cond>) + reg(%s)
    in favor of formula reg({%s,+,1}<nw><%while.cond>)

After filtering out undesirable candidates:
LSR is examining the following uses:
  LSR Use: Kind=Address of i8, Offsets={0}, widest fixup type: i8*
    reg({%s,+,1}<nw><%while.cond>)
New best at 1 reg, with addrec cost 1.
 Regs: {%s,+,1}<nw><%while.cond>

The chosen solution requires 1 reg, with addrec cost 1:
  LSR Use: Kind=Address of i8, Offsets={0}, widest fixup type: i8*
    reg({%s,+,1}<nw><%while.cond>)
Computing probabilities for while.body
set edge while.body -> 0 successor weight to 124
Computing probabilities for while.end
Computing probabilities for lor.rhs.i
set edge lor.rhs.i -> 0 successor weight to 124
set edge lor.rhs.i -> 1 successor weight to 4
Computing probabilities for while.cond
set edge while.cond -> 0 successor weight to 62
set edge while.cond -> 1 successor weight to 62
Computing probabilities for entry



=== atol
5
is64bit 1
Initial selection DAG: BB#0 'atol:entry'
SelectionDAG has 3 nodes:
    0x2fbf468: ch = EntryToken

    0x2fe95d0: i64 = Register %vreg3

  0x2fe9bd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe95d0

  0x2fbf468: ch = EntryToken


Optimized lowered selection DAG: BB#0 'atol:entry'
SelectionDAG has 1 nodes:
  0x2fbf468: ch = EntryToken


Legally typed node: 0x2fbf468: ch = EntryToken [ID=0]

Legally typed node: 0x7fff8d52a470: ch = handlenode 0x2fbf468 [ID=0]

Type-legalized selection DAG: BB#0 'atol:entry'
SelectionDAG has 1 nodes:
  0x2fbf468: ch = EntryToken [ID=-3]


In LegalizeDAG() 1
In legalize Op1
0
Legalized selection DAG: BB#0 'atol:entry'
SelectionDAG has 1 nodes:
  0x2fbf468: ch = EntryToken [ID=0]


Optimized legalized selection DAG: BB#0 'atol:entry'
SelectionDAG has 1 nodes:
  0x2fbf468: ch = EntryToken [ID=0]


===== Instruction selection begins: BB#0 'entry'
Selecting: 0x2fbf468: ch = EntryToken [ID=0]

=> 0x2fbf468: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#0 'atol:entry'
SelectionDAG has 1 nodes:
  0x2fbf468: ch = EntryToken


********** List Scheduling BB#0 'entry' **********
*** Final schedule ***

Total amount of phi nodes to update: 1
Node 0 : (0x300f0e0, 2147483651)
Inside ICMP! setcc maybe  
Initial selection DAG: BB#1 'atol:while.cond'
SelectionDAG has 16 nodes:
  0x2fbf468: ch = EntryToken [ORD=25]

  0x3004420: i64 = Constant<0>

    0x2fbf468: <multiple use>
      0x2fbf468: <multiple use>
      0x2fe95d0: i64 = Register %vreg0 [ORD=25]

    0x2fe9bd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe95d0 [ORD=25]

    0x2fe96d0: i64 = undef [ORD=25]

  0x2fe9ad0: i8,ch = load 0x2fbf468, 0x2fe9bd0, 0x2fe96d0<LD1[%s.addr.0](tbaa=!"omnipotent char")> [ORD=25]

        0x2fbf468: <multiple use>
        0x2fe6050: i64 = Register %vreg1

          0x2fe9ad0: <multiple use>
        0x3004320: i64 = zero_extend 0x2fe9ad0

      0x2fe97d0: ch = CopyToReg 0x2fbf468, 0x2fe6050, 0x3004320

        0x2fe9ad0: <multiple use>
        0x3004020: i8 = Constant<32> [ORD=26]

        0x2fe6550: ch = seteq [ORD=26]

      0x3004220: i1 = setcc 0x2fe9ad0, 0x3004020, 0x2fe6550 [ORD=26]

      0x3004520: ch = BasicBlock<while.body 0x300f1f0>

    0x2fe93d0: ch = brcond 0x2fe97d0, 0x3004220, 0x3004520

    0x3004120: ch = BasicBlock<lor.rhs.i 0x300f148>

  0x2fe8dd0: ch = br 0x2fe93d0, 0x3004120



Replacing.1 0x3004320: i64 = zero_extend 0x2fe9ad0

With: 0x2fe6250: i64,ch = load 0x2fbf468, 0x2fe9bd0, 0x2fe96d0<LD1[%s.addr.0], zext from i8>
 and 0 other values

Replacing.1 0x2fe9ad0: i8,ch = load 0x2fbf468, 0x2fe9bd0, 0x2fe96d0<LD1[%s.addr.0](tbaa=!"omnipotent char")> [ORD=25]

With: 0x3004320: i8 = truncate 0x2fe6250
 and 1 other values

Replacing.1 0x3004220: i1 = setcc 0x3004320, 0x3004020, 0x2fe6550 [ORD=26]

With: 0x2fe6350: i1 = setcc 0x2fe6250, 0x2fe9ad0, 0x2fe6550
 and 0 other values
Optimized lowered selection DAG: BB#1 'atol:while.cond'
SelectionDAG has 14 nodes:
  0x2fbf468: ch = EntryToken [ORD=25]

    0x2fbf468: <multiple use>
      0x2fbf468: <multiple use>
      0x2fe95d0: i64 = Register %vreg0 [ORD=25]

    0x2fe9bd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe95d0 [ORD=25]

    0x2fe96d0: i64 = undef [ORD=25]

  0x2fe6250: i64,ch = load 0x2fbf468, 0x2fe9bd0, 0x2fe96d0<LD1[%s.addr.0], zext from i8>

        0x2fbf468: <multiple use>
        0x2fe6050: i64 = Register %vreg1

        0x2fe6250: <multiple use>
      0x2fe97d0: ch = CopyToReg 0x2fbf468, 0x2fe6050, 0x2fe6250

        0x2fe6250: <multiple use>
        0x2fe9ad0: i64 = Constant<32>

        0x2fe6550: ch = seteq [ORD=26]

      0x2fe6350: i1 = setcc 0x2fe6250, 0x2fe9ad0, 0x2fe6550

      0x3004520: ch = BasicBlock<while.body 0x300f1f0>

    0x2fe93d0: ch = brcond 0x2fe97d0, 0x2fe6350, 0x3004520

    0x3004120: ch = BasicBlock<lor.rhs.i 0x300f148>

  0x2fe8dd0: ch = br 0x2fe93d0, 0x3004120


Legally typed node: 0x2fe9ad0: i64 = Constant<32> [ID=0]

Legally typed node: 0x3004120: ch = BasicBlock<lor.rhs.i 0x300f148> [ID=0]

Legally typed node: 0x3004520: ch = BasicBlock<while.body 0x300f1f0> [ID=0]

Legally typed node: 0x2fe6550: ch = seteq [ORD=26] [ID=0]

Legally typed node: 0x2fe6050: i64 = Register %vreg1 [ID=0]

Legally typed node: 0x2fe96d0: i64 = undef [ORD=25] [ID=0]

Legally typed node: 0x2fe95d0: i64 = Register %vreg0 [ORD=25] [ID=0]

Legally typed node: 0x2fbf468: ch = EntryToken [ORD=25] [ID=0]

Legally typed node: 0x2fe9bd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe95d0 [ORD=25] [ID=0]

Legally typed node: 0x2fe6250: i64,ch = load 0x2fbf468, 0x2fe9bd0, 0x2fe96d0<LD1[%s.addr.0], zext from i8> [ID=0]

Legally typed node: 0x2fe97d0: ch = CopyToReg 0x2fbf468, 0x2fe6050, 0x2fe6250 [ID=0]

Promote integer result: 0x2fe6350: i1 = setcc 0x2fe6250, 0x2fe9ad0, 0x2fe6550 [ID=0]

Set Promoted Integer! Opcode0x3004020: i64 = setcc 0x2fe6250, 0x2fe9ad0, 0x2fe6550 [ID=0]
5
Promote integer operand: 0x2fe93d0: ch = brcond 0x2fe97d0, 0x2fe6350, 0x3004520 [ID=0]
149 1 105 1
Res.getNode(), N0x2fe93d0 0x2fe93d0: Promote integer operand: 0x3004420: i64 = zero_extend 0x2fe6350 [ID=0]
110 0 105 1
0x2fe6350: i1 = setcc 0x2fe6250, 0x2fe9ad0, 0x2fe6550 [ID=-3]
 1
105 5
105 5
In PIO_ZERO_EXTEND105 5
Res.getNode(), N0x3004220 0x3004420: Legally typed node: 0x3004320: i64 = Constant<1> [ID=0]

Legally typed node: 0x3004020: i64 = setcc 0x2fe6250, 0x2fe9ad0, 0x2fe6550 [ID=0]

Legally typed node: 0x3004220: i64 = and 0x3004020, 0x3004320 [ID=0]

Legally typed node: 0x2fe93d0: ch = brcond 0x2fe97d0, 0x3004220, 0x3004520 [ID=0]

Legally typed node: 0x2fe8dd0: ch = br 0x2fe93d0, 0x3004120 [ID=0]

Legally typed node: 0x7fff8d52a470: ch = handlenode 0x2fe8dd0 [ID=0]

Type-legalized selection DAG: BB#1 'atol:while.cond'
SelectionDAG has 16 nodes:
  0x2fbf468: ch = EntryToken [ORD=25] [ID=-3]

    0x2fbf468: <multiple use>
      0x2fbf468: <multiple use>
      0x2fe95d0: i64 = Register %vreg0 [ORD=25] [ID=-3]

    0x2fe9bd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe95d0 [ORD=25] [ID=-3]

    0x2fe96d0: i64 = undef [ORD=25] [ID=-3]

  0x2fe6250: i64,ch = load 0x2fbf468, 0x2fe9bd0, 0x2fe96d0<LD1[%s.addr.0], zext from i8> [ID=-3]

        0x2fbf468: <multiple use>
        0x2fe6050: i64 = Register %vreg1 [ID=-3]

        0x2fe6250: <multiple use>
      0x2fe97d0: ch = CopyToReg 0x2fbf468, 0x2fe6050, 0x2fe6250 [ID=-3]

          0x2fe6250: <multiple use>
          0x2fe9ad0: i64 = Constant<32> [ID=-3]

          0x2fe6550: ch = seteq [ORD=26] [ID=-3]

        0x3004020: i64 = setcc 0x2fe6250, 0x2fe9ad0, 0x2fe6550 [ID=-3]

        0x3004320: i64 = Constant<1> [ID=-3]

      0x3004220: i64 = and 0x3004020, 0x3004320 [ID=-3]

      0x3004520: ch = BasicBlock<while.body 0x300f1f0> [ID=-3]

    0x2fe93d0: ch = brcond 0x2fe97d0, 0x3004220, 0x3004520 [ID=-3]

    0x3004120: ch = BasicBlock<lor.rhs.i 0x300f148> [ID=-3]

  0x2fe8dd0: ch = br 0x2fe93d0, 0x3004120 [ID=-3]



Replacing.2 0x3004220: i64 = and 0x3004020, 0x3004320 [ID=-3]

With: 0x3004020: i64 = setcc 0x2fe6250, 0x2fe9ad0, 0x2fe6550 [ID=-3]

Optimized type-legalized selection DAG: BB#1 'atol:while.cond'
SelectionDAG has 14 nodes:
  0x2fbf468: ch = EntryToken [ORD=25] [ID=-3]

    0x2fbf468: <multiple use>
      0x2fbf468: <multiple use>
      0x2fe95d0: i64 = Register %vreg0 [ORD=25] [ID=-3]

    0x2fe9bd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe95d0 [ORD=25] [ID=-3]

    0x2fe96d0: i64 = undef [ORD=25] [ID=-3]

  0x2fe6250: i64,ch = load 0x2fbf468, 0x2fe9bd0, 0x2fe96d0<LD1[%s.addr.0], zext from i8> [ID=-3]

        0x2fbf468: <multiple use>
        0x2fe6050: i64 = Register %vreg1 [ID=-3]

        0x2fe6250: <multiple use>
      0x2fe97d0: ch = CopyToReg 0x2fbf468, 0x2fe6050, 0x2fe6250 [ID=-3]

        0x2fe6250: <multiple use>
        0x2fe9ad0: i64 = Constant<32> [ID=-3]

        0x2fe6550: ch = seteq [ORD=26] [ID=-3]

      0x3004020: i64 = setcc 0x2fe6250, 0x2fe9ad0, 0x2fe6550 [ID=-3]

      0x3004520: ch = BasicBlock<while.body 0x300f1f0> [ID=-3]

    0x2fe93d0: ch = brcond 0x2fe97d0, 0x3004020, 0x3004520 [ID=-3]

    0x3004120: ch = BasicBlock<lor.rhs.i 0x300f148> [ID=-3]

  0x2fe8dd0: ch = br 0x2fe93d0, 0x3004120 [ID=-3]


In LegalizeDAG() 146
In legalize Op146
0
0
0
In LegalizeDAG() 149
In legalize Op149
0
0
5
0
105 105 210
Lowering SETCC to CMP. Here are the operands' types 143 5 10 5
In LegalizeDAG() 42
In legalize Op42
0
0
5
5
In LegalizeDAG() 143
In legalize Op143
5
0
0
5
5
In LegalizeDAG() 43
In legalize Op43
5
0
0
5
In LegalizeDAG() 10
In legalize Op10
5
In LegalizeDAG() 5
In legalize Op5
0
In LegalizeDAG() 5
In legalize Op5
0
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 44
In legalize Op44
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 1
In legalize Op1
0
In LegalizeDAG() 210
In legalize Op210
0
0
0
5
5
In LegalizeDAG() 200
In legalize Op200
5
5
5
5
In LegalizeDAG() 10
In legalize Op10
5
Legalized selection DAG: BB#1 'atol:while.cond'
SelectionDAG has 14 nodes:
  0x2fbf468: ch = EntryToken [ORD=25] [ID=0]

    0x2fbf468: <multiple use>
      0x2fbf468: <multiple use>
      0x2fe95d0: i64 = Register %vreg0 [ORD=25] [ID=1]

    0x2fe9bd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe95d0 [ORD=25] [ID=8]

    0x2fe96d0: i64 = undef [ORD=25] [ID=2]

  0x2fe6250: i64,ch = load 0x2fbf468, 0x2fe9bd0, 0x2fe96d0<LD1[%s.addr.0], zext from i8> [ID=9]

  0x3004320: i64 = Constant<4>

        0x2fbf468: <multiple use>
        0x2fe6050: i64 = Register %vreg1 [ID=3]

        0x2fe6250: <multiple use>
      0x2fe97d0: ch = CopyToReg 0x2fbf468, 0x2fe6050, 0x2fe6250 [ID=11]

      0x3004520: ch = BasicBlock<while.body 0x300f1f0> [ID=5]

      0x3004320: <multiple use>
        0x2fe6250: <multiple use>
        0x2fe9ad0: i64 = Constant<32> [ID=7]

        0x3004320: <multiple use>
      0x3004220: i64 = X86ISD::CMP 0x2fe6250, 0x2fe9ad0, 0x3004320

    0x2fe6350: ch = X86ISD::BRCOND 0x2fe97d0, 0x3004520, 0x3004320, 0x3004220

    0x3004120: ch = BasicBlock<lor.rhs.i 0x300f148> [ID=6]

  0x2fe8dd0: ch = br 0x2fe6350, 0x3004120 [ID=13]


Optimized legalized selection DAG: BB#1 'atol:while.cond'
SelectionDAG has 14 nodes:
  0x2fbf468: ch = EntryToken [ORD=25] [ID=0]

    0x2fbf468: <multiple use>
      0x2fbf468: <multiple use>
      0x2fe95d0: i64 = Register %vreg0 [ORD=25] [ID=1]

    0x2fe9bd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe95d0 [ORD=25] [ID=8]

    0x2fe96d0: i64 = undef [ORD=25] [ID=2]

  0x2fe6250: i64,ch = load 0x2fbf468, 0x2fe9bd0, 0x2fe96d0<LD1[%s.addr.0], zext from i8> [ID=9]

  0x3004320: i64 = Constant<4>

        0x2fbf468: <multiple use>
        0x2fe6050: i64 = Register %vreg1 [ID=3]

        0x2fe6250: <multiple use>
      0x2fe97d0: ch = CopyToReg 0x2fbf468, 0x2fe6050, 0x2fe6250 [ID=11]

      0x3004520: ch = BasicBlock<while.body 0x300f1f0> [ID=5]

      0x3004320: <multiple use>
        0x2fe6250: <multiple use>
        0x2fe9ad0: i64 = Constant<32> [ID=7]

        0x3004320: <multiple use>
      0x3004220: i64 = X86ISD::CMP 0x2fe6250, 0x2fe9ad0, 0x3004320

    0x2fe6350: ch = X86ISD::BRCOND 0x2fe97d0, 0x3004520, 0x3004320, 0x3004220

    0x3004120: ch = BasicBlock<lor.rhs.i 0x300f148> [ID=6]

  0x2fe8dd0: ch = br 0x2fe6350, 0x3004120 [ID=13]


===== Instruction selection begins: BB#1 'while.cond'
Selecting: 0x2fe8dd0: ch = br 0x2fe6350, 0x3004120 [ID=13]

ISEL: Starting pattern match on root node: 0x2fe8dd0: ch = br 0x2fe6350, 0x3004120 [ID=13]

  Initial Opcode index to 120382
  Skipped scope entry (due to false predicate) at index 120392, continuing at 120402
  Morphed node: 0x2fe8dd0: ch = JMP64pcrel32 0x3004120, 0x2fe6350

ISEL: Match complete!
=> 0x2fe8dd0: ch = JMP64pcrel32 0x3004120, 0x2fe6350

Selecting: 0x2fe6350: ch = X86ISD::BRCOND 0x2fe97d0, 0x3004520, 0x3004320, 0x3004220 [ID=12]

ISEL: Starting pattern match on root node: 0x2fe6350: ch = X86ISD::BRCOND 0x2fe97d0, 0x3004520, 0x3004320, 0x3004220 [ID=12]

  Initial Opcode index to 81395
  Skipped scope entry (due to false predicate) at index 81407, continuing at 81439
  Skipped scope entry (due to false predicate) at index 81440, continuing at 81472
  Skipped scope entry (due to false predicate) at index 81473, continuing at 81505
  Skipped scope entry (due to false predicate) at index 81506, continuing at 81538
  Skipped scope entry (due to false predicate) at index 81545, continuing at 81558
  Morphed node: 0x2fe6350: ch = JE_64 0x3004520, 0x3004020, 0x3004020:1

ISEL: Match complete!
=> 0x2fe6350: ch = JE_64 0x3004520, 0x3004020, 0x3004020:1

Selecting: 0x2fe97d0: ch = CopyToReg 0x2fbf468, 0x2fe6050, 0x2fe6250 [ID=11]

=> 0x2fe97d0: ch = CopyToReg 0x2fbf468, 0x2fe6050, 0x2fe6250

Selecting: 0x3004220: i64 = X86ISD::CMP 0x2fe6250, 0x2fe9ad0, 0x3004320 [ID=10]

ISEL: Starting pattern match on root node: 0x3004220: i64 = X86ISD::CMP 0x2fe6250, 0x2fe9ad0, 0x3004320 [ID=10]

  Initial Opcode index to 15658
  OpcodeSwitch from 15663 to 16119
  Match failed at index 16121
  Continuing at 16336
  Skipped scope entry (due to false predicate) at index 16341, continuing at 16376
  Skipped scope entry (due to false predicate) at index 16377, continuing at 16412
  Skipped scope entry (due to false predicate) at index 16413, continuing at 16448
  Match failed at index 16453
  Continuing at 16482
  Continuing at 16483
  Match failed at index 16491
  Continuing at 16589
  Skipped scope entry (due to false predicate) at index 16593, continuing at 16651
  Skipped scope entry (due to false predicate) at index 16652, continuing at 16710
  Match failed at index 16591
  Continuing at 16711
  Match failed at index 16715
  Continuing at 16903
  Skipped scope entry (due to false predicate) at index 16908, continuing at 16965
  Skipped scope entry (due to false predicate) at index 16966, continuing at 17043
  Skipped scope entry (due to false predicate) at index 17044, continuing at 17121
  Match failed at index 17128
  Continuing at 17140
  Morphed node: 0x3004220: i32 = CMP64ri8 0x2fe6250, 0x2fe93d0

ISEL: Match complete!
=> 0x3004220: i32 = CMP64ri8 0x2fe6250, 0x2fe93d0

Selecting: 0x2fe6250: i64,ch = load 0x2fbf468, 0x2fe9bd0, 0x2fe96d0<LD1[%s.addr.0], zext from i8> [ID=9]

ISEL: Starting pattern match on root node: 0x2fe6250: i64,ch = load 0x2fbf468, 0x2fe9bd0, 0x2fe96d0<LD1[%s.addr.0], zext from i8> [ID=9]

  Initial Opcode index to 72777
  Skipped scope entry (due to false predicate) at index 72787, continuing at 72809
  Skipped scope entry (due to false predicate) at index 72810, continuing at 72832
  Skipped scope entry (due to false predicate) at index 72833, continuing at 72855
  Skipped scope entry (due to false predicate) at index 72856, continuing at 72876
  Skipped scope entry (due to false predicate) at index 72877, continuing at 72925
  Match failed at index 72928
  Continuing at 72974
  Match failed at index 72975
  Continuing at 73038
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Morphed node: 0x2fe6250: i64,ch = MOVZX64rm8 0x2fe9bd0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe92d0, 0x2fbf468<Mem:LD1[%s.addr.0]>

ISEL: Match complete!
=> 0x2fe6250: i64,ch = MOVZX64rm8 0x2fe9bd0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe92d0, 0x2fbf468<Mem:LD1[%s.addr.0]>

Selecting: 0x2fe9bd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe95d0 [ORD=25] [ID=8]

=> 0x2fe9bd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe95d0 [ORD=25]

Selecting: 0x3004120: ch = BasicBlock<lor.rhs.i 0x300f148> [ID=5]

=> 0x3004120: ch = BasicBlock<lor.rhs.i 0x300f148>

Selecting: 0x3004520: ch = BasicBlock<while.body 0x300f1f0> [ID=4]

=> 0x3004520: ch = BasicBlock<while.body 0x300f1f0>

Selecting: 0x2fe6050: i64 = Register %vreg1 [ID=3]

=> 0x2fe6050: i64 = Register %vreg1

Selecting: 0x2fe95d0: i64 = Register %vreg0 [ORD=25] [ID=1]

=> 0x2fe95d0: i64 = Register %vreg0 [ORD=25]

Selecting: 0x2fbf468: ch = EntryToken [ORD=25] [ID=0]

=> 0x2fbf468: ch = EntryToken [ORD=25]

===== Instruction selection ends:
Selected selection DAG: BB#1 'atol:while.cond'
SelectionDAG has 18 nodes:
  0x2fbf468: ch = EntryToken [ORD=25]

      0x2fbf468: <multiple use>
      0x2fe95d0: i64 = Register %vreg0 [ORD=25]

    0x2fe9bd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe95d0 [ORD=25]

    0x3004320: i8 = TargetConstant<1>

    0x2fe9ad0: i64 = Register %noreg

    0x3004420: i32 = TargetConstant<0>

    0x2fe92d0: i32 = Register %noreg

    0x2fbf468: <multiple use>
  0x2fe6250: i64,ch = MOVZX64rm8 0x2fe9bd0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe92d0, 0x2fbf468<Mem:LD1[%s.addr.0]>

      0x2fbf468: <multiple use>
      0x2fe6050: i64 = Register %vreg1

      0x2fe6250: <multiple use>
    0x2fe97d0: ch = CopyToReg 0x2fbf468, 0x2fe6050, 0x2fe6250

    0x2fe6550: i64 = Register %EFLAGS

      0x2fe6250: <multiple use>
      0x2fe93d0: i64 = TargetConstant<32>

    0x3004220: i32 = CMP64ri8 0x2fe6250, 0x2fe93d0

  0x3004020: ch,glue = CopyToReg 0x2fe97d0, 0x2fe6550, 0x3004220

    0x3004120: ch = BasicBlock<lor.rhs.i 0x300f148>

      0x3004520: ch = BasicBlock<while.body 0x300f1f0>

      0x3004020: <multiple use>
      0x3004020: <multiple use>
    0x2fe6350: ch = JE_64 0x3004520, 0x3004020, 0x3004020:1

  0x2fe8dd0: ch = JMP64pcrel32 0x3004120, 0x2fe6350


********** List Scheduling BB#1 'while.cond' **********
SU(0): 0x2fe8dd0: ch = JMP64pcrel32 0x3004120, 0x2fe6350 [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x2fe6350: ch = JE_64 0x3004520, 0x3004020, 0x3004020:1 [ID=1]

    0x3004020: ch,glue = CopyToReg 0x2fe97d0, 0x2fe6550, 0x3004220 [ID=1]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   ch  SU(5): Latency=1
   val SU(2): Latency=1 Reg=%EFLAGS
  Successors:
   ch  SU(0): Latency=1

SU(2): 0x3004220: i32 = CMP64ri8 0x2fe6250, 0x2fe93d0 [ID=2]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(3): Latency=1
  Successors:
   val SU(1): Latency=1

SU(3): 0x2fe6250: i64,ch = MOVZX64rm8 0x2fe9bd0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe92d0, 0x2fbf468<Mem:LD1[%s.addr.0]> [ID=3]

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(4): Latency=1
  Successors:
   val SU(2): Latency=1
   val SU(5): Latency=1

SU(4): 0x2fe9bd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe95d0 [ORD=25] [ID=4]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
   val SU(3): Latency=1

SU(5): 0x2fe97d0: ch = CopyToReg 0x2fbf468, 0x2fe6050, 0x2fe6250 [ID=5]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(3): Latency=1
  Successors:
   ch  SU(1): Latency=1


Examining Available:
Height 0: SU(0): 0x2fe8dd0: ch = JMP64pcrel32 0x3004120, 0x2fe6350 [ID=0]


*** Scheduling [0]: SU(0): 0x2fe8dd0: ch = JMP64pcrel32 0x3004120, 0x2fe6350 [ID=0]


Examining Available:
Height 1: SU(1): 0x2fe6350: ch = JE_64 0x3004520, 0x3004020, 0x3004020:1 [ID=1]

    0x3004020: ch,glue = CopyToReg 0x2fe97d0, 0x2fe6550, 0x3004220 [ID=1]


*** Scheduling [1]: SU(1): 0x2fe6350: ch = JE_64 0x3004520, 0x3004020, 0x3004020:1 [ID=1]

    0x3004020: ch,glue = CopyToReg 0x2fe97d0, 0x2fe6550, 0x3004220 [ID=1]


Examining Available:
  SU (5)  has no physreg SU(2)  defines a physreg
Height 2: SU(2): 0x3004220: i32 = CMP64ri8 0x2fe6250, 0x2fe93d0 [ID=2]

Height 2: SU(5): 0x2fe97d0: ch = CopyToReg 0x2fbf468, 0x2fe6050, 0x2fe6250 [ID=5]

  SU (5)  has no physreg SU(2)  defines a physreg

*** Scheduling [2]: SU(2): 0x3004220: i32 = CMP64ri8 0x2fe6250, 0x2fe93d0 [ID=2]

GR64: 1 / 12

Examining Available:
Height 2: SU(5): 0x2fe97d0: ch = CopyToReg 0x2fbf468, 0x2fe6050, 0x2fe6250 [ID=5]


*** Scheduling [3]: SU(5): 0x2fe97d0: ch = CopyToReg 0x2fbf468, 0x2fe6050, 0x2fe6250 [ID=5]

GR64: 1 / 12

Examining Available:
Height 4: SU(3): 0x2fe6250: i64,ch = MOVZX64rm8 0x2fe9bd0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe92d0, 0x2fbf468<Mem:LD1[%s.addr.0]> [ID=3]


*** Scheduling [4]: SU(3): 0x2fe6250: i64,ch = MOVZX64rm8 0x2fe9bd0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe92d0, 0x2fbf468<Mem:LD1[%s.addr.0]> [ID=3]

GR64: 1 / 12

Examining Available:
Height 5: SU(4): 0x2fe9bd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe95d0 [ORD=25] [ID=4]


*** Scheduling [5]: SU(4): 0x2fe9bd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe95d0 [ORD=25] [ID=4]

*** Final schedule ***
SU(4): 0x2fe9bd0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe95d0 [ORD=25] [ID=4]

SU(3): 0x2fe6250: i64,ch = MOVZX64rm8 0x2fe9bd0, 0x3004320, 0x2fe9ad0, 0x3004420, 0x2fe92d0, 0x2fbf468<Mem:LD1[%s.addr.0]> [ID=3]

SU(5): 0x2fe97d0: ch = CopyToReg 0x2fbf468, 0x2fe6050, 0x2fe6250 [ID=5]

SU(2): 0x3004220: i32 = CMP64ri8 0x2fe6250, 0x2fe93d0 [ID=2]

SU(1): 0x2fe6350: ch = JE_64 0x3004520, 0x3004020, 0x3004020:1 [ID=1]

    0x3004020: ch,glue = CopyToReg 0x2fe97d0, 0x2fe6550, 0x3004220 [ID=1]

SU(0): 0x2fe8dd0: ch = JMP64pcrel32 0x3004120, 0x2fe6350 [ID=0]


Total amount of phi nodes to update: 0
Inside ICMP! setcc maybe  
Initial selection DAG: BB#2 'atol:lor.rhs.i'
SelectionDAG has 18 nodes:
  0x2fbf468: ch = EntryToken [ORD=27]

      0x2fbf468: <multiple use>
                    0x2fbf468: <multiple use>
                    0x2fe92d0: i64 = Register %vreg1 [ORD=27]

                  0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x2fe92d0 [ORD=27]

                  0x3004320: ch = ValueType:i8 [ORD=27]

                0x2fe9ad0: i64 = AssertZext 0x3004420, 0x3004320 [ORD=27]

              0x2fe93d0: i8 = truncate 0x2fe9ad0 [ORD=27]

            0x3004020: i64 = sign_extend 0x2fe93d0 [ORD=27]

            0x2fe6550: i64 = Constant<-9> [ORD=28]

          0x2fe8dd0: i64 = add 0x3004020, 0x2fe6550 [ORD=28]

          0x2fe6350: i64 = Constant<5> [ORD=29]

          0x2fe97d0: ch = setlt [ORD=29]

        0x3004220: i1 = setcc 0x2fe8dd0, 0x2fe6350, 0x2fe97d0 [ORD=29]

        0x2fe6250: i1 = Constant<-1>

      0x2fe9bd0: i1 = xor 0x3004220, 0x2fe6250

      0x3004120: ch = BasicBlock<while.end 0x300f298>

    0x3004520: ch = brcond 0x2fbf468, 0x2fe9bd0, 0x3004120

    0x2fe6050: ch = BasicBlock<while.body 0x300f1f0>

  0x2fe95d0: ch = br 0x3004520, 0x2fe6050



Replacing.3 0x2fe9bd0: i1 = xor 0x3004220, 0x2fe6250

With: 0x2fe98d0: i1 = setcc 0x2fe8dd0, 0x2fe6350, 0x2fe96d0


Replacing.3 0x2fe98d0: i1 = setcc 0x2fe8dd0, 0x2fe6350, 0x2fe96d0

With: 0x2fe6250: i1 = setcc 0x2fe8dd0, 0x2fe97d0, 0x3004220


Replacing.3 0x3004020: i64 = sign_extend 0x2fe93d0 [ORD=27]

With: 0x2fe6350: i64 = sign_extend_inreg 0x2fe9ad0, 0x3004320

Optimized lowered selection DAG: BB#2 'atol:lor.rhs.i'
SelectionDAG has 15 nodes:
  0x2fbf468: ch = EntryToken [ORD=27]

  0x3004320: ch = ValueType:i8 [ORD=27]

      0x2fbf468: <multiple use>
                0x2fbf468: <multiple use>
                0x2fe92d0: i64 = Register %vreg1 [ORD=27]

              0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x2fe92d0 [ORD=27]

              0x3004320: <multiple use>
            0x2fe9ad0: i64 = AssertZext 0x3004420, 0x3004320 [ORD=27]

            0x3004320: <multiple use>
          0x2fe6350: i64 = sign_extend_inreg 0x2fe9ad0, 0x3004320

          0x2fe6550: i64 = Constant<-9> [ORD=28]

        0x2fe8dd0: i64 = add 0x2fe6350, 0x2fe6550 [ORD=28]

        0x2fe97d0: i64 = Constant<4>

        0x3004220: ch = setgt

      0x2fe6250: i1 = setcc 0x2fe8dd0, 0x2fe97d0, 0x3004220

      0x3004120: ch = BasicBlock<while.end 0x300f298>

    0x3004520: ch = brcond 0x2fbf468, 0x2fe6250, 0x3004120

    0x2fe6050: ch = BasicBlock<while.body 0x300f1f0>

  0x2fe95d0: ch = br 0x3004520, 0x2fe6050


Legally typed node: 0x3004220: ch = setgt [ID=0]

Legally typed node: 0x2fe97d0: i64 = Constant<4> [ID=0]

Legally typed node: 0x2fe6050: ch = BasicBlock<while.body 0x300f1f0> [ID=0]

Legally typed node: 0x3004120: ch = BasicBlock<while.end 0x300f298> [ID=0]

Legally typed node: 0x2fe6550: i64 = Constant<-9> [ORD=28] [ID=0]

Legally typed node: 0x3004320: ch = ValueType:i8 [ORD=27] [ID=0]

Legally typed node: 0x2fe92d0: i64 = Register %vreg1 [ORD=27] [ID=0]

Legally typed node: 0x2fbf468: ch = EntryToken [ORD=27] [ID=0]

Legally typed node: 0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x2fe92d0 [ORD=27] [ID=0]

Legally typed node: 0x2fe9ad0: i64 = AssertZext 0x3004420, 0x3004320 [ORD=27] [ID=0]

Legally typed node: 0x2fe6350: i64 = sign_extend_inreg 0x2fe9ad0, 0x3004320 [ID=0]

Legally typed node: 0x2fe8dd0: i64 = add 0x2fe6350, 0x2fe6550 [ORD=28] [ID=0]

Promote integer result: 0x2fe6250: i1 = setcc 0x2fe8dd0, 0x2fe97d0, 0x3004220 [ID=0]

Set Promoted Integer! Opcode0x2fe93d0: i64 = setcc 0x2fe8dd0, 0x2fe97d0, 0x3004220 [ID=0]
5
Promote integer operand: 0x3004520: ch = brcond 0x2fbf468, 0x2fe6250, 0x3004120 [ID=0]
149 1 105 1
Res.getNode(), N0x3004520 0x3004520: Promote integer operand: 0x3004020: i64 = zero_extend 0x2fe6250 [ID=0]
110 0 105 1
0x2fe6250: i1 = setcc 0x2fe8dd0, 0x2fe97d0, 0x3004220 [ID=-3]
 1
105 5
105 5
In PIO_ZERO_EXTEND105 5
Res.getNode(), N0x2fe98d0 0x3004020: Legally typed node: 0x2fe96d0: i64 = Constant<1> [ID=0]

Legally typed node: 0x2fe93d0: i64 = setcc 0x2fe8dd0, 0x2fe97d0, 0x3004220 [ID=0]

Legally typed node: 0x2fe98d0: i64 = and 0x2fe93d0, 0x2fe96d0 [ID=0]

Legally typed node: 0x3004520: ch = brcond 0x2fbf468, 0x2fe98d0, 0x3004120 [ID=0]

Legally typed node: 0x2fe95d0: ch = br 0x3004520, 0x2fe6050 [ID=0]

Legally typed node: 0x7fff8d52a470: ch = handlenode 0x2fe95d0 [ID=0]

Type-legalized selection DAG: BB#2 'atol:lor.rhs.i'
SelectionDAG has 17 nodes:
  0x2fbf468: ch = EntryToken [ORD=27] [ID=-3]

  0x3004320: ch = ValueType:i8 [ORD=27] [ID=-3]

      0x2fbf468: <multiple use>
                  0x2fbf468: <multiple use>
                  0x2fe92d0: i64 = Register %vreg1 [ORD=27] [ID=-3]

                0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x2fe92d0 [ORD=27] [ID=-3]

                0x3004320: <multiple use>
              0x2fe9ad0: i64 = AssertZext 0x3004420, 0x3004320 [ORD=27] [ID=-3]

              0x3004320: <multiple use>
            0x2fe6350: i64 = sign_extend_inreg 0x2fe9ad0, 0x3004320 [ID=-3]

            0x2fe6550: i64 = Constant<-9> [ORD=28] [ID=-3]

          0x2fe8dd0: i64 = add 0x2fe6350, 0x2fe6550 [ORD=28] [ID=-3]

          0x2fe97d0: i64 = Constant<4> [ID=-3]

          0x3004220: ch = setgt [ID=-3]

        0x2fe93d0: i64 = setcc 0x2fe8dd0, 0x2fe97d0, 0x3004220 [ID=-3]

        0x2fe96d0: i64 = Constant<1> [ID=-3]

      0x2fe98d0: i64 = and 0x2fe93d0, 0x2fe96d0 [ID=-3]

      0x3004120: ch = BasicBlock<while.end 0x300f298> [ID=-3]

    0x3004520: ch = brcond 0x2fbf468, 0x2fe98d0, 0x3004120 [ID=-3]

    0x2fe6050: ch = BasicBlock<while.body 0x300f1f0> [ID=-3]

  0x2fe95d0: ch = br 0x3004520, 0x2fe6050 [ID=-3]



Replacing.2 0x2fe98d0: i64 = and 0x2fe93d0, 0x2fe96d0 [ID=-3]

With: 0x2fe93d0: i64 = setcc 0x2fe8dd0, 0x2fe97d0, 0x3004220 [ID=-3]

Optimized type-legalized selection DAG: BB#2 'atol:lor.rhs.i'
SelectionDAG has 15 nodes:
  0x2fbf468: ch = EntryToken [ORD=27] [ID=-3]

  0x3004320: ch = ValueType:i8 [ORD=27] [ID=-3]

      0x2fbf468: <multiple use>
                0x2fbf468: <multiple use>
                0x2fe92d0: i64 = Register %vreg1 [ORD=27] [ID=-3]

              0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x2fe92d0 [ORD=27] [ID=-3]

              0x3004320: <multiple use>
            0x2fe9ad0: i64 = AssertZext 0x3004420, 0x3004320 [ORD=27] [ID=-3]

            0x3004320: <multiple use>
          0x2fe6350: i64 = sign_extend_inreg 0x2fe9ad0, 0x3004320 [ID=-3]

          0x2fe6550: i64 = Constant<-9> [ORD=28] [ID=-3]

        0x2fe8dd0: i64 = add 0x2fe6350, 0x2fe6550 [ORD=28] [ID=-3]

        0x2fe97d0: i64 = Constant<4> [ID=-3]

        0x3004220: ch = setgt [ID=-3]

      0x2fe93d0: i64 = setcc 0x2fe8dd0, 0x2fe97d0, 0x3004220 [ID=-3]

      0x3004120: ch = BasicBlock<while.end 0x300f298> [ID=-3]

    0x3004520: ch = brcond 0x2fbf468, 0x2fe93d0, 0x3004120 [ID=-3]

    0x2fe6050: ch = BasicBlock<while.body 0x300f1f0> [ID=-3]

  0x2fe95d0: ch = br 0x3004520, 0x2fe6050 [ID=-3]


In LegalizeDAG() 146
In legalize Op146
0
0
0
In LegalizeDAG() 149
In legalize Op149
0
0
5
0
105 105 210
Lowering SETCC to CMP. Here are the operands' types 48 5 10 5
In LegalizeDAG() 48
In legalize Op48
5
5
5
In LegalizeDAG() 115
In legalize Op115
5
5
0
In LegalizeDAG() 4
In legalize Op4
5
5
0
In LegalizeDAG() 43
In legalize Op43
5
0
0
5
In LegalizeDAG() 10
In legalize Op10
5
In LegalizeDAG() 5
In legalize Op5
0
In LegalizeDAG() 5
In legalize Op5
0
In LegalizeDAG() 10
In legalize Op10
5
In LegalizeDAG() 6
In legalize Op6
0
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 1
In legalize Op1
0
In LegalizeDAG() 92
In legalize Op92
5
5
5
OPTY SHTY5 2
going to legalise operand on SHL etc5
In legalize Op10
5
In LegalizeDAG() 91
In legalize Op91
5
5
5
OPTY SHTY5 2
going to legalise operand on SHL etc5
In legalize Op10
5
In LegalizeDAG() 10
In legalize Op10
5
In LegalizeDAG() 210
In legalize Op210
0
0
0
5
5
In LegalizeDAG() 200
In legalize Op200
5
5
5
5
In LegalizeDAG() 10
In legalize Op10
5
In LegalizeDAG() 10
In legalize Op10
2
Legalized selection DAG: BB#2 'atol:lor.rhs.i'
SelectionDAG has 17 nodes:
  0x2fbf468: ch = EntryToken [ORD=27] [ID=0]

  0x2fe96d0: i64 = Constant<5>

  0x2fe6350: i64 = Constant<56>

      0x2fbf468: <multiple use>
      0x3004120: ch = BasicBlock<while.end 0x300f298> [ID=4]

      0x2fe96d0: <multiple use>
                  0x2fbf468: <multiple use>
                  0x2fe92d0: i64 = Register %vreg1 [ORD=27] [ID=1]

                0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x2fe92d0 [ORD=27] [ID=8]

                0x3004320: ch = ValueType:i8 [ORD=27] [ID=2]

              0x2fe9ad0: i64 = AssertZext 0x3004420, 0x3004320 [ORD=27] [ID=9]

              0x2fe6350: <multiple use>
            0x2fe93d0: i64 = shl 0x2fe9ad0, 0x2fe6350

            0x2fe6350: <multiple use>
          0x3004520: i64 = sra 0x2fe93d0, 0x2fe6350

          0x2fe6550: i64 = Constant<-9> [ORD=28] [ID=3]

        0x2fe8dd0: i64 = add 0x3004520, 0x2fe6550 [ORD=28] [ID=11]

        0x2fe97d0: i64 = Constant<4> [ID=6]

        0x2fe96d0: <multiple use>
      0x2fe98d0: i64 = X86ISD::CMP 0x2fe8dd0, 0x2fe97d0, 0x2fe96d0

    0x2fe6250: ch = X86ISD::BRCOND 0x2fbf468, 0x3004120, 0x2fe96d0, 0x2fe98d0

    0x2fe6050: ch = BasicBlock<while.body 0x300f1f0> [ID=5]

  0x2fe95d0: ch = br 0x2fe6250, 0x2fe6050 [ID=14]


Optimized legalized selection DAG: BB#2 'atol:lor.rhs.i'
SelectionDAG has 17 nodes:
  0x2fbf468: ch = EntryToken [ORD=27] [ID=0]

  0x2fe96d0: i64 = Constant<5>

  0x2fe6350: i64 = Constant<56>

      0x2fbf468: <multiple use>
      0x3004120: ch = BasicBlock<while.end 0x300f298> [ID=4]

      0x2fe96d0: <multiple use>
                  0x2fbf468: <multiple use>
                  0x2fe92d0: i64 = Register %vreg1 [ORD=27] [ID=1]

                0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x2fe92d0 [ORD=27] [ID=8]

                0x3004320: ch = ValueType:i8 [ORD=27] [ID=2]

              0x2fe9ad0: i64 = AssertZext 0x3004420, 0x3004320 [ORD=27] [ID=9]

              0x2fe6350: <multiple use>
            0x2fe93d0: i64 = shl 0x2fe9ad0, 0x2fe6350

            0x2fe6350: <multiple use>
          0x3004520: i64 = sra 0x2fe93d0, 0x2fe6350

          0x2fe6550: i64 = Constant<-9> [ORD=28] [ID=3]

        0x2fe8dd0: i64 = add 0x3004520, 0x2fe6550 [ORD=28] [ID=11]

        0x2fe97d0: i64 = Constant<4> [ID=6]

        0x2fe96d0: <multiple use>
      0x2fe98d0: i64 = X86ISD::CMP 0x2fe8dd0, 0x2fe97d0, 0x2fe96d0

    0x2fe6250: ch = X86ISD::BRCOND 0x2fbf468, 0x3004120, 0x2fe96d0, 0x2fe98d0

    0x2fe6050: ch = BasicBlock<while.body 0x300f1f0> [ID=5]

  0x2fe95d0: ch = br 0x2fe6250, 0x2fe6050 [ID=14]


===== Instruction selection begins: BB#2 'lor.rhs.i'
Selecting: 0x2fe95d0: ch = br 0x2fe6250, 0x2fe6050 [ID=16]

ISEL: Starting pattern match on root node: 0x2fe95d0: ch = br 0x2fe6250, 0x2fe6050 [ID=16]

  Initial Opcode index to 120382
  Skipped scope entry (due to false predicate) at index 120392, continuing at 120402
  Morphed node: 0x2fe95d0: ch = JMP64pcrel32 0x2fe6050, 0x2fe6250

ISEL: Match complete!
=> 0x2fe95d0: ch = JMP64pcrel32 0x2fe6050, 0x2fe6250

Selecting: 0x2fe6250: ch = X86ISD::BRCOND 0x2fbf468, 0x3004120, 0x2fe96d0, 0x2fe98d0 [ID=15]

ISEL: Starting pattern match on root node: 0x2fe6250: ch = X86ISD::BRCOND 0x2fbf468, 0x3004120, 0x2fe96d0, 0x2fe98d0 [ID=15]

  Initial Opcode index to 81395
  Skipped scope entry (due to false predicate) at index 81407, continuing at 81439
  Skipped scope entry (due to false predicate) at index 81440, continuing at 81472
  Skipped scope entry (due to false predicate) at index 81473, continuing at 81505
  Skipped scope entry (due to false predicate) at index 81506, continuing at 81538
  Skipped scope entry (due to false predicate) at index 81539, continuing at 81571
  Skipped scope entry (due to false predicate) at index 81572, continuing at 81604
  Skipped scope entry (due to false predicate) at index 81605, continuing at 81637
  Skipped scope entry (due to false predicate) at index 81638, continuing at 81670
  Skipped scope entry (due to false predicate) at index 81671, continuing at 81703
  Skipped scope entry (due to false predicate) at index 81704, continuing at 81736
  Skipped scope entry (due to false predicate) at index 81737, continuing at 81769
  Skipped scope entry (due to false predicate) at index 81770, continuing at 81802
  Skipped scope entry (due to false predicate) at index 81803, continuing at 81835
  Skipped scope entry (due to false predicate) at index 81836, continuing at 81868
  Skipped scope entry (due to false predicate) at index 81869, continuing at 81901
  Skipped scope entry (due to false predicate) at index 81908, continuing at 81921
  Morphed node: 0x2fe6250: ch = JG_64 0x3004120, 0x3004020, 0x3004020:1

ISEL: Match complete!
=> 0x2fe6250: ch = JG_64 0x3004120, 0x3004020, 0x3004020:1

Selecting: 0x2fe98d0: i64 = X86ISD::CMP 0x2fe8dd0, 0x2fe97d0, 0x2fe96d0 [ID=14]

ISEL: Starting pattern match on root node: 0x2fe98d0: i64 = X86ISD::CMP 0x2fe8dd0, 0x2fe97d0, 0x2fe96d0 [ID=14]

  Initial Opcode index to 15658
  Match failed at index 15663
  Continuing at 16336
  Skipped scope entry (due to false predicate) at index 16341, continuing at 16376
  Skipped scope entry (due to false predicate) at index 16377, continuing at 16412
  Skipped scope entry (due to false predicate) at index 16413, continuing at 16448
  Match failed at index 16453
  Continuing at 16482
  Continuing at 16483
  Match failed at index 16486
  Continuing at 16589
  Skipped scope entry (due to false predicate) at index 16593, continuing at 16651
  Skipped scope entry (due to false predicate) at index 16652, continuing at 16710
  Match failed at index 16591
  Continuing at 16711
  Match failed at index 16715
  Continuing at 16903
  Skipped scope entry (due to false predicate) at index 16908, continuing at 16965
  Skipped scope entry (due to false predicate) at index 16966, continuing at 17043
  Skipped scope entry (due to false predicate) at index 17044, continuing at 17121
  Match failed at index 17128
  Continuing at 17140
  Morphed node: 0x2fe98d0: i32 = CMP64ri8 0x2fe8dd0, 0x2fe9bd0

ISEL: Match complete!
=> 0x2fe98d0: i32 = CMP64ri8 0x2fe8dd0, 0x2fe9bd0

Selecting: 0x2fe8dd0: i64 = add 0x3004520, 0x2fe6550 [ORD=28] [ID=13]

ISEL: Starting pattern match on root node: 0x2fe8dd0: i64 = add 0x3004520, 0x2fe6550 [ORD=28] [ID=13]

  Initial Opcode index to 67013
  Match failed at index 67018
  Continuing at 67125
  Match failed at index 67129
  Continuing at 67324
  Match failed at index 67328
  Continuing at 67409
  TypeSwitch[i64] from 67411 to 67454
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg 0x3004520: i64 = sra 0x2fe93d0, 0x2fe6350 [ID=12]
 Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Match failed at index 67454
  Continuing at 67470
  Match failed at index 67474
  Continuing at 67596
  Match failed at index 67600
  Continuing at 67728
  Skipped scope entry (due to false predicate) at index 67738, continuing at 67821
  Skipped scope entry (due to false predicate) at index 67822, continuing at 67914
  Skipped scope entry (due to false predicate) at index 67915, continuing at 67997
  Skipped scope entry (due to false predicate) at index 67998, continuing at 68029
  Match failed at index 67736
  Continuing at 68030
  Match failed at index 68045
  Continuing at 68059
  Match failed at index 68063
  Continuing at 68077
  Morphed node: 0x2fe8dd0: i64,i32 = ADD64ri8 0x3004520, 0x2fe8ed0 [ORD=28]

ISEL: Match complete!
=> 0x2fe8dd0: i64,i32 = ADD64ri8 0x3004520, 0x2fe8ed0 [ORD=28]

Selecting: 0x3004520: i64 = sra 0x2fe93d0, 0x2fe6350 [ID=12]

ISEL: Starting pattern match on root node: 0x3004520: i64 = sra 0x2fe93d0, 0x2fe6350 [ID=12]

  Initial Opcode index to 80241
  Skipped scope entry (due to false predicate) at index 80249, continuing at 80332
  Skipped scope entry (due to false predicate) at index 80333, continuing at 80395
  Match failed at index 80247
  Continuing at 80396
  TypeSwitch[i64] from 80406 to 80462
  Morphed node: 0x3004520: i64,i32 = SAR64ri 0x2fe93d0, 0x2fe6550

ISEL: Match complete!
=> 0x3004520: i64,i32 = SAR64ri 0x2fe93d0, 0x2fe6550

Selecting: 0x2fe93d0: i64 = shl 0x2fe9ad0, 0x2fe6350 [ID=11]

ISEL: Starting pattern match on root node: 0x2fe93d0: i64 = shl 0x2fe9ad0, 0x2fe6350 [ID=11]

  Initial Opcode index to 76595
  TypeSwitch[i64] from 76598 to 76641
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Match failed at index 76641
  Continuing at 76657
  Skipped scope entry (due to false predicate) at index 76667, continuing at 76750
  Skipped scope entry (due to false predicate) at index 76751, continuing at 76806
  Match failed at index 76665
  Continuing at 76807
  TypeSwitch[i64] from 76817 to 76873
  Morphed node: 0x2fe93d0: i64,i32 = SHL64ri 0x2fe9ad0, 0x2fe6550

ISEL: Match complete!
=> 0x2fe93d0: i64,i32 = SHL64ri 0x2fe9ad0, 0x2fe6550

Selecting: 0x2fe9ad0: i64 = AssertZext 0x3004420, 0x3004320 [ORD=27] [ID=10]

=> 0x2fe9ad0: i64 = AssertZext 0x3004420, 0x3004320 [ORD=27] [ID=10]

Selecting: 0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x2fe92d0 [ORD=27] [ID=9]

=> 0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x2fe92d0 [ORD=27]

Selecting: 0x2fe6050: ch = BasicBlock<while.body 0x300f1f0> [ID=5]

=> 0x2fe6050: ch = BasicBlock<while.body 0x300f1f0>

Selecting: 0x3004120: ch = BasicBlock<while.end 0x300f298> [ID=4]

=> 0x3004120: ch = BasicBlock<while.end 0x300f298>

Selecting: 0x2fe92d0: i64 = Register %vreg1 [ORD=27] [ID=1]

=> 0x2fe92d0: i64 = Register %vreg1 [ORD=27]

Selecting: 0x2fbf468: ch = EntryToken [ORD=27] [ID=0]

=> 0x2fbf468: ch = EntryToken [ORD=27]

===== Instruction selection ends:
Selected selection DAG: BB#2 'atol:lor.rhs.i'
SelectionDAG has 18 nodes:
  0x2fbf468: ch = EntryToken [ORD=27]

    0x2fbf468: <multiple use>
    0x3004220: i64 = Register %EFLAGS

              0x2fbf468: <multiple use>
              0x2fe92d0: i64 = Register %vreg1 [ORD=27]

            0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x2fe92d0 [ORD=27]

            0x2fe6550: <multiple use>
          0x2fe93d0: i64,i32 = SHL64ri 0x3004420, 0x2fe6550

          0x2fe6550: <multiple use>
        0x3004520: i64,i32 = SAR64ri 0x2fe93d0, 0x2fe6550

        0x2fe8ed0: i64 = TargetConstant<-9>

      0x2fe8dd0: i64,i32 = ADD64ri8 0x3004520, 0x2fe8ed0 [ORD=28]

      0x2fe9bd0: i64 = TargetConstant<4>

    0x2fe98d0: i32 = CMP64ri8 0x2fe8dd0, 0x2fe9bd0

  0x3004020: ch,glue = CopyToReg 0x2fbf468, 0x3004220, 0x2fe98d0

  0x2fe97d0: i32 = Register %noreg

  0x2fe96d0: i64 = Register %noreg

  0x2fe6550: i64 = TargetConstant<56>

    0x2fe6050: ch = BasicBlock<while.body 0x300f1f0>

      0x3004120: ch = BasicBlock<while.end 0x300f298>

      0x3004020: <multiple use>
      0x3004020: <multiple use>
    0x2fe6250: ch = JG_64 0x3004120, 0x3004020, 0x3004020:1

  0x2fe95d0: ch = JMP64pcrel32 0x2fe6050, 0x2fe6250


********** List Scheduling BB#2 'lor.rhs.i' **********
SU(0): 0x2fe95d0: ch = JMP64pcrel32 0x2fe6050, 0x2fe6250 [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x2fe6250: ch = JG_64 0x3004120, 0x3004020, 0x3004020:1 [ID=1]

    0x3004020: ch,glue = CopyToReg 0x2fbf468, 0x3004220, 0x2fe98d0 [ID=1]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(2): Latency=1 Reg=%EFLAGS
  Successors:
   ch  SU(0): Latency=1

SU(2): 0x2fe98d0: i32 = CMP64ri8 0x2fe8dd0, 0x2fe9bd0 [ID=2]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(3): Latency=1
  Successors:
   val SU(1): Latency=1

SU(3): 0x2fe8dd0: i64,i32 = ADD64ri8 0x3004520, 0x2fe8ed0 [ORD=28] [ID=3]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(4): Latency=1
  Successors:
   val SU(2): Latency=1

SU(4): 0x3004520: i64,i32 = SAR64ri 0x2fe93d0, 0x2fe6550 [ID=4]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(5): Latency=1
  Successors:
   val SU(3): Latency=1

SU(5): 0x2fe93d0: i64,i32 = SHL64ri 0x3004420, 0x2fe6550 [ID=5]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(6): Latency=1
  Successors:
   val SU(4): Latency=1

SU(6): 0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x2fe92d0 [ORD=27] [ID=6]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
   val SU(5): Latency=1


Examining Available:
Height 0: SU(0): 0x2fe95d0: ch = JMP64pcrel32 0x2fe6050, 0x2fe6250 [ID=0]


*** Scheduling [0]: SU(0): 0x2fe95d0: ch = JMP64pcrel32 0x2fe6050, 0x2fe6250 [ID=0]


Examining Available:
Height 1: SU(1): 0x2fe6250: ch = JG_64 0x3004120, 0x3004020, 0x3004020:1 [ID=1]

    0x3004020: ch,glue = CopyToReg 0x2fbf468, 0x3004220, 0x2fe98d0 [ID=1]


*** Scheduling [1]: SU(1): 0x2fe6250: ch = JG_64 0x3004120, 0x3004020, 0x3004020:1 [ID=1]

    0x3004020: ch,glue = CopyToReg 0x2fbf468, 0x3004220, 0x2fe98d0 [ID=1]


Examining Available:
Height 2: SU(2): 0x2fe98d0: i32 = CMP64ri8 0x2fe8dd0, 0x2fe9bd0 [ID=2]


*** Scheduling [2]: SU(2): 0x2fe98d0: i32 = CMP64ri8 0x2fe8dd0, 0x2fe9bd0 [ID=2]

GR64: 1 / 12

Examining Available:
Height 3: SU(3): 0x2fe8dd0: i64,i32 = ADD64ri8 0x3004520, 0x2fe8ed0 [ORD=28] [ID=3]


*** Scheduling [3]: SU(3): 0x2fe8dd0: i64,i32 = ADD64ri8 0x3004520, 0x2fe8ed0 [ORD=28] [ID=3]

GR64: 1 / 12

Examining Available:
Height 4: SU(4): 0x3004520: i64,i32 = SAR64ri 0x2fe93d0, 0x2fe6550 [ID=4]


*** Scheduling [4]: SU(4): 0x3004520: i64,i32 = SAR64ri 0x2fe93d0, 0x2fe6550 [ID=4]

GR64: 1 / 12

Examining Available:
Height 5: SU(5): 0x2fe93d0: i64,i32 = SHL64ri 0x3004420, 0x2fe6550 [ID=5]


*** Scheduling [5]: SU(5): 0x2fe93d0: i64,i32 = SHL64ri 0x3004420, 0x2fe6550 [ID=5]

GR64: 1 / 12

Examining Available:
Height 6: SU(6): 0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x2fe92d0 [ORD=27] [ID=6]


*** Scheduling [6]: SU(6): 0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x2fe92d0 [ORD=27] [ID=6]

*** Final schedule ***
SU(6): 0x3004420: i64,ch = CopyFromReg 0x2fbf468, 0x2fe92d0 [ORD=27] [ID=6]

SU(5): 0x2fe93d0: i64,i32 = SHL64ri 0x3004420, 0x2fe6550 [ID=5]

SU(4): 0x3004520: i64,i32 = SAR64ri 0x2fe93d0, 0x2fe6550 [ID=4]

SU(3): 0x2fe8dd0: i64,i32 = ADD64ri8 0x3004520, 0x2fe8ed0 [ORD=28] [ID=3]

SU(2): 0x2fe98d0: i32 = CMP64ri8 0x2fe8dd0, 0x2fe9bd0 [ID=2]

SU(1): 0x2fe6250: ch = JG_64 0x3004120, 0x3004020, 0x3004020:1 [ID=1]

    0x3004020: ch,glue = CopyToReg 0x2fbf468, 0x3004220, 0x2fe98d0 [ID=1]

SU(0): 0x2fe95d0: ch = JMP64pcrel32 0x2fe6050, 0x2fe6250 [ID=0]


Total amount of phi nodes to update: 0
I've changed this to i64 from i16! Might break returns!Initial selection DAG: BB#4 'atol:while.end'
SelectionDAG has 6 nodes:
    0x2fbf468: ch = EntryToken

    0x2fe96d0: i64 = Register %RAX

    0x2fe6550: i64 = Constant<0>

  0x2fe97d0: ch,glue = CopyToReg 0x2fbf468, 0x2fe96d0, 0x2fe6550

    0x2fe97d0: <multiple use>
    0x2fe8ed0: i64 = TargetConstant<0>

    0x2fe97d0: <multiple use>
  0x2fe9bd0: ch = X86ISD::RET_FLAG 0x2fe97d0, 0x2fe8ed0, 0x2fe97d0:1


Optimized lowered selection DAG: BB#4 'atol:while.end'
SelectionDAG has 6 nodes:
    0x2fbf468: ch = EntryToken

    0x2fe96d0: i64 = Register %RAX

    0x2fe6550: i64 = Constant<0>

  0x2fe97d0: ch,glue = CopyToReg 0x2fbf468, 0x2fe96d0, 0x2fe6550

    0x2fe97d0: <multiple use>
    0x2fe8ed0: i64 = TargetConstant<0>

    0x2fe97d0: <multiple use>
  0x2fe9bd0: ch = X86ISD::RET_FLAG 0x2fe97d0, 0x2fe8ed0, 0x2fe97d0:1


Legally typed node: 0x2fe96d0: i64 = Register %RAX [ID=0]

Legally typed node: 0x2fe8ed0: i64 = TargetConstant<0> [ID=0]

Legally typed node: 0x2fe6550: i64 = Constant<0> [ID=0]

Legally typed node: 0x2fbf468: ch = EntryToken [ID=0]

Legally typed node: 0x2fe97d0: ch,glue = CopyToReg 0x2fbf468, 0x2fe96d0, 0x2fe6550 [ID=0]

Legally typed node: 0x2fe9bd0: ch = X86ISD::RET_FLAG 0x2fe97d0, 0x2fe8ed0, 0x2fe97d0:1 [ID=0]

Legally typed node: 0x7fff8d52a470: ch = handlenode 0x2fe9bd0 [ID=0]

Type-legalized selection DAG: BB#4 'atol:while.end'
SelectionDAG has 6 nodes:
    0x2fbf468: ch = EntryToken [ID=-3]

    0x2fe96d0: i64 = Register %RAX [ID=-3]

    0x2fe6550: i64 = Constant<0> [ID=-3]

  0x2fe97d0: ch,glue = CopyToReg 0x2fbf468, 0x2fe96d0, 0x2fe6550 [ID=-3]

    0x2fe97d0: <multiple use>
    0x2fe8ed0: i64 = TargetConstant<0> [ID=-3]

    0x2fe97d0: <multiple use>
  0x2fe9bd0: ch = X86ISD::RET_FLAG 0x2fe97d0, 0x2fe8ed0, 0x2fe97d0:1 [ID=-3]


In LegalizeDAG() 211
In legalize Op211
0
0
5
50
In LegalizeDAG() 42
In legalize Op42
0
50
0
5
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 29
In LegalizeDAG() 10
In legalize Op10
5
In LegalizeDAG() 1
In legalize Op1
0
Legalized selection DAG: BB#4 'atol:while.end'
SelectionDAG has 6 nodes:
    0x2fbf468: ch = EntryToken [ID=0]

    0x2fe96d0: i64 = Register %RAX [ID=3]

    0x2fe6550: i64 = Constant<0> [ID=1]

  0x2fe97d0: ch,glue = CopyToReg 0x2fbf468, 0x2fe96d0, 0x2fe6550 [ID=4]

    0x2fe97d0: <multiple use>
    0x2fe8ed0: i64 = TargetConstant<0> [ID=2]

    0x2fe97d0: <multiple use>
  0x2fe9bd0: ch = X86ISD::RET_FLAG 0x2fe97d0, 0x2fe8ed0, 0x2fe97d0:1 [ID=5]


Optimized legalized selection DAG: BB#4 'atol:while.end'
SelectionDAG has 6 nodes:
    0x2fbf468: ch = EntryToken [ID=0]

    0x2fe96d0: i64 = Register %RAX [ID=3]

    0x2fe6550: i64 = Constant<0> [ID=1]

  0x2fe97d0: ch,glue = CopyToReg 0x2fbf468, 0x2fe96d0, 0x2fe6550 [ID=4]

    0x2fe97d0: <multiple use>
    0x2fe8ed0: i64 = TargetConstant<0> [ID=2]

    0x2fe97d0: <multiple use>
  0x2fe9bd0: ch = X86ISD::RET_FLAG 0x2fe97d0, 0x2fe8ed0, 0x2fe97d0:1 [ID=5]


===== Instruction selection begins: BB#4 'while.end'
Selecting: 0x2fe9bd0: ch = X86ISD::RET_FLAG 0x2fe97d0, 0x2fe8ed0, 0x2fe97d0:1 [ID=5]

ISEL: Starting pattern match on root node: 0x2fe9bd0: ch = X86ISD::RET_FLAG 0x2fe97d0, 0x2fe8ed0, 0x2fe97d0:1 [ID=5]

  Initial Opcode index to 81356
  Morphed node: 0x2fe9bd0: ch = RET 0x2fe97d0, 0x2fe97d0:1

ISEL: Match complete!
=> 0x2fe9bd0: ch = RET 0x2fe97d0, 0x2fe97d0:1

Selecting: 0x2fe97d0: ch,glue = CopyToReg 0x2fbf468, 0x2fe96d0, 0x2fe6550 [ID=4]

=> 0x2fe97d0: ch,glue = CopyToReg 0x2fbf468, 0x2fe96d0, 0x2fe6550

Selecting: 0x2fe96d0: i64 = Register %RAX [ID=3]

=> 0x2fe96d0: i64 = Register %RAX

Selecting: 0x2fe6550: i64 = Constant<0> [ID=1]

ISEL: Starting pattern match on root node: 0x2fe6550: i64 = Constant<0> [ID=1]

  Initial Opcode index to 83167
  TypeSwitch[i64] from 83171 to 83174
  Morphed node: 0x2fe6550: i64,i32 = MOV64r0

ISEL: Match complete!
=> 0x2fe6550: i64,i32 = MOV64r0

Selecting: 0x2fbf468: ch = EntryToken [ID=0]

=> 0x2fbf468: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#4 'atol:while.end'
SelectionDAG has 5 nodes:
    0x2fbf468: ch = EntryToken

    0x2fe96d0: i64 = Register %RAX

    0x2fe6550: i64,i32 = MOV64r0

  0x2fe97d0: ch,glue = CopyToReg 0x2fbf468, 0x2fe96d0, 0x2fe6550

    0x2fe97d0: <multiple use>
    0x2fe97d0: <multiple use>
  0x2fe9bd0: ch = RET 0x2fe97d0, 0x2fe97d0:1


********** List Scheduling BB#4 'while.end' **********
SU(0): 0x2fe9bd0: ch = RET 0x2fe97d0, 0x2fe97d0:1 [ID=0]

    0x2fe97d0: ch,glue = CopyToReg 0x2fbf468, 0x2fe96d0, 0x2fe6550 [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(1): Latency=1

SU(1): 0x2fe6550: i64,i32 = MOV64r0 [ID=1]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
   val SU(0): Latency=1


Examining Available:
Height 0: SU(0): 0x2fe9bd0: ch = RET 0x2fe97d0, 0x2fe97d0:1 [ID=0]

    0x2fe97d0: ch,glue = CopyToReg 0x2fbf468, 0x2fe96d0, 0x2fe6550 [ID=0]


*** Scheduling [0]: SU(0): 0x2fe9bd0: ch = RET 0x2fe97d0, 0x2fe97d0:1 [ID=0]

    0x2fe97d0: ch,glue = CopyToReg 0x2fbf468, 0x2fe96d0, 0x2fe6550 [ID=0]

GR64: 1 / 12

Examining Available:
Height 1: SU(1): 0x2fe6550: i64,i32 = MOV64r0 [ID=1]


*** Scheduling [1]: SU(1): 0x2fe6550: i64,i32 = MOV64r0 [ID=1]

*** Final schedule ***
SU(1): 0x2fe6550: i64,i32 = MOV64r0 [ID=1]

SU(0): 0x2fe9bd0: ch = RET 0x2fe97d0, 0x2fe97d0:1 [ID=0]

    0x2fe97d0: ch,glue = CopyToReg 0x2fbf468, 0x2fe96d0, 0x2fe6550 [ID=0]


Total amount of phi nodes to update: 0
Initial selection DAG: BB#3 'atol:while.body'
SelectionDAG has 9 nodes:
  0x2fbf468: ch = EntryToken [ORD=30]

      0x2fbf468: <multiple use>
      0x2fe8ed0: i64 = Register %vreg2

          0x2fbf468: <multiple use>
          0x2fe9bd0: i64 = Register %vreg0 [ORD=30]

        0x2fe97d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=30]

        0x2fe96d0: i64 = Constant<1> [ORD=30]

      0x2fe6550: i64 = add 0x2fe97d0, 0x2fe96d0 [ORD=30]

    0x3004020: ch = CopyToReg 0x2fbf468, 0x2fe8ed0, 0x2fe6550

    0x3004220: ch = BasicBlock<while.cond 0x300f038>

  0x2fe95d0: ch = br 0x3004020, 0x3004220


Optimized lowered selection DAG: BB#3 'atol:while.body'
SelectionDAG has 9 nodes:
  0x2fbf468: ch = EntryToken [ORD=30]

      0x2fbf468: <multiple use>
      0x2fe8ed0: i64 = Register %vreg2

          0x2fbf468: <multiple use>
          0x2fe9bd0: i64 = Register %vreg0 [ORD=30]

        0x2fe97d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=30]

        0x2fe96d0: i64 = Constant<1> [ORD=30]

      0x2fe6550: i64 = add 0x2fe97d0, 0x2fe96d0 [ORD=30]

    0x3004020: ch = CopyToReg 0x2fbf468, 0x2fe8ed0, 0x2fe6550

    0x3004220: ch = BasicBlock<while.cond 0x300f038>

  0x2fe95d0: ch = br 0x3004020, 0x3004220


Legally typed node: 0x3004220: ch = BasicBlock<while.cond 0x300f038> [ID=0]

Legally typed node: 0x2fe8ed0: i64 = Register %vreg2 [ID=0]

Legally typed node: 0x2fe96d0: i64 = Constant<1> [ORD=30] [ID=0]

Legally typed node: 0x2fe9bd0: i64 = Register %vreg0 [ORD=30] [ID=0]

Legally typed node: 0x2fbf468: ch = EntryToken [ORD=30] [ID=0]

Legally typed node: 0x2fe97d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=30] [ID=0]

Legally typed node: 0x2fe6550: i64 = add 0x2fe97d0, 0x2fe96d0 [ORD=30] [ID=0]

Legally typed node: 0x3004020: ch = CopyToReg 0x2fbf468, 0x2fe8ed0, 0x2fe6550 [ID=0]

Legally typed node: 0x2fe95d0: ch = br 0x3004020, 0x3004220 [ID=0]

Legally typed node: 0x7fff8d52a470: ch = handlenode 0x2fe95d0 [ID=0]

Type-legalized selection DAG: BB#3 'atol:while.body'
SelectionDAG has 9 nodes:
  0x2fbf468: ch = EntryToken [ORD=30] [ID=-3]

      0x2fbf468: <multiple use>
      0x2fe8ed0: i64 = Register %vreg2 [ID=-3]

          0x2fbf468: <multiple use>
          0x2fe9bd0: i64 = Register %vreg0 [ORD=30] [ID=-3]

        0x2fe97d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=30] [ID=-3]

        0x2fe96d0: i64 = Constant<1> [ORD=30] [ID=-3]

      0x2fe6550: i64 = add 0x2fe97d0, 0x2fe96d0 [ORD=30] [ID=-3]

    0x3004020: ch = CopyToReg 0x2fbf468, 0x2fe8ed0, 0x2fe6550 [ID=-3]

    0x3004220: ch = BasicBlock<while.cond 0x300f038> [ID=-3]

  0x2fe95d0: ch = br 0x3004020, 0x3004220 [ID=-3]


In LegalizeDAG() 146
In legalize Op146
0
0
0
In LegalizeDAG() 42
In legalize Op42
0
0
5
5
In LegalizeDAG() 48
In legalize Op48
5
5
5
In LegalizeDAG() 43
In legalize Op43
5
0
0
5
In LegalizeDAG() 5
In legalize Op5
0
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 10
In legalize Op10
5
In LegalizeDAG() 8
In legalize Op8
5
In LegalizeDAG() 1
In legalize Op1
0
Legalized selection DAG: BB#3 'atol:while.body'
SelectionDAG has 9 nodes:
  0x2fbf468: ch = EntryToken [ORD=30] [ID=0]

      0x2fbf468: <multiple use>
      0x2fe8ed0: i64 = Register %vreg2 [ID=3]

          0x2fbf468: <multiple use>
          0x2fe9bd0: i64 = Register %vreg0 [ORD=30] [ID=1]

        0x2fe97d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=30] [ID=5]

        0x2fe96d0: i64 = Constant<1> [ORD=30] [ID=2]

      0x2fe6550: i64 = add 0x2fe97d0, 0x2fe96d0 [ORD=30] [ID=6]

    0x3004020: ch = CopyToReg 0x2fbf468, 0x2fe8ed0, 0x2fe6550 [ID=7]

    0x3004220: ch = BasicBlock<while.cond 0x300f038> [ID=4]

  0x2fe95d0: ch = br 0x3004020, 0x3004220 [ID=8]


Optimized legalized selection DAG: BB#3 'atol:while.body'
SelectionDAG has 9 nodes:
  0x2fbf468: ch = EntryToken [ORD=30] [ID=0]

      0x2fbf468: <multiple use>
      0x2fe8ed0: i64 = Register %vreg2 [ID=3]

          0x2fbf468: <multiple use>
          0x2fe9bd0: i64 = Register %vreg0 [ORD=30] [ID=1]

        0x2fe97d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=30] [ID=5]

        0x2fe96d0: i64 = Constant<1> [ORD=30] [ID=2]

      0x2fe6550: i64 = add 0x2fe97d0, 0x2fe96d0 [ORD=30] [ID=6]

    0x3004020: ch = CopyToReg 0x2fbf468, 0x2fe8ed0, 0x2fe6550 [ID=7]

    0x3004220: ch = BasicBlock<while.cond 0x300f038> [ID=4]

  0x2fe95d0: ch = br 0x3004020, 0x3004220 [ID=8]


===== Instruction selection begins: BB#3 'while.body'
Selecting: 0x2fe95d0: ch = br 0x3004020, 0x3004220 [ID=8]

ISEL: Starting pattern match on root node: 0x2fe95d0: ch = br 0x3004020, 0x3004220 [ID=8]

  Initial Opcode index to 120382
  Skipped scope entry (due to false predicate) at index 120392, continuing at 120402
  Morphed node: 0x2fe95d0: ch = JMP64pcrel32 0x3004220, 0x3004020

ISEL: Match complete!
=> 0x2fe95d0: ch = JMP64pcrel32 0x3004220, 0x3004020

Selecting: 0x3004020: ch = CopyToReg 0x2fbf468, 0x2fe8ed0, 0x2fe6550 [ID=7]

=> 0x3004020: ch = CopyToReg 0x2fbf468, 0x2fe8ed0, 0x2fe6550

Selecting: 0x2fe6550: i64 = add 0x2fe97d0, 0x2fe96d0 [ORD=30] [ID=6]

ISEL: Starting pattern match on root node: 0x2fe6550: i64 = add 0x2fe97d0, 0x2fe96d0 [ORD=30] [ID=6]

  Initial Opcode index to 67013
  Match failed at index 67018
  Continuing at 67125
  Match failed at index 67129
  Continuing at 67324
  Match failed at index 67328
  Continuing at 67409
  TypeSwitch[i64] from 67411 to 67454
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fff8d529550
Base_Reg 0x2fe97d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ID=5]
 Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Match failed at index 67454
  Continuing at 67470
  Match failed at index 67474
  Continuing at 67596
  Match failed at index 67600
  Continuing at 67728
  TypeSwitch[i64] from 67741 to 67800
  Morphed node: 0x2fe6550: i64,i32 = INC64r 0x2fe97d0 [ORD=30]

ISEL: Match complete!
=> 0x2fe6550: i64,i32 = INC64r 0x2fe97d0 [ORD=30]

Selecting: 0x2fe97d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=30] [ID=5]

=> 0x2fe97d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=30]

Selecting: 0x3004220: ch = BasicBlock<while.cond 0x300f038> [ID=4]

=> 0x3004220: ch = BasicBlock<while.cond 0x300f038>

Selecting: 0x2fe8ed0: i64 = Register %vreg2 [ID=3]

=> 0x2fe8ed0: i64 = Register %vreg2

Selecting: 0x2fe9bd0: i64 = Register %vreg0 [ORD=30] [ID=1]

=> 0x2fe9bd0: i64 = Register %vreg0 [ORD=30]

Selecting: 0x2fbf468: ch = EntryToken [ORD=30] [ID=0]

=> 0x2fbf468: ch = EntryToken [ORD=30]

===== Instruction selection ends:
Selected selection DAG: BB#3 'atol:while.body'
SelectionDAG has 10 nodes:
  0x2fbf468: ch = EntryToken [ORD=30]

  0x2fe6250: i32 = Register %noreg

  0x2fe98d0: i64 = Register %noreg

    0x3004220: ch = BasicBlock<while.cond 0x300f038>

      0x2fbf468: <multiple use>
      0x2fe8ed0: i64 = Register %vreg2

          0x2fbf468: <multiple use>
          0x2fe9bd0: i64 = Register %vreg0 [ORD=30]

        0x2fe97d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=30]

      0x2fe6550: i64,i32 = INC64r 0x2fe97d0 [ORD=30]

    0x3004020: ch = CopyToReg 0x2fbf468, 0x2fe8ed0, 0x2fe6550

  0x2fe95d0: ch = JMP64pcrel32 0x3004220, 0x3004020


********** List Scheduling BB#3 'while.body' **********
SU(0): 0x2fe95d0: ch = JMP64pcrel32 0x3004220, 0x3004020 [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x3004020: ch = CopyToReg 0x2fbf468, 0x2fe8ed0, 0x2fe6550 [ID=1]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(2): Latency=1
  Successors:
   ch  SU(0): Latency=1

SU(2): 0x2fe6550: i64,i32 = INC64r 0x2fe97d0 [ORD=30] [ID=2]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
   val SU(3): Latency=1
  Successors:
   val SU(1): Latency=1

SU(3): 0x2fe97d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=30] [ID=3]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
   val SU(2): Latency=1


Examining Available:
Height 0: SU(0): 0x2fe95d0: ch = JMP64pcrel32 0x3004220, 0x3004020 [ID=0]


*** Scheduling [0]: SU(0): 0x2fe95d0: ch = JMP64pcrel32 0x3004220, 0x3004020 [ID=0]


Examining Available:
Height 1: SU(1): 0x3004020: ch = CopyToReg 0x2fbf468, 0x2fe8ed0, 0x2fe6550 [ID=1]


*** Scheduling [1]: SU(1): 0x3004020: ch = CopyToReg 0x2fbf468, 0x2fe8ed0, 0x2fe6550 [ID=1]

GR64: 1 / 12

Examining Available:
Height 2: SU(2): 0x2fe6550: i64,i32 = INC64r 0x2fe97d0 [ORD=30] [ID=2]


*** Scheduling [2]: SU(2): 0x2fe6550: i64,i32 = INC64r 0x2fe97d0 [ORD=30] [ID=2]

GR64: 1 / 12

Examining Available:
Height 3: SU(3): 0x2fe97d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=30] [ID=3]


*** Scheduling [3]: SU(3): 0x2fe97d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=30] [ID=3]

*** Final schedule ***
SU(3): 0x2fe97d0: i64,ch = CopyFromReg 0x2fbf468, 0x2fe9bd0 [ORD=30] [ID=3]

SU(2): 0x2fe6550: i64,i32 = INC64r 0x2fe97d0 [ORD=30] [ID=2]

SU(1): 0x3004020: ch = CopyToReg 0x2fbf468, 0x2fe8ed0, 0x2fe6550 [ID=1]

SU(0): 0x2fe95d0: ch = JMP64pcrel32 0x3004220, 0x3004020 [ID=0]


Total amount of phi nodes to update: 1
Node 0 : (0x300f0e0, 2147483650)
# Machine code for function atol: SSA
Function Live Ins: %RDI in %vreg3
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg3<def> = COPY %RDI; GR64:%vreg3
	    Successors according to CFG: BB#1

32B	BB#1: derived from LLVM BB %while.cond
	    Predecessors according to CFG: BB#0 BB#3
48B		%vreg0<def> = PHI %vreg3, <BB#0>, %vreg2, <BB#3>; GR64:%vreg0,%vreg3,%vreg2
64B		%vreg1<def> = MOVZX64rm8 %vreg0, 1, %noreg, 0, %noreg; mem:LD1[%s.addr.0] GR64:%vreg1,%vreg0
80B		CMP64ri8 %vreg1, 32, %EFLAGS<imp-def>; GR64:%vreg1
96B		JE_64 <BB#3>, %EFLAGS<imp-use>
112B		JMP64pcrel32 <BB#2>
	    Successors according to CFG: BB#3(62) BB#2(62)

128B	BB#2: derived from LLVM BB %lor.rhs.i
	    Predecessors according to CFG: BB#1
144B		%vreg4<def,tied1> = SHL64ri %vreg1<tied0>, 56, %EFLAGS<imp-def,dead>; GR64:%vreg4,%vreg1
160B		%vreg5<def,tied1> = SAR64ri %vreg4<tied0>, 56, %EFLAGS<imp-def,dead>; GR64:%vreg5,%vreg4
176B		%vreg6<def,tied1> = ADD64ri8 %vreg5<tied0>, -9, %EFLAGS<imp-def,dead>; GR64:%vreg6,%vreg5
192B		CMP64ri8 %vreg6<kill>, 4, %EFLAGS<imp-def>; GR64:%vreg6
208B		JG_64 <BB#4>, %EFLAGS<imp-use>
224B		JMP64pcrel32 <BB#3>
	    Successors according to CFG: BB#3(124) BB#4(4)

240B	BB#3: derived from LLVM BB %while.body
	    Predecessors according to CFG: BB#1 BB#2
256B		%vreg2<def,tied1> = INC64r %vreg0<tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg2,%vreg0
272B		JMP64pcrel32 <BB#1>
	    Successors according to CFG: BB#1

288B	BB#4: derived from LLVM BB %while.end
	    Predecessors according to CFG: BB#2
304B		%vreg7<def> = MOV64r0 %EFLAGS<imp-def,dead>; GR64:%vreg7
320B		%RAX<def> = COPY %vreg7; GR64:%vreg7
336B		RET

# End machine code for function atol.

********** Stack Coloring **********
********** Function: atol
******** Pre-regalloc Machine LICM: atol ********
Entering: while.cond
Entering: while.body
Exiting: while.body
Entering: lor.rhs.i
Entering: entry
Entering: while.cond
Entering: lor.rhs.i
Entering: while.end
Exiting: while.end
Exiting: lor.rhs.i
Entering: while.body
Exiting: while.body
Exiting: while.cond
Exiting: entry
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: atol
********** PROCESS IMPLICIT DEFS **********
********** Function: atol
********** REWRITING TWO-ADDR INSTRS **********
********** Function: atol
	%vreg4<def,tied1> = SHL64ri %vreg1<kill,tied0>, 56, %EFLAGS<imp-def,dead>; GR64:%vreg4,%vreg1
		prepend:	%vreg4<def> = COPY %vreg1; GR64:%vreg4,%vreg1
		rewrite to:	%vreg4<def,tied1> = SHL64ri %vreg4<tied0>, 56, %EFLAGS<imp-def,dead>; GR64:%vreg4
	%vreg5<def,tied1> = SAR64ri %vreg4<kill,tied0>, 56, %EFLAGS<imp-def,dead>; GR64:%vreg5,%vreg4
		prepend:	%vreg5<def> = COPY %vreg4; GR64:%vreg5,%vreg4
		rewrite to:	%vreg5<def,tied1> = SAR64ri %vreg5<tied0>, 56, %EFLAGS<imp-def,dead>; GR64:%vreg5
	%vreg6<def,tied1> = ADD64ri8 %vreg5<kill,tied0>, -9, %EFLAGS<imp-def,dead>; GR64:%vreg6,%vreg5
		prepend:	%vreg6<def> = COPY %vreg5; GR64:%vreg6,%vreg5
		rewrite to:	%vreg6<def,tied1> = ADD64ri8 %vreg6<tied0>, -9, %EFLAGS<imp-def,dead>; GR64:%vreg6
	%vreg2<def,tied1> = INC64r %vreg0<kill,tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg2,%vreg0
		prepend:	%vreg2<def> = COPY %vreg0; GR64:%vreg2,%vreg0
		rewrite to:	%vreg2<def,tied1> = INC64r %vreg2<tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg2
# Machine code for function atol: Post SSA
Function Live Ins: %RDI in %vreg3
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg3<def> = COPY %RDI<kill>; GR64:%vreg3
32B		%vreg8<def> = COPY %vreg3<kill>; GR64:%vreg8,%vreg3
	    Successors according to CFG: BB#1

48B	BB#1: derived from LLVM BB %while.cond
	    Predecessors according to CFG: BB#0 BB#3
64B		%vreg0<def> = COPY %vreg8<kill>; GR64:%vreg0,%vreg8
80B		%vreg1<def> = MOVZX64rm8 %vreg0, 1, %noreg, 0, %noreg; mem:LD1[%s.addr.0] GR64:%vreg1,%vreg0
96B		CMP64ri8 %vreg1, 32, %EFLAGS<imp-def>; GR64:%vreg1
112B		JE_64 <BB#3>, %EFLAGS<imp-use,kill>
128B		JMP64pcrel32 <BB#2>
	    Successors according to CFG: BB#3(62) BB#2(62)

144B	BB#2: derived from LLVM BB %lor.rhs.i
	    Predecessors according to CFG: BB#1
160B		%vreg4<def> = COPY %vreg1<kill>; GR64:%vreg4,%vreg1
176B		%vreg4<def,tied1> = SHL64ri %vreg4<tied0>, 56, %EFLAGS<imp-def,dead>; GR64:%vreg4
192B		%vreg5<def> = COPY %vreg4<kill>; GR64:%vreg5,%vreg4
208B		%vreg5<def,tied1> = SAR64ri %vreg5<tied0>, 56, %EFLAGS<imp-def,dead>; GR64:%vreg5
224B		%vreg6<def> = COPY %vreg5<kill>; GR64:%vreg6,%vreg5
240B		%vreg6<def,tied1> = ADD64ri8 %vreg6<tied0>, -9, %EFLAGS<imp-def,dead>; GR64:%vreg6
256B		CMP64ri8 %vreg6<kill>, 4, %EFLAGS<imp-def>; GR64:%vreg6
272B		JG_64 <BB#4>, %EFLAGS<imp-use,kill>
288B		JMP64pcrel32 <BB#3>
	    Successors according to CFG: BB#3(124) BB#4(4)

304B	BB#3: derived from LLVM BB %while.body
	    Predecessors according to CFG: BB#1 BB#2
320B		%vreg2<def> = COPY %vreg0<kill>; GR64:%vreg2,%vreg0
336B		%vreg2<def,tied1> = INC64r %vreg2<tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg2
352B		%vreg8<def> = COPY %vreg2<kill>; GR64:%vreg8,%vreg2
368B		JMP64pcrel32 <BB#1>
	    Successors according to CFG: BB#1

384B	BB#4: derived from LLVM BB %while.end
	    Predecessors according to CFG: BB#2
400B		%vreg7<def> = MOV64r0 %EFLAGS<imp-def,dead>; GR64:%vreg7
416B		%RAX<def> = COPY %vreg7<kill>; GR64:%vreg7
432B		RET %RAX<imp-use,kill>

# End machine code for function atol.

********** COMPUTING LIVE INTERVALS **********
********** Function: atol
BB#0:		# derived from entry
16B	%vreg3<def> = COPY %RDI<kill>; GR64:%vreg3
		register: %vreg3 +[16r,32r:0)
32B	%vreg8<def> = COPY %vreg3<kill>; GR64:%vreg8,%vreg3
		register: %vreg8 +[32r,48B:0) phi-join +[48B,64r:1)
BB#1:		# derived from while.cond
64B	%vreg0<def> = COPY %vreg8<kill>; GR64:%vreg0,%vreg8
		register: %vreg0 +[64r,144B:0) +[144B,304B:0) +[304B,320r:0)
80B	%vreg1<def> = MOVZX64rm8 %vreg0, 1, %noreg, 0, %noreg; mem:LD1[%s.addr.0] GR64:%vreg1,%vreg0
		register: %vreg1 +[80r,144B:0) +[144B,160r:0)
96B	CMP64ri8 %vreg1, 32, %EFLAGS<imp-def>; GR64:%vreg1
112B	JE_64 <BB#3>, %EFLAGS<imp-use,kill>
128B	JMP64pcrel32 <BB#2>
BB#2:		# derived from lor.rhs.i
160B	%vreg4<def> = COPY %vreg1<kill>; GR64:%vreg4,%vreg1
		register: %vreg4 +[160r,192r:0)
176B	%vreg4<def,tied1> = SHL64ri %vreg4<tied0>, 56, %EFLAGS<imp-def,dead>; GR64:%vreg4
		register: %vreg4 replace range with [160r,176r:1) RESULT: [160r,176r:1)[176r,192r:0)  0@176r 1@160r
192B	%vreg5<def> = COPY %vreg4<kill>; GR64:%vreg5,%vreg4
		register: %vreg5 +[192r,224r:0)
208B	%vreg5<def,tied1> = SAR64ri %vreg5<tied0>, 56, %EFLAGS<imp-def,dead>; GR64:%vreg5
		register: %vreg5 replace range with [192r,208r:1) RESULT: [192r,208r:1)[208r,224r:0)  0@208r 1@192r
224B	%vreg6<def> = COPY %vreg5<kill>; GR64:%vreg6,%vreg5
		register: %vreg6 +[224r,256r:0)
240B	%vreg6<def,tied1> = ADD64ri8 %vreg6<tied0>, -9, %EFLAGS<imp-def,dead>; GR64:%vreg6
		register: %vreg6 replace range with [224r,240r:1) RESULT: [224r,240r:1)[240r,256r:0)  0@240r 1@224r
256B	CMP64ri8 %vreg6<kill>, 4, %EFLAGS<imp-def>; GR64:%vreg6
272B	JG_64 <BB#4>, %EFLAGS<imp-use,kill>
288B	JMP64pcrel32 <BB#3>
BB#3:		# derived from while.body
320B	%vreg2<def> = COPY %vreg0<kill>; GR64:%vreg2,%vreg0
		register: %vreg2 +[320r,352r:0)
336B	%vreg2<def,tied1> = INC64r %vreg2<tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg2
		register: %vreg2 replace range with [320r,336r:1) RESULT: [320r,336r:1)[336r,352r:0)  0@336r 1@320r
352B	%vreg8<def> = COPY %vreg2<kill>; GR64:%vreg8,%vreg2
		register: %vreg8 phi-join +[352r,384B:2)
368B	JMP64pcrel32 <BB#1>
BB#4:		# derived from while.end
400B	%vreg7<def> = MOV64r0 %EFLAGS<imp-def,dead>; GR64:%vreg7
		register: %vreg7 +[400r,416r:0)
416B	%RAX<def> = COPY %vreg7<kill>; GR64:%vreg7
432B	RET %RAX<imp-use,kill>
Computing live-in reg-units in ABI blocks.
0B	BB#0 DIL#0
Created 1 new intervals.
********** INTERVALS **********
DIL = [0B,16r:0)  0@0B-phi
%vreg0 = [64r,320r:0)  0@64r
%vreg1 = [80r,160r:0)  0@80r
%vreg2 = [320r,336r:1)[336r,352r:0)  0@336r 1@320r
%vreg3 = [16r,32r:0)  0@16r
%vreg4 = [160r,176r:1)[176r,192r:0)  0@176r 1@160r
%vreg5 = [192r,208r:1)[208r,224r:0)  0@208r 1@192r
%vreg6 = [224r,240r:1)[240r,256r:0)  0@240r 1@224r
%vreg7 = [400r,416r:0)  0@400r
%vreg8 = [32r,48B:0)[48B,64r:1)[352r,384B:2)  0@32r 1@48B-phi 2@352r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function atol: Post SSA
Function Live Ins: %RDI in %vreg3
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg3<def> = COPY %RDI; GR64:%vreg3
32B		%vreg8<def> = COPY %vreg3<kill>; GR64:%vreg8,%vreg3
	    Successors according to CFG: BB#1

48B	BB#1: derived from LLVM BB %while.cond
	    Predecessors according to CFG: BB#0 BB#3
64B		%vreg0<def> = COPY %vreg8<kill>; GR64:%vreg0,%vreg8
80B		%vreg1<def> = MOVZX64rm8 %vreg0, 1, %noreg, 0, %noreg; mem:LD1[%s.addr.0] GR64:%vreg1,%vreg0
96B		CMP64ri8 %vreg1, 32, %EFLAGS<imp-def>; GR64:%vreg1
112B		JE_64 <BB#3>, %EFLAGS<imp-use,kill>
128B		JMP64pcrel32 <BB#2>
	    Successors according to CFG: BB#3(62) BB#2(62)

144B	BB#2: derived from LLVM BB %lor.rhs.i
	    Predecessors according to CFG: BB#1
160B		%vreg4<def> = COPY %vreg1<kill>; GR64:%vreg4,%vreg1
176B		%vreg4<def,tied1> = SHL64ri %vreg4<tied0>, 56, %EFLAGS<imp-def,dead>; GR64:%vreg4
192B		%vreg5<def> = COPY %vreg4<kill>; GR64:%vreg5,%vreg4
208B		%vreg5<def,tied1> = SAR64ri %vreg5<tied0>, 56, %EFLAGS<imp-def,dead>; GR64:%vreg5
224B		%vreg6<def> = COPY %vreg5<kill>; GR64:%vreg6,%vreg5
240B		%vreg6<def,tied1> = ADD64ri8 %vreg6<tied0>, -9, %EFLAGS<imp-def,dead>; GR64:%vreg6
256B		CMP64ri8 %vreg6<kill>, 4, %EFLAGS<imp-def>; GR64:%vreg6
272B		JG_64 <BB#4>, %EFLAGS<imp-use,kill>
288B		JMP64pcrel32 <BB#3>
	    Successors according to CFG: BB#3(124) BB#4(4)

304B	BB#3: derived from LLVM BB %while.body
	    Predecessors according to CFG: BB#1 BB#2
320B		%vreg2<def> = COPY %vreg0<kill>; GR64:%vreg2,%vreg0
336B		%vreg2<def,tied1> = INC64r %vreg2<tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg2
352B		%vreg8<def> = COPY %vreg2<kill>; GR64:%vreg8,%vreg2
368B		JMP64pcrel32 <BB#1>
	    Successors according to CFG: BB#1

384B	BB#4: derived from LLVM BB %while.end
	    Predecessors according to CFG: BB#2
400B		%vreg7<def> = MOV64r0 %EFLAGS<imp-def,dead>; GR64:%vreg7
416B		%RAX<def> = COPY %vreg7<kill>; GR64:%vreg7
432B		RET %RAX<imp-use,kill>

# End machine code for function atol.

********** COMPUTING LIVE DEBUG VARIABLES: atol **********
********** DEBUG VARIABLES **********
********** SIMPLE REGISTER COALESCING **********
********** Function: atol
********** JOINING INTERVALS ***********
while.cond:
64B	%vreg0<def> = COPY %vreg8<kill>; GR64:%vreg0,%vreg8
	Considering merging to GR64 with %vreg8 in %vreg0
		RHS = %vreg0 [64r,320r:0)  0@64r
		LHS = %vreg8 [32r,48B:0)[48B,64r:1)[352r,384B:2)  0@32r 1@48B-phi 2@352r
		merge %vreg0:0@64r into %vreg8:1@48B --> @48B
		erased:	64r	%vreg0<def> = COPY %vreg8<kill>; GR64:%vreg0,%vreg8
		updated: 80B	%vreg1<def> = MOVZX64rm8 %vreg8, 1, %noreg, 0, %noreg; mem:LD1[%s.addr.0] GR64:%vreg1,%vreg8
		updated: 320B	%vreg2<def> = COPY %vreg8; GR64:%vreg2,%vreg8
	Joined. Result = %vreg8[32r,48B:0)[48B,320r:1)[352r,384B:2)  0@32r 1@48B-phi 2@352r
lor.rhs.i:
160B	%vreg4<def> = COPY %vreg1<kill>; GR64:%vreg4,%vreg1
	Considering merging to GR64 with %vreg1 in %vreg4
		RHS = %vreg1 [80r,160r:0)  0@80r
		LHS = %vreg4 [160r,176r:1)[176r,192r:0)  0@176r 1@160r
		merge %vreg4:1@160r into %vreg1:0@80r --> @80r
		erased:	160r	%vreg4<def> = COPY %vreg1<kill>; GR64:%vreg4,%vreg1
		updated: 80B	%vreg4<def> = MOVZX64rm8 %vreg8, 1, %noreg, 0, %noreg; mem:LD1[%s.addr.0] GR64:%vreg4,%vreg8
		updated: 96B	CMP64ri8 %vreg4, 32, %EFLAGS<imp-def>; GR64:%vreg4
	Joined. Result = %vreg4[80r,176r:1)[176r,192r:0)  0@176r 1@80r
192B	%vreg5<def> = COPY %vreg4; GR64:%vreg5,%vreg4
	Considering merging to GR64 with %vreg4 in %vreg5
		RHS = %vreg4 [80r,176r:1)[176r,192r:0)  0@176r 1@80r
		LHS = %vreg5 [192r,208r:1)[208r,224r:0)  0@208r 1@192r
		merge %vreg5:1@192r into %vreg4:0@176r --> @176r
		erased:	192r	%vreg5<def> = COPY %vreg4; GR64:%vreg5,%vreg4
		updated: 80B	%vreg5<def> = MOVZX64rm8 %vreg8, 1, %noreg, 0, %noreg; mem:LD1[%s.addr.0] GR64:%vreg5,%vreg8
		updated: 176B	%vreg5<def,tied1> = SHL64ri %vreg5<tied0>, 56, %EFLAGS<imp-def,dead>; GR64:%vreg5
		updated: 96B	CMP64ri8 %vreg5, 32, %EFLAGS<imp-def>; GR64:%vreg5
	Joined. Result = %vreg5[80r,176r:2)[176r,208r:1)[208r,224r:0)  0@208r 1@176r 2@80r
224B	%vreg6<def> = COPY %vreg5; GR64:%vreg6,%vreg5
	Considering merging to GR64 with %vreg5 in %vreg6
		RHS = %vreg6 [224r,240r:1)[240r,256r:0)  0@240r 1@224r
		LHS = %vreg5 [80r,176r:2)[176r,208r:1)[208r,224r:0)  0@208r 1@176r 2@80r
		merge %vreg6:1@224r into %vreg5:0@208r --> @208r
		erased:	224r	%vreg6<def> = COPY %vreg5; GR64:%vreg6,%vreg5
		updated: 240B	%vreg5<def,tied1> = ADD64ri8 %vreg5<tied0>, -9, %EFLAGS<imp-def,dead>; GR64:%vreg5
		updated: 256B	CMP64ri8 %vreg5, 4, %EFLAGS<imp-def>; GR64:%vreg5
	Joined. Result = %vreg5[80r,176r:2)[176r,208r:1)[208r,240r:0)[240r,256r:3)  0@208r 1@176r 2@80r 3@240r
while.body:
320B	%vreg2<def> = COPY %vreg8; GR64:%vreg2,%vreg8
	Considering merging to GR64 with %vreg8 in %vreg2
		RHS = %vreg2 [320r,336r:1)[336r,352r:0)  0@336r 1@320r
		LHS = %vreg8 [32r,48B:0)[48B,320r:1)[352r,384B:2)  0@32r 1@48B-phi 2@352r
		merge %vreg8:2@352r into %vreg2:0@336r --> @336r
		merge %vreg2:1@320r into %vreg8:1@48B --> @48B
		erased:	352r	%vreg8<def> = COPY %vreg2<kill>; GR64:%vreg8,%vreg2
		erased:	320r	%vreg2<def> = COPY %vreg8; GR64:%vreg2,%vreg8
		updated: 336B	%vreg8<def,tied1> = INC64r %vreg8<tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg8
	Joined. Result = %vreg8[32r,48B:0)[48B,336r:1)[336r,384B:2)  0@32r 1@48B-phi 2@336r
entry:
16B	%vreg3<def> = COPY %RDI; GR64:%vreg3
	Considering merging %vreg3 with %RDI
	Can only merge into reserved registers.
32B	%vreg8<def> = COPY %vreg3<kill>; GR64:%vreg8,%vreg3
	Considering merging to GR64 with %vreg3 in %vreg8
		RHS = %vreg3 [16r,32r:0)  0@16r
		LHS = %vreg8 [32r,48B:0)[48B,336r:1)[336r,384B:2)  0@32r 1@48B-phi 2@336r
		merge %vreg8:0@32r into %vreg3:0@16r --> @16r
		erased:	32r	%vreg8<def> = COPY %vreg3<kill>; GR64:%vreg8,%vreg3
		updated: 16B	%vreg8<def> = COPY %RDI; GR64:%vreg8
	Joined. Result = %vreg8[16r,48B:0)[48B,336r:1)[336r,384B:2)  0@16r 1@48B-phi 2@336r
while.end:
416B	%RAX<def> = COPY %vreg7<kill>; GR64:%vreg7
	Considering merging %vreg7 with %RAX
	Can only merge into reserved registers.
Remat: %RAX<def> = MOV64r0 %EFLAGS<imp-def,dead>
Shrink: [400r,416r:0)  0@400r
All defs dead: 400r	%vreg7<def,dead> = MOV64r0 %EFLAGS<imp-def,dead>; GR64:%vreg7
Shrunk: [400r,400d:0)  0@400r
Deleting dead def 400r	%vreg7<def,dead> = MOV64r0 %EFLAGS<imp-def,dead>; GR64:%vreg7
Trying to inflate 0 regs.
********** INTERVALS **********
DIL = [0B,16r:0)  0@0B-phi
%vreg5 = [80r,176r:2)[176r,208r:1)[208r,240r:0)[240r,256r:3)  0@208r 1@176r 2@80r 3@240r
%vreg8 = [16r,48B:0)[48B,336r:1)[336r,384B:2)  0@16r 1@48B-phi 2@336r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function atol: Post SSA
Function Live Ins: %RDI in %vreg3
Function Live Outs: %RAX

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg8<def> = COPY %RDI; GR64:%vreg8
	    Successors according to CFG: BB#1

48B	BB#1: derived from LLVM BB %while.cond
	    Predecessors according to CFG: BB#0 BB#3
80B		%vreg5<def> = MOVZX64rm8 %vreg8, 1, %noreg, 0, %noreg; mem:LD1[%s.addr.0] GR64:%vreg5,%vreg8
96B		CMP64ri8 %vreg5, 32, %EFLAGS<imp-def>; GR64:%vreg5
112B		JE_64 <BB#3>, %EFLAGS<imp-use,kill>
128B		JMP64pcrel32 <BB#2>
	    Successors according to CFG: BB#3(62) BB#2(62)

144B	BB#2: derived from LLVM BB %lor.rhs.i
	    Predecessors according to CFG: BB#1
176B		%vreg5<def,tied1> = SHL64ri %vreg5<tied0>, 56, %EFLAGS<imp-def,dead>; GR64:%vreg5
208B		%vreg5<def,tied1> = SAR64ri %vreg5<tied0>, 56, %EFLAGS<imp-def,dead>; GR64:%vreg5
240B		%vreg5<def,tied1> = ADD64ri8 %vreg5<tied0>, -9, %EFLAGS<imp-def,dead>; GR64:%vreg5
256B		CMP64ri8 %vreg5, 4, %EFLAGS<imp-def>; GR64:%vreg5
272B		JG_64 <BB#4>, %EFLAGS<imp-use,kill>
288B		JMP64pcrel32 <BB#3>
	    Successors according to CFG: BB#3(124) BB#4(4)

304B	BB#3: derived from LLVM BB %while.body
	    Predecessors according to CFG: BB#1 BB#2
336B		%vreg8<def,tied1> = INC64r %vreg8<tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg8
368B		JMP64pcrel32 <BB#1>
	    Successors according to CFG: BB#1

384B	BB#4: derived from LLVM BB %while.end
	    Predecessors according to CFG: BB#2
416B		%RAX<def> = MOV64r0 %EFLAGS<imp-def,dead>
432B		RET %RAX<imp-use,kill>

# End machine code for function atol.

********** DEBUG VARIABLES **********
********** Compute Spill Weights **********
********** Function: atol
********** GREEDY REGISTER ALLOCATION **********
********** Function: atol

selectOrSplit GR64:%vreg8 [16r,48B:0)[48B,336r:1)[336r,384B:2)  0@16r 1@48B-phi 2@336r
hints: %RDI
assigning %vreg8 to %RDI: DIL

selectOrSplit GR64:%vreg5 [80r,176r:2)[176r,208r:1)[208r,240r:0)[240r,256r:3)  0@208r 1@176r 2@80r 3@240r
assigning %vreg5 to %RAX: AH AL
********** REWRITE VIRTUAL REGISTERS **********
********** Function: atol
********** REGISTER MAP **********
[%vreg5 -> %RAX] GR64
[%vreg8 -> %RDI] GR64

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI
16B		%vreg8<def> = COPY %RDI; GR64:%vreg8
	    Successors according to CFG: BB#1
> %RDI<def> = COPY %RDI
Deleting identity copy.
48B	BB#1: derived from LLVM BB %while.cond
	    Live Ins: %RDI
	    Predecessors according to CFG: BB#0 BB#3
80B		%vreg5<def> = MOVZX64rm8 %vreg8, 1, %noreg, 0, %noreg; mem:LD1[%s.addr.0] GR64:%vreg5,%vreg8
96B		CMP64ri8 %vreg5, 32, %EFLAGS<imp-def>; GR64:%vreg5
112B		JE_64 <BB#3>, %EFLAGS<imp-use,kill>
128B		JMP64pcrel32 <BB#2>
	    Successors according to CFG: BB#3(62) BB#2(62)
> %RAX<def> = MOVZX64rm8 %RDI, 1, %noreg, 0, %noreg; mem:LD1[%s.addr.0]
> CMP64ri8 %RAX, 32, %EFLAGS<imp-def>
> JE_64 <BB#3>, %EFLAGS<imp-use,kill>
> JMP64pcrel32 <BB#2>
144B	BB#2: derived from LLVM BB %lor.rhs.i
	    Live Ins: %RAX %RDI
	    Predecessors according to CFG: BB#1
176B		%vreg5<def,tied1> = SHL64ri %vreg5<kill,tied0>, 56, %EFLAGS<imp-def,dead>; GR64:%vreg5
208B		%vreg5<def,tied1> = SAR64ri %vreg5<kill,tied0>, 56, %EFLAGS<imp-def,dead>; GR64:%vreg5
240B		%vreg5<def,tied1> = ADD64ri8 %vreg5<kill,tied0>, -9, %EFLAGS<imp-def,dead>; GR64:%vreg5
256B		CMP64ri8 %vreg5<kill>, 4, %EFLAGS<imp-def>; GR64:%vreg5
272B		JG_64 <BB#4>, %EFLAGS<imp-use,kill>
288B		JMP64pcrel32 <BB#3>
	    Successors according to CFG: BB#3(124) BB#4(4)
> %RAX<def,tied1> = SHL64ri %RAX<kill,tied0>, 56, %EFLAGS<imp-def,dead>
> %RAX<def,tied1> = SAR64ri %RAX<kill,tied0>, 56, %EFLAGS<imp-def,dead>
> %RAX<def,tied1> = ADD64ri8 %RAX<kill,tied0>, -9, %EFLAGS<imp-def,dead>
> CMP64ri8 %RAX<kill>, 4, %EFLAGS<imp-def>
> JG_64 <BB#4>, %EFLAGS<imp-use,kill>
> JMP64pcrel32 <BB#3>
304B	BB#3: derived from LLVM BB %while.body
	    Live Ins: %RDI
	    Predecessors according to CFG: BB#1 BB#2
336B		%vreg8<def,tied1> = INC64r %vreg8<kill,tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg8
368B		JMP64pcrel32 <BB#1>
	    Successors according to CFG: BB#1
> %RDI<def,tied1> = INC64r %RDI<kill,tied0>, %EFLAGS<imp-def,dead>
> JMP64pcrel32 <BB#1>
384B	BB#4: derived from LLVM BB %while.end
	    Predecessors according to CFG: BB#2
416B		%RAX<def> = MOV64r0 %EFLAGS<imp-def,dead>
432B		RET %RAX<imp-use>
> %RAX<def> = MOV64r0 %EFLAGS<imp-def,dead>
> RET %RAX<imp-use>
********** EMITTING LIVE DEBUG VARIABLES **********
********** Stack Slot Coloring **********
********** Function: atol
******** Post-regalloc Machine LICM: atol ********

*** Tail-duplicating BB#3

*** Tail-duplicating BB#4
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: atol
RPO[BB#0 derived from LLVM BB entry] = 1
RPO[BB#1 derived from LLVM BB while.cond] = 2
RPO[BB#2 derived from LLVM BB lor.rhs.i] = 3
RPO[BB#4 derived from LLVM BB while.end] = 4
RPO[BB#3 derived from LLVM BB while.body] = 5
POT: BB#3 derived from LLVM BB while.body
POT: BB#4 derived from LLVM BB while.end
POT: BB#2 derived from LLVM BB lor.rhs.i
POT: BB#1 derived from LLVM BB while.cond
doLoop(BB#1 derived from LLVM BB while.cond, BB#3 derived from LLVM BB while.body)
doBlock(BB#1 derived from LLVM BB while.cond)
Frequency(BB#1 derived from LLVM BB while.cond) = 0
Frequency(BB#1 derived from LLVM BB while.cond) = 1024
doBlock(BB#2 derived from LLVM BB lor.rhs.i)
Frequency(BB#2 derived from LLVM BB lor.rhs.i) = 0
Frequency(BB#2 derived from LLVM BB lor.rhs.i) = 512
doBlock(BB#4 derived from LLVM BB while.end)
Frequency(BB#4 derived from LLVM BB while.end) = 0
Frequency(BB#4 derived from LLVM BB while.end) = 16
doBlock(BB#3 derived from LLVM BB while.body)
Frequency(BB#3 derived from LLVM BB while.body) = 0
Frequency(BB#3 derived from LLVM BB while.body) += 512 --> 512
Frequency(BB#3 derived from LLVM BB while.body) += 496 --> 1008
  CycleProb[BB#1 derived from LLVM BB while.cond] += 1008 --> 1008
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#3 derived from LLVM BB while.body)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0
Frequency(BB#0 derived from LLVM BB entry) = 1024
doBlock(BB#1 derived from LLVM BB while.cond)
Frequency(BB#1 derived from LLVM BB while.cond) = 0
Frequency(BB#1 derived from LLVM BB while.cond) += 1024 --> 1024
Frequency(BB#1 derived from LLVM BB while.cond) /= (16 / 1024 = 1.5625%) --> 65536
doBlock(BB#2 derived from LLVM BB lor.rhs.i)
Frequency(BB#2 derived from LLVM BB lor.rhs.i) = 0
Frequency(BB#2 derived from LLVM BB lor.rhs.i) = 32768
doBlock(BB#4 derived from LLVM BB while.end)
Frequency(BB#4 derived from LLVM BB while.end) = 0
Frequency(BB#4 derived from LLVM BB while.end) = 1024
doBlock(BB#3 derived from LLVM BB while.body)
Frequency(BB#3 derived from LLVM BB while.body) = 0
Frequency(BB#3 derived from LLVM BB while.body) += 32768 --> 32768
Frequency(BB#3 derived from LLVM BB while.body) += 31744 --> 64512
Finding best loop top for: BB#1 (derived from LLVM BB 'while.cond')
    header pred: BB#3 (derived from LLVM BB 'while.body'), 1 successors, 64512 freq
    final top: BB#3 (derived from LLVM BB 'while.body')
Attempting merge from: BB#3 (derived from LLVM BB 'while.body')
    BB#1 (derived from LLVM BB 'while.cond') -> 16 / 16 = 100% (prob)
Merging from BB#3 to BB#1
Attempting merge from: BB#1 (derived from LLVM BB 'while.cond')
    BB#3 (derived from LLVM BB 'while.body') -> Already merged!
    BB#2 (derived from LLVM BB 'lor.rhs.i') -> 62 / 124 = 50% (prob)
Merging from BB#1 to BB#2
Attempting merge from: BB#2 (derived from LLVM BB 'lor.rhs.i')
    BB#3 (derived from LLVM BB 'while.body') -> Already merged!
Finished forming chain for header block BB#3
          ... BB#3 (derived from LLVM BB 'while.body')
          ... BB#1 (derived from LLVM BB 'while.cond')
          ... BB#2 (derived from LLVM BB 'lor.rhs.i')
Attempting merge from: BB#0 (derived from LLVM BB 'entry')
    BB#1 (derived from LLVM BB 'while.cond') -> Mid chain!
    BB#3 (derived from LLVM BB 'while.body') -> 64512 (freq)
Merging from BB#0 to BB#3
Attempting merge from: BB#2 (derived from LLVM BB 'lor.rhs.i')
    BB#3 (derived from LLVM BB 'while.body') -> Already merged!
    BB#4 (derived from LLVM BB 'while.end') -> 4 / 128 = 3.125% (prob)
Merging from BB#2 to BB#4
Attempting merge from: BB#4 (derived from LLVM BB 'while.end')
Finished forming chain for header block BB#0
Placing chain BB#0 (derived from LLVM BB 'entry')
          ... BB#3 (derived from LLVM BB 'while.body')
          ... BB#1 (derived from LLVM BB 'while.cond')
          ... BB#2 (derived from LLVM BB 'lor.rhs.i')
          ... BB#4 (derived from LLVM BB 'while.end')
********** FIX EXECUTION DEPENDENCIES: VR128 **********
The instruction being printed 1051 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 902 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 1049 1501 1647 1642 1506 1648 1643 1645 1640The instruction being printed 1643 1501 1647 1642 1506 1648 1643 1645 1640llc: /home/theusurper/llvm/build/lib/Target/X86/InstPrinter/../X86GenAsmWriter.inc:10284: void llvm::X86ATTInstPrinter::printInstruction(const llvm::MCInst*, llvm::raw_ostream&): Assertion `Bits != 0 && "Cannot print this instruction."' failed.
0  llc             0x000000000149a8b9
1  llc             0x000000000149a592
2  libpthread.so.0 0x00007fc7ab562cb0
3  libc.so.6       0x00007fc7aa7b1425 gsignal + 53
4  libc.so.6       0x00007fc7aa7b4b8b abort + 379
5  libc.so.6       0x00007fc7aa7aa0ee
6  libc.so.6       0x00007fc7aa7aa192
7  llc             0x00000000012bcd7f llvm::X86ATTInstPrinter::printInstruction(llvm::MCInst const*, llvm::raw_ostream&) + 247
8  llc             0x00000000012c187d llvm::X86ATTInstPrinter::printInst(llvm::MCInst const*, llvm::raw_ostream&, llvm::StringRef) + 487
9  llc             0x00000000012dea80
10 llc             0x0000000000be919b
11 llc             0x0000000000eb5654 llvm::AsmPrinter::EmitFunctionBody() + 1398
12 llc             0x0000000000bdf105
13 llc             0x0000000000fcc2ad llvm::MachineFunctionPass::runOnFunction(llvm::Function&) + 95
14 llc             0x00000000014254f4 llvm::FPPassManager::runOnFunction(llvm::Function&) + 382
15 llc             0x00000000014256e2 llvm::FPPassManager::runOnModule(llvm::Module&) + 84
16 llc             0x0000000001425a09 llvm::MPPassManager::runOnModule(llvm::Module&) + 505
17 llc             0x0000000001425fe3 llvm::PassManagerImpl::run(llvm::Module&) + 249
18 llc             0x00000000014261f5 llvm::PassManager::run(llvm::Module&) + 39
19 llc             0x00000000007f9d44
20 llc             0x00000000007f8cbc main + 237
21 libc.so.6       0x00007fc7aa79c76d __libc_start_main + 237
22 llc             0x00000000007f85f9
Stack dump:
0.	Program arguments: llc -march=x86-64 -mcpu=CSE502 -debug -O3 libc.c.bc -o libc.c.S 
1.	Running pass 'Function Pass Manager' on module 'libc.c.bc'.
2.	Running pass 'X86 AT&T-Style Assembly Printer' on function '@atol'
