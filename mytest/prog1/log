Args: /var/services/homes/spparmar/llvm/build/Debug+Asserts/bin/llc -O3 hello.c.bc -o hello.c.S1 -debug 
Subtarget features: SSELevel 8, 3DNowLevel 0, 64bit 1
********** Constant Hoisting **********
********** Function: main
---- Branch Probability Info : main ----

Computing probabilities for entry



=== main
Initial selection DAG: BB#0 'main:entry'
SelectionDAG has 28 nodes:
  0x37aed70: i64 = Constant<1>

  0x37af470: i64 = Register %RAX

    0x3786790: ch = EntryToken

    0x37af470: <multiple use>
    0x37aed70: <multiple use>
  0x37af570: ch,glue = CopyToReg 0x3786790, 0x37af470, 0x37aed70 [ORD=2]

  0x37af670: i32 = TargetConstant<9>

  0x37af770: i64 = Register %RDI

    0x37af570: <multiple use>
    0x37af770: <multiple use>
    0x37aed70: <multiple use>
    0x37af570: <multiple use>
  0x37af870: ch,glue = CopyToReg 0x37af570, 0x37af770, 0x37aed70, 0x37af570:1 [ORD=2]

  0x37af970: i64 = Register %RSI

    0x37af870: <multiple use>
    0x37af970: <multiple use>
    0x37aee70: i64 = GlobalAddress<[14 x i8]* @.str> 0 [ORD=2]

    0x37af870: <multiple use>
  0x37afa70: ch,glue = CopyToReg 0x37af870, 0x37af970, 0x37aee70, 0x37af870:1 [ORD=2]

  0x37afb70: i64 = Register %vreg0

    0x37afa70: <multiple use>
    0x37afb70: <multiple use>
    0x37aef70: i64 = Constant<13>

    0x37afa70: <multiple use>
  0x37b1650: ch,glue = CopyToReg 0x37afa70, 0x37afb70, 0x37aef70, 0x37afa70:1 [ORD=2]

  0x37b1850: i32 = TargetConstant<12>

    0x37b1650: <multiple use>
    0x37af070: i64 = TargetExternalSymbol'syscall'

    0x37af170: ch = MDNode<0x3760d00>

    0x37af270: i64 = TargetConstant<25>

    0x37af370: i32 = TargetConstant<10>

    0x37af470: <multiple use>
    0x37af670: <multiple use>
    0x37af470: <multiple use>
    0x37af670: <multiple use>
    0x37af770: <multiple use>
    0x37af670: <multiple use>
    0x37af970: <multiple use>
    0x37b1750: i32 = TargetConstant<2424841>

    0x37afb70: <multiple use>
    0x37b1850: <multiple use>
    0x37b1950: i64 = Register %RCX

    0x37b1850: <multiple use>
    0x37b1a50: i64 = Register %R11

    0x37b1850: <multiple use>
    0x37b1b50: i32 = Register %EFLAGS

    0x37b1650: <multiple use>
  0x37b1c50: ch,glue = inlineasm 0x37b1650, 0x37af070, 0x37af170, 0x37af270, 0x37af370, 0x37af470, 0x37af670, 0x37af470, 0x37af670, 0x37af770, 0x37af670, 0x37af970, 0x37b1750, 0x37afb70, 0x37b1850, 0x37b1950, 0x37b1850, 0x37b1a50, 0x37b1850, 0x37b1b50, 0x37b1650:1 [ORD=2]

      0x37b1c50: <multiple use>
      0x37af470: <multiple use>
      0x37b1c50: <multiple use>
    0x37b1d50: i64,ch,glue = CopyFromReg 0x37b1c50, 0x37af470, 0x37b1c50:1 [ORD=2]

    0x37af470: <multiple use>
    0x37b1e50: i64 = Constant<0>

  0x37b2050: ch,glue = CopyToReg 0x37b1d50:1, 0x37af470, 0x37b1e50 [ORD=3]

    0x37b2050: <multiple use>
    0x37b1f50: i16 = TargetConstant<0>

    0x37af470: <multiple use>
    0x37b2050: <multiple use>
  0x37b2150: ch = X86ISD::RET_FLAG 0x37b2050, 0x37b1f50, 0x37af470, 0x37b2050:1 [ORD=3]


Optimized lowered selection DAG: BB#0 'main:entry'
SelectionDAG has 28 nodes:
  0x37aed70: i64 = Constant<1>

  0x37af470: i64 = Register %RAX

    0x3786790: ch = EntryToken

    0x37af470: <multiple use>
    0x37aed70: <multiple use>
  0x37af570: ch,glue = CopyToReg 0x3786790, 0x37af470, 0x37aed70 [ORD=2]

  0x37af670: i32 = TargetConstant<9>

  0x37af770: i64 = Register %RDI

    0x37af570: <multiple use>
    0x37af770: <multiple use>
    0x37aed70: <multiple use>
    0x37af570: <multiple use>
  0x37af870: ch,glue = CopyToReg 0x37af570, 0x37af770, 0x37aed70, 0x37af570:1 [ORD=2]

  0x37af970: i64 = Register %RSI

    0x37af870: <multiple use>
    0x37af970: <multiple use>
    0x37aee70: i64 = GlobalAddress<[14 x i8]* @.str> 0 [ORD=2]

    0x37af870: <multiple use>
  0x37afa70: ch,glue = CopyToReg 0x37af870, 0x37af970, 0x37aee70, 0x37af870:1 [ORD=2]

  0x37afb70: i64 = Register %vreg0

    0x37afa70: <multiple use>
    0x37afb70: <multiple use>
    0x37aef70: i64 = Constant<13>

    0x37afa70: <multiple use>
  0x37b1650: ch,glue = CopyToReg 0x37afa70, 0x37afb70, 0x37aef70, 0x37afa70:1 [ORD=2]

  0x37b1850: i32 = TargetConstant<12>

    0x37b1650: <multiple use>
    0x37af070: i64 = TargetExternalSymbol'syscall'

    0x37af170: ch = MDNode<0x3760d00>

    0x37af270: i64 = TargetConstant<25>

    0x37af370: i32 = TargetConstant<10>

    0x37af470: <multiple use>
    0x37af670: <multiple use>
    0x37af470: <multiple use>
    0x37af670: <multiple use>
    0x37af770: <multiple use>
    0x37af670: <multiple use>
    0x37af970: <multiple use>
    0x37b1750: i32 = TargetConstant<2424841>

    0x37afb70: <multiple use>
    0x37b1850: <multiple use>
    0x37b1950: i64 = Register %RCX

    0x37b1850: <multiple use>
    0x37b1a50: i64 = Register %R11

    0x37b1850: <multiple use>
    0x37b1b50: i32 = Register %EFLAGS

    0x37b1650: <multiple use>
  0x37b1c50: ch,glue = inlineasm 0x37b1650, 0x37af070, 0x37af170, 0x37af270, 0x37af370, 0x37af470, 0x37af670, 0x37af470, 0x37af670, 0x37af770, 0x37af670, 0x37af970, 0x37b1750, 0x37afb70, 0x37b1850, 0x37b1950, 0x37b1850, 0x37b1a50, 0x37b1850, 0x37b1b50, 0x37b1650:1 [ORD=2]

      0x37b1c50: <multiple use>
      0x37af470: <multiple use>
      0x37b1c50: <multiple use>
    0x37b1d50: i64,ch,glue = CopyFromReg 0x37b1c50, 0x37af470, 0x37b1c50:1 [ORD=2]

    0x37af470: <multiple use>
    0x37b1e50: i64 = Constant<0>

  0x37b2050: ch,glue = CopyToReg 0x37b1d50:1, 0x37af470, 0x37b1e50 [ORD=3]

    0x37b2050: <multiple use>
    0x37b1f50: i16 = TargetConstant<0>

    0x37af470: <multiple use>
    0x37b2050: <multiple use>
  0x37b2150: ch = X86ISD::RET_FLAG 0x37b2050, 0x37b1f50, 0x37af470, 0x37b2050:1 [ORD=3]


Legally typed node: 0x37b1f50: i16 = TargetConstant<0> [ID=0]

Legally typed node: 0x37b1e50: i64 = Constant<0> [ID=0]

Legally typed node: 0x37b1b50: i32 = Register %EFLAGS [ID=0]

Legally typed node: 0x37b1a50: i64 = Register %R11 [ID=0]

Legally typed node: 0x37b1950: i64 = Register %RCX [ID=0]

Legally typed node: 0x37b1850: i32 = TargetConstant<12> [ID=0]

Legally typed node: 0x37b1750: i32 = TargetConstant<2424841> [ID=0]

Legally typed node: 0x37afb70: i64 = Register %vreg0 [ID=0]

Legally typed node: 0x37af970: i64 = Register %RSI [ID=0]

Legally typed node: 0x37af770: i64 = Register %RDI [ID=0]

Legally typed node: 0x37af670: i32 = TargetConstant<9> [ID=0]

Legally typed node: 0x37af470: i64 = Register %RAX [ID=0]

Legally typed node: 0x37af370: i32 = TargetConstant<10> [ID=0]

Legally typed node: 0x37af270: i64 = TargetConstant<25> [ID=0]

Legally typed node: 0x37af170: ch = MDNode<0x3760d00> [ID=0]

Legally typed node: 0x37af070: i64 = TargetExternalSymbol'syscall' [ID=0]

Legally typed node: 0x37aef70: i64 = Constant<13> [ID=0]

Legally typed node: 0x37aee70: i64 = GlobalAddress<[14 x i8]* @.str> 0 [ORD=2] [ID=0]

Legally typed node: 0x37aed70: i64 = Constant<1> [ID=0]

Legally typed node: 0x3786790: ch = EntryToken [ID=0]

Legally typed node: 0x37af570: ch,glue = CopyToReg 0x3786790, 0x37af470, 0x37aed70 [ORD=2] [ID=0]

Legally typed node: 0x37af870: ch,glue = CopyToReg 0x37af570, 0x37af770, 0x37aed70, 0x37af570:1 [ORD=2] [ID=0]

Legally typed node: 0x37afa70: ch,glue = CopyToReg 0x37af870, 0x37af970, 0x37aee70, 0x37af870:1 [ORD=2] [ID=0]

Legally typed node: 0x37b1650: ch,glue = CopyToReg 0x37afa70, 0x37afb70, 0x37aef70, 0x37afa70:1 [ORD=2] [ID=0]

Legally typed node: 0x37b1c50: ch,glue = inlineasm 0x37b1650, 0x37af070, 0x37af170, 0x37af270, 0x37af370, 0x37af470, 0x37af670, 0x37af470, 0x37af670, 0x37af770, 0x37af670, 0x37af970, 0x37b1750, 0x37afb70, 0x37b1850, 0x37b1950, 0x37b1850, 0x37b1a50, 0x37b1850, 0x37b1b50, 0x37b1650:1 [ORD=2] [ID=0]

Legally typed node: 0x37b1d50: i64,ch,glue = CopyFromReg 0x37b1c50, 0x37af470, 0x37b1c50:1 [ORD=2] [ID=0]

Legally typed node: 0x37b2050: ch,glue = CopyToReg 0x37b1d50:1, 0x37af470, 0x37b1e50 [ORD=3] [ID=0]

Legally typed node: 0x37b2150: ch = X86ISD::RET_FLAG 0x37b2050, 0x37b1f50, 0x37af470, 0x37b2050:1 [ORD=3] [ID=0]

Legally typed node: 0x7fff823a8b80: ch = handlenode 0x37b2150 [ID=0]

Type-legalized selection DAG: BB#0 'main:entry'
SelectionDAG has 28 nodes:
  0x37aed70: i64 = Constant<1> [ID=-3]

  0x37af470: i64 = Register %RAX [ID=-3]

    0x3786790: ch = EntryToken [ID=-3]

    0x37af470: <multiple use>
    0x37aed70: <multiple use>
  0x37af570: ch,glue = CopyToReg 0x3786790, 0x37af470, 0x37aed70 [ORD=2] [ID=-3]

  0x37af670: i32 = TargetConstant<9> [ID=-3]

  0x37af770: i64 = Register %RDI [ID=-3]

    0x37af570: <multiple use>
    0x37af770: <multiple use>
    0x37aed70: <multiple use>
    0x37af570: <multiple use>
  0x37af870: ch,glue = CopyToReg 0x37af570, 0x37af770, 0x37aed70, 0x37af570:1 [ORD=2] [ID=-3]

  0x37af970: i64 = Register %RSI [ID=-3]

    0x37af870: <multiple use>
    0x37af970: <multiple use>
    0x37aee70: i64 = GlobalAddress<[14 x i8]* @.str> 0 [ORD=2] [ID=-3]

    0x37af870: <multiple use>
  0x37afa70: ch,glue = CopyToReg 0x37af870, 0x37af970, 0x37aee70, 0x37af870:1 [ORD=2] [ID=-3]

  0x37afb70: i64 = Register %vreg0 [ID=-3]

    0x37afa70: <multiple use>
    0x37afb70: <multiple use>
    0x37aef70: i64 = Constant<13> [ID=-3]

    0x37afa70: <multiple use>
  0x37b1650: ch,glue = CopyToReg 0x37afa70, 0x37afb70, 0x37aef70, 0x37afa70:1 [ORD=2] [ID=-3]

  0x37b1850: i32 = TargetConstant<12> [ID=-3]

    0x37b1650: <multiple use>
    0x37af070: i64 = TargetExternalSymbol'syscall' [ID=-3]

    0x37af170: ch = MDNode<0x3760d00> [ID=-3]

    0x37af270: i64 = TargetConstant<25> [ID=-3]

    0x37af370: i32 = TargetConstant<10> [ID=-3]

    0x37af470: <multiple use>
    0x37af670: <multiple use>
    0x37af470: <multiple use>
    0x37af670: <multiple use>
    0x37af770: <multiple use>
    0x37af670: <multiple use>
    0x37af970: <multiple use>
    0x37b1750: i32 = TargetConstant<2424841> [ID=-3]

    0x37afb70: <multiple use>
    0x37b1850: <multiple use>
    0x37b1950: i64 = Register %RCX [ID=-3]

    0x37b1850: <multiple use>
    0x37b1a50: i64 = Register %R11 [ID=-3]

    0x37b1850: <multiple use>
    0x37b1b50: i32 = Register %EFLAGS [ID=-3]

    0x37b1650: <multiple use>
  0x37b1c50: ch,glue = inlineasm 0x37b1650, 0x37af070, 0x37af170, 0x37af270, 0x37af370, 0x37af470, 0x37af670, 0x37af470, 0x37af670, 0x37af770, 0x37af670, 0x37af970, 0x37b1750, 0x37afb70, 0x37b1850, 0x37b1950, 0x37b1850, 0x37b1a50, 0x37b1850, 0x37b1b50, 0x37b1650:1 [ORD=2] [ID=-3]

      0x37b1c50: <multiple use>
      0x37af470: <multiple use>
      0x37b1c50: <multiple use>
    0x37b1d50: i64,ch,glue = CopyFromReg 0x37b1c50, 0x37af470, 0x37b1c50:1 [ORD=2] [ID=-3]

    0x37af470: <multiple use>
    0x37b1e50: i64 = Constant<0> [ID=-3]

  0x37b2050: ch,glue = CopyToReg 0x37b1d50:1, 0x37af470, 0x37b1e50 [ORD=3] [ID=-3]

    0x37b2050: <multiple use>
    0x37b1f50: i16 = TargetConstant<0> [ID=-3]

    0x37af470: <multiple use>
    0x37b2050: <multiple use>
  0x37b2150: ch = X86ISD::RET_FLAG 0x37b2050, 0x37b1f50, 0x37af470, 0x37b2050:1 [ORD=3] [ID=-3]


Legalized selection DAG: BB#0 'main:entry'
SelectionDAG has 29 nodes:
  0x37aed70: i64 = Constant<1> [ID=1]

  0x37af470: i64 = Register %RAX [ID=8]

  0x37af670: i32 = TargetConstant<9> [ID=9]

  0x37af770: i64 = Register %RDI [ID=10]

  0x37af970: i64 = Register %RSI [ID=11]

  0x37afb70: i64 = Register %vreg0 [ID=12]

  0x37b1850: i32 = TargetConstant<12> [ID=14]

    0x3786790: ch = EntryToken [ID=0]

    0x37af470: <multiple use>
    0x37aed70: <multiple use>
  0x37af570: ch,glue = CopyToReg 0x3786790, 0x37af470, 0x37aed70 [ORD=2] [ID=20]

    0x37af570: <multiple use>
    0x37af770: <multiple use>
    0x37aed70: <multiple use>
    0x37af570: <multiple use>
  0x37af870: ch,glue = CopyToReg 0x37af570, 0x37af770, 0x37aed70, 0x37af570:1 [ORD=2] [ID=21]

    0x37af870: <multiple use>
    0x37af970: <multiple use>
      0x37b2250: i64 = TargetGlobalAddress<[14 x i8]* @.str> 0 [ORD=2]

    0x37b2350: i64 = X86ISD::Wrapper 0x37b2250 [ORD=2]

    0x37af870: <multiple use>
  0x37afa70: ch,glue = CopyToReg 0x37af870, 0x37af970, 0x37b2350, 0x37af870:1 [ORD=2] [ID=22]

    0x37afa70: <multiple use>
    0x37afb70: <multiple use>
    0x37aef70: i64 = Constant<13> [ID=3]

    0x37afa70: <multiple use>
  0x37b1650: ch,glue = CopyToReg 0x37afa70, 0x37afb70, 0x37aef70, 0x37afa70:1 [ORD=2] [ID=23]

    0x37b1650: <multiple use>
    0x37af070: i64 = TargetExternalSymbol'syscall' [ID=4]

    0x37af170: ch = MDNode<0x3760d00> [ID=5]

    0x37af270: i64 = TargetConstant<25> [ID=6]

    0x37af370: i32 = TargetConstant<10> [ID=7]

    0x37af470: <multiple use>
    0x37af670: <multiple use>
    0x37af470: <multiple use>
    0x37af670: <multiple use>
    0x37af770: <multiple use>
    0x37af670: <multiple use>
    0x37af970: <multiple use>
    0x37b1750: i32 = TargetConstant<2424841> [ID=13]

    0x37afb70: <multiple use>
    0x37b1850: <multiple use>
    0x37b1950: i64 = Register %RCX [ID=15]

    0x37b1850: <multiple use>
    0x37b1a50: i64 = Register %R11 [ID=16]

    0x37b1850: <multiple use>
    0x37b1b50: i32 = Register %EFLAGS [ID=17]

    0x37b1650: <multiple use>
  0x37b1c50: ch,glue = inlineasm 0x37b1650, 0x37af070, 0x37af170, 0x37af270, 0x37af370, 0x37af470, 0x37af670, 0x37af470, 0x37af670, 0x37af770, 0x37af670, 0x37af970, 0x37b1750, 0x37afb70, 0x37b1850, 0x37b1950, 0x37b1850, 0x37b1a50, 0x37b1850, 0x37b1b50, 0x37b1650:1 [ORD=2] [ID=24]

      0x37b1c50: <multiple use>
      0x37af470: <multiple use>
      0x37b1c50: <multiple use>
    0x37b1d50: i64,ch,glue = CopyFromReg 0x37b1c50, 0x37af470, 0x37b1c50:1 [ORD=2] [ID=25]

    0x37af470: <multiple use>
    0x37b1e50: i64 = Constant<0> [ID=18]

  0x37b2050: ch,glue = CopyToReg 0x37b1d50:1, 0x37af470, 0x37b1e50 [ORD=3] [ID=26]

    0x37b2050: <multiple use>
    0x37b1f50: i16 = TargetConstant<0> [ID=19]

    0x37af470: <multiple use>
    0x37b2050: <multiple use>
  0x37b2150: ch = X86ISD::RET_FLAG 0x37b2050, 0x37b1f50, 0x37af470, 0x37b2050:1 [ORD=3] [ID=27]


Optimized legalized selection DAG: BB#0 'main:entry'
SelectionDAG has 29 nodes:
  0x37aed70: i64 = Constant<1> [ID=1]

  0x37af470: i64 = Register %RAX [ID=8]

  0x37af670: i32 = TargetConstant<9> [ID=9]

  0x37af770: i64 = Register %RDI [ID=10]

  0x37af970: i64 = Register %RSI [ID=11]

  0x37afb70: i64 = Register %vreg0 [ID=12]

  0x37b1850: i32 = TargetConstant<12> [ID=14]

    0x3786790: ch = EntryToken [ID=0]

    0x37af470: <multiple use>
    0x37aed70: <multiple use>
  0x37af570: ch,glue = CopyToReg 0x3786790, 0x37af470, 0x37aed70 [ORD=2] [ID=20]

    0x37af570: <multiple use>
    0x37af770: <multiple use>
    0x37aed70: <multiple use>
    0x37af570: <multiple use>
  0x37af870: ch,glue = CopyToReg 0x37af570, 0x37af770, 0x37aed70, 0x37af570:1 [ORD=2] [ID=21]

    0x37af870: <multiple use>
    0x37af970: <multiple use>
      0x37b2250: i64 = TargetGlobalAddress<[14 x i8]* @.str> 0 [ORD=2]

    0x37b2350: i64 = X86ISD::Wrapper 0x37b2250 [ORD=2]

    0x37af870: <multiple use>
  0x37afa70: ch,glue = CopyToReg 0x37af870, 0x37af970, 0x37b2350, 0x37af870:1 [ORD=2] [ID=22]

    0x37afa70: <multiple use>
    0x37afb70: <multiple use>
    0x37aef70: i64 = Constant<13> [ID=3]

    0x37afa70: <multiple use>
  0x37b1650: ch,glue = CopyToReg 0x37afa70, 0x37afb70, 0x37aef70, 0x37afa70:1 [ORD=2] [ID=23]

    0x37b1650: <multiple use>
    0x37af070: i64 = TargetExternalSymbol'syscall' [ID=4]

    0x37af170: ch = MDNode<0x3760d00> [ID=5]

    0x37af270: i64 = TargetConstant<25> [ID=6]

    0x37af370: i32 = TargetConstant<10> [ID=7]

    0x37af470: <multiple use>
    0x37af670: <multiple use>
    0x37af470: <multiple use>
    0x37af670: <multiple use>
    0x37af770: <multiple use>
    0x37af670: <multiple use>
    0x37af970: <multiple use>
    0x37b1750: i32 = TargetConstant<2424841> [ID=13]

    0x37afb70: <multiple use>
    0x37b1850: <multiple use>
    0x37b1950: i64 = Register %RCX [ID=15]

    0x37b1850: <multiple use>
    0x37b1a50: i64 = Register %R11 [ID=16]

    0x37b1850: <multiple use>
    0x37b1b50: i32 = Register %EFLAGS [ID=17]

    0x37b1650: <multiple use>
  0x37b1c50: ch,glue = inlineasm 0x37b1650, 0x37af070, 0x37af170, 0x37af270, 0x37af370, 0x37af470, 0x37af670, 0x37af470, 0x37af670, 0x37af770, 0x37af670, 0x37af970, 0x37b1750, 0x37afb70, 0x37b1850, 0x37b1950, 0x37b1850, 0x37b1a50, 0x37b1850, 0x37b1b50, 0x37b1650:1 [ORD=2] [ID=24]

      0x37b1c50: <multiple use>
      0x37af470: <multiple use>
      0x37b1c50: <multiple use>
    0x37b1d50: i64,ch,glue = CopyFromReg 0x37b1c50, 0x37af470, 0x37b1c50:1 [ORD=2] [ID=25]

    0x37af470: <multiple use>
    0x37b1e50: i64 = Constant<0> [ID=18]

  0x37b2050: ch,glue = CopyToReg 0x37b1d50:1, 0x37af470, 0x37b1e50 [ORD=3] [ID=26]

    0x37b2050: <multiple use>
    0x37b1f50: i16 = TargetConstant<0> [ID=19]

    0x37af470: <multiple use>
    0x37b2050: <multiple use>
  0x37b2150: ch = X86ISD::RET_FLAG 0x37b2050, 0x37b1f50, 0x37af470, 0x37b2050:1 [ORD=3] [ID=27]


===== Instruction selection begins: BB#0 'entry'
Selecting: 0x37b2150: ch = X86ISD::RET_FLAG 0x37b2050, 0x37b1f50, 0x37af470, 0x37b2050:1 [ORD=3] [ID=28]

ISEL: Starting pattern match on root node: 0x37b2150: ch = X86ISD::RET_FLAG 0x37b2050, 0x37b1f50, 0x37af470, 0x37b2050:1 [ORD=3] [ID=28]

  Skipped scope entry (due to false predicate) at index 94715, continuing at 94724
  Morphed node: 0x37b2150: ch = RETQ 0x37af470, 0x37b2050, 0x37b2050:1 [ORD=3]

ISEL: Match complete!
=> 0x37b2150: ch = RETQ 0x37af470, 0x37b2050, 0x37b2050:1 [ORD=3]

Selecting: 0x37b2050: ch,glue = CopyToReg 0x37b1d50:1, 0x37af470, 0x37b1e50 [ORD=3] [ID=27]

=> 0x37b2050: ch,glue = CopyToReg 0x37b1d50:1, 0x37af470, 0x37b1e50 [ORD=3]

Selecting: 0x37b1d50: i64,ch,glue = CopyFromReg 0x37b1c50, 0x37af470, 0x37b1c50:1 [ORD=2] [ID=26]

=> 0x37b1d50: i64,ch,glue = CopyFromReg 0x37b1c50, 0x37af470, 0x37b1c50:1 [ORD=2]

Selecting: 0x37b1c50: ch,glue = inlineasm 0x37b1650, 0x37af070, 0x37af170, 0x37af270, 0x37af370, 0x37af470, 0x37af670, 0x37af470, 0x37af670, 0x37af770, 0x37af670, 0x37af970, 0x37b1750, 0x37afb70, 0x37b1850, 0x37b1950, 0x37b1850, 0x37b1a50, 0x37b1850, 0x37b1b50, 0x37b1650:1 [ORD=2] [ID=25]

=> 0x37b1f50: ch,glue = inlineasm 0x37b1650, 0x37af070, 0x37af170, 0x37af270, 0x37af370, 0x37af470, 0x37af670, 0x37af470, 0x37af670, 0x37af770, 0x37af670, 0x37af970, 0x37b1750, 0x37afb70, 0x37b1850, 0x37b1950, 0x37b1850, 0x37b1a50, 0x37b1850, 0x37b1b50, 0x37b1650:1 [ORD=2]

Selecting: 0x37b1650: ch,glue = CopyToReg 0x37afa70, 0x37afb70, 0x37aef70, 0x37afa70:1 [ORD=2] [ID=24]

=> 0x37b1650: ch,glue = CopyToReg 0x37afa70, 0x37afb70, 0x37aef70, 0x37afa70:1 [ORD=2]

Selecting: 0x37afa70: ch,glue = CopyToReg 0x37af870, 0x37af970, 0x37b2350, 0x37af870:1 [ORD=2] [ID=23]

=> 0x37afa70: ch,glue = CopyToReg 0x37af870, 0x37af970, 0x37b2350, 0x37af870:1 [ORD=2]

Selecting: 0x37af870: ch,glue = CopyToReg 0x37af570, 0x37af770, 0x37aed70, 0x37af570:1 [ORD=2] [ID=22]

=> 0x37af870: ch,glue = CopyToReg 0x37af570, 0x37af770, 0x37aed70, 0x37af570:1 [ORD=2]

Selecting: 0x37b2350: i64 = X86ISD::Wrapper 0x37b2250 [ORD=2] [ID=21]

ISEL: Starting pattern match on root node: 0x37b2350: i64 = X86ISD::Wrapper 0x37b2250 [ORD=2] [ID=21]

  Initial Opcode index to 96202
  Created node: 0x37aee70: i32 = MOV32ri64 0x37b2250 [ORD=2]

  Morphed node: 0x37b2350: i64 = SUBREG_TO_REG 0x37b1c50, 0x37aee70, 0x37b2450 [ORD=2]

ISEL: Match complete!
=> 0x37b2350: i64 = SUBREG_TO_REG 0x37b1c50, 0x37aee70, 0x37b2450 [ORD=2]

Selecting: 0x37af570: ch,glue = CopyToReg 0x3786790, 0x37af470, 0x37aed70 [ORD=2] [ID=20]

=> 0x37af570: ch,glue = CopyToReg 0x3786790, 0x37af470, 0x37aed70 [ORD=2]

Selecting: 0x37b2250: i64 = TargetGlobalAddress<[14 x i8]* @.str> 0 [ORD=2] [ID=19]

=> 0x37b2250: i64 = TargetGlobalAddress<[14 x i8]* @.str> 0 [ORD=2]

Selecting: 0x37b1e50: i64 = Constant<0> [ID=17]

ISEL: Starting pattern match on root node: 0x37b1e50: i64 = Constant<0> [ID=17]

  Initial Opcode index to 83838
  Created node: 0x37b3720: i32,i32 = MOV32r0

  Morphed node: 0x37b1e50: i64 = SUBREG_TO_REG 0x37b1c50, 0x37b3720, 0x37b2450

ISEL: Match complete!
=> 0x37b1e50: i64 = SUBREG_TO_REG 0x37b1c50, 0x37b3720, 0x37b2450

Selecting: 0x37b1b50: i32 = Register %EFLAGS [ID=16]

=> 0x37b1b50: i32 = Register %EFLAGS

Selecting: 0x37b1a50: i64 = Register %R11 [ID=15]

=> 0x37b1a50: i64 = Register %R11

Selecting: 0x37b1950: i64 = Register %RCX [ID=14]

=> 0x37b1950: i64 = Register %RCX

Selecting: 0x37b1850: i32 = TargetConstant<12> [ID=13]

=> 0x37b1850: i32 = TargetConstant<12>

Selecting: 0x37b1750: i32 = TargetConstant<2424841> [ID=12]

=> 0x37b1750: i32 = TargetConstant<2424841>

Selecting: 0x37afb70: i64 = Register %vreg0 [ID=11]

=> 0x37afb70: i64 = Register %vreg0

Selecting: 0x37af970: i64 = Register %RSI [ID=10]

=> 0x37af970: i64 = Register %RSI

Selecting: 0x37af770: i64 = Register %RDI [ID=9]

=> 0x37af770: i64 = Register %RDI

Selecting: 0x37af670: i32 = TargetConstant<9> [ID=8]

=> 0x37af670: i32 = TargetConstant<9>

Selecting: 0x37af470: i64 = Register %RAX [ID=7]

=> 0x37af470: i64 = Register %RAX

Selecting: 0x37af370: i32 = TargetConstant<10> [ID=6]

=> 0x37af370: i32 = TargetConstant<10>

Selecting: 0x37af270: i64 = TargetConstant<25> [ID=5]

=> 0x37af270: i64 = TargetConstant<25>

Selecting: 0x37af170: ch = MDNode<0x3760d00> [ID=4]

=> 0x37af170: ch = MDNode<0x3760d00>

Selecting: 0x37af070: i64 = TargetExternalSymbol'syscall' [ID=3]

=> 0x37af070: i64 = TargetExternalSymbol'syscall'

Selecting: 0x37aef70: i64 = Constant<13> [ID=2]

ISEL: Starting pattern match on root node: 0x37aef70: i64 = Constant<13> [ID=2]

  Initial Opcode index to 83838
  Skipped scope entry (due to false predicate) at index 83840, continuing at 83868
  Created node: 0x37b3920: i32 = MOV32ri64 0x37b3820

  Morphed node: 0x37aef70: i64 = SUBREG_TO_REG 0x37b1c50, 0x37b3920, 0x37b2450

ISEL: Match complete!
=> 0x37aef70: i64 = SUBREG_TO_REG 0x37b1c50, 0x37b3920, 0x37b2450

Selecting: 0x37aed70: i64 = Constant<1> [ID=1]

ISEL: Starting pattern match on root node: 0x37aed70: i64 = Constant<1> [ID=1]

  Initial Opcode index to 83838
  Skipped scope entry (due to false predicate) at index 83840, continuing at 83868
  Created node: 0x37b3b20: i32 = MOV32ri64 0x37b3a20

  Morphed node: 0x37aed70: i64 = SUBREG_TO_REG 0x37b1c50, 0x37b3b20, 0x37b2450

ISEL: Match complete!
=> 0x37aed70: i64 = SUBREG_TO_REG 0x37b1c50, 0x37b3b20, 0x37b2450

Selecting: 0x3786790: ch = EntryToken [ID=0]

=> 0x3786790: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#0 'main:entry'
SelectionDAG has 36 nodes:
    0x37b1c50: <multiple use>
      0x37b3a20: i64 = TargetConstant<1>

    0x37b3b20: i32 = MOV32ri64 0x37b3a20

    0x37b2450: <multiple use>
  0x37aed70: i64 = SUBREG_TO_REG 0x37b1c50, 0x37b3b20, 0x37b2450

  0x37af470: i64 = Register %RAX

  0x37af670: i32 = TargetConstant<9>

  0x37af770: i64 = Register %RDI

  0x37af970: i64 = Register %RSI

  0x37afb70: i64 = Register %vreg0

  0x37b1850: i32 = TargetConstant<12>

    0x3786790: ch = EntryToken

    0x37af470: <multiple use>
    0x37aed70: <multiple use>
  0x37af570: ch,glue = CopyToReg 0x3786790, 0x37af470, 0x37aed70 [ORD=2]

    0x37af570: <multiple use>
    0x37af770: <multiple use>
    0x37aed70: <multiple use>
    0x37af570: <multiple use>
  0x37af870: ch,glue = CopyToReg 0x37af570, 0x37af770, 0x37aed70, 0x37af570:1 [ORD=2]

    0x37af870: <multiple use>
    0x37af970: <multiple use>
      0x37b1c50: <multiple use>
        0x37b2250: i64 = TargetGlobalAddress<[14 x i8]* @.str> 0 [ORD=2]

      0x37aee70: i32 = MOV32ri64 0x37b2250 [ORD=2]

      0x37b2450: <multiple use>
    0x37b2350: i64 = SUBREG_TO_REG 0x37b1c50, 0x37aee70, 0x37b2450 [ORD=2]

    0x37af870: <multiple use>
  0x37afa70: ch,glue = CopyToReg 0x37af870, 0x37af970, 0x37b2350, 0x37af870:1 [ORD=2]

    0x37afa70: <multiple use>
    0x37afb70: <multiple use>
      0x37b1c50: <multiple use>
        0x37b3820: i64 = TargetConstant<13>

      0x37b3920: i32 = MOV32ri64 0x37b3820

      0x37b2450: <multiple use>
    0x37aef70: i64 = SUBREG_TO_REG 0x37b1c50, 0x37b3920, 0x37b2450

    0x37afa70: <multiple use>
  0x37b1650: ch,glue = CopyToReg 0x37afa70, 0x37afb70, 0x37aef70, 0x37afa70:1 [ORD=2]

      0x37b1f50: <multiple use>
      0x37af470: <multiple use>
      0x37b1f50: <multiple use>
    0x37b1d50: i64,ch,glue = CopyFromReg 0x37b1f50, 0x37af470, 0x37b1f50:1 [ORD=2]

    0x37af470: <multiple use>
      0x37b1c50: <multiple use>
      0x37b3720: i32,i32 = MOV32r0

      0x37b2450: <multiple use>
    0x37b1e50: i64 = SUBREG_TO_REG 0x37b1c50, 0x37b3720, 0x37b2450

  0x37b2050: ch,glue = CopyToReg 0x37b1d50:1, 0x37af470, 0x37b1e50 [ORD=3]

    0x37b1650: <multiple use>
    0x37af070: i64 = TargetExternalSymbol'syscall'

    0x37af170: ch = MDNode<0x3760d00>

    0x37af270: i64 = TargetConstant<25>

    0x37af370: i32 = TargetConstant<10>

    0x37af470: <multiple use>
    0x37af670: <multiple use>
    0x37af470: <multiple use>
    0x37af670: <multiple use>
    0x37af770: <multiple use>
    0x37af670: <multiple use>
    0x37af970: <multiple use>
    0x37b1750: i32 = TargetConstant<2424841>

    0x37afb70: <multiple use>
    0x37b1850: <multiple use>
    0x37b1950: i64 = Register %RCX

    0x37b1850: <multiple use>
    0x37b1a50: i64 = Register %R11

    0x37b1850: <multiple use>
    0x37b1b50: i32 = Register %EFLAGS

    0x37b1650: <multiple use>
  0x37b1f50: ch,glue = inlineasm 0x37b1650, 0x37af070, 0x37af170, 0x37af270, 0x37af370, 0x37af470, 0x37af670, 0x37af470, 0x37af670, 0x37af770, 0x37af670, 0x37af970, 0x37b1750, 0x37afb70, 0x37b1850, 0x37b1950, 0x37b1850, 0x37b1a50, 0x37b1850, 0x37b1b50, 0x37b1650:1 [ORD=2]

  0x37b1c50: i64 = TargetConstant<0>

  0x37b2450: i32 = TargetConstant<4>

    0x37af470: <multiple use>
    0x37b2050: <multiple use>
    0x37b2050: <multiple use>
  0x37b2150: ch = RETQ 0x37af470, 0x37b2050, 0x37b2050:1 [ORD=3]


********** List Scheduling BB#0 'entry' **********
SU(0): 0x37b2150: ch = RETQ 0x37af470, 0x37b2050, 0x37b2050:1 [ORD=3] [ID=0]

    0x37b2050: ch,glue = CopyToReg 0x37b1d50:1, 0x37af470, 0x37b1e50 [ORD=3] [ID=0]

  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
   ch  SU(3): Latency=1
   val SU(1): Latency=1

SU(1): 0x37b1e50: i64 = SUBREG_TO_REG 0x37b1c50, 0x37b3720, 0x37b2450 [ID=1]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
   val SU(2): Latency=1
  Successors:
   val SU(0): Latency=1

SU(2): 0x37b3720: i32,i32 = MOV32r0 [ID=2]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(1): Latency=1

SU(3): 0x37b1d50: i64,ch,glue = CopyFromReg 0x37b1f50, 0x37af470, 0x37b1f50:1 [ORD=2] [ID=3]

    0x37af570: ch,glue = CopyToReg 0x3786790, 0x37af470, 0x37aed70 [ORD=2] [ID=3]

    0x37af870: ch,glue = CopyToReg 0x37af570, 0x37af770, 0x37aed70, 0x37af570:1 [ORD=2] [ID=3]

    0x37afa70: ch,glue = CopyToReg 0x37af870, 0x37af970, 0x37b2350, 0x37af870:1 [ORD=2] [ID=3]

    0x37b1650: ch,glue = CopyToReg 0x37afa70, 0x37afb70, 0x37aef70, 0x37afa70:1 [ORD=2] [ID=3]

    0x37b1f50: ch,glue = inlineasm 0x37b1650, 0x37af070, 0x37af170, 0x37af270, 0x37af370, 0x37af470, 0x37af670, 0x37af470, 0x37af670, 0x37af770, 0x37af670, 0x37af970, 0x37b1750, 0x37afb70, 0x37b1850, 0x37b1950, 0x37b1850, 0x37b1a50, 0x37b1850, 0x37b1b50, 0x37b1650:1 [ORD=2] [ID=3]

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
   val SU(4): Latency=1
   val SU(6): Latency=1
   val SU(8): Latency=1
  Successors:
   ch  SU(0): Latency=1

SU(4): 0x37aef70: i64 = SUBREG_TO_REG 0x37b1c50, 0x37b3920, 0x37b2450 [ID=4]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(5): Latency=1
  Successors:
   val SU(3): Latency=1

SU(5): 0x37b3920: i32 = MOV32ri64 0x37b3820 [ID=5]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(4): Latency=1

SU(6): 0x37b2350: i64 = SUBREG_TO_REG 0x37b1c50, 0x37aee70, 0x37b2450 [ORD=2] [ID=6]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(7): Latency=1
  Successors:
   val SU(3): Latency=1

SU(7): 0x37aee70: i32 = MOV32ri64 0x37b2250 [ORD=2] [ID=7]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(6): Latency=1

SU(8): 0x37aed70: i64 = SUBREG_TO_REG 0x37b1c50, 0x37b3b20, 0x37b2450 [ID=8]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(9): Latency=1
  Successors:
   val SU(3): Latency=1

SU(9): 0x37b3b20: i32 = MOV32ri64 0x37b3a20 [ID=9]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(8): Latency=1


Examining Available:
Height 0: SU(0): 0x37b2150: ch = RETQ 0x37af470, 0x37b2050, 0x37b2050:1 [ORD=3] [ID=0]

    0x37b2050: ch,glue = CopyToReg 0x37b1d50:1, 0x37af470, 0x37b1e50 [ORD=3] [ID=0]


*** Scheduling [0]: SU(0): 0x37b2150: ch = RETQ 0x37af470, 0x37b2050, 0x37b2050:1 [ORD=3] [ID=0]

    0x37b2050: ch,glue = CopyToReg 0x37b1d50:1, 0x37af470, 0x37b1e50 [ORD=3] [ID=0]


Examining Available:
Height 1: SU(1): 0x37b1e50: i64 = SUBREG_TO_REG 0x37b1c50, 0x37b3720, 0x37b2450 [ID=1]

Height 1: SU(3): 0x37b1d50: i64,ch,glue = CopyFromReg 0x37b1f50, 0x37af470, 0x37b1f50:1 [ORD=2] [ID=3]

    0x37af570: ch,glue = CopyToReg 0x3786790, 0x37af470, 0x37aed70 [ORD=2] [ID=3]

    0x37af870: ch,glue = CopyToReg 0x37af570, 0x37af770, 0x37aed70, 0x37af570:1 [ORD=2] [ID=3]

    0x37afa70: ch,glue = CopyToReg 0x37af870, 0x37af970, 0x37b2350, 0x37af870:1 [ORD=2] [ID=3]

    0x37b1650: ch,glue = CopyToReg 0x37afa70, 0x37afb70, 0x37aef70, 0x37afa70:1 [ORD=2] [ID=3]

    0x37b1f50: ch,glue = inlineasm 0x37b1650, 0x37af070, 0x37af170, 0x37af270, 0x37af370, 0x37af470, 0x37af670, 0x37af470, 0x37af670, 0x37af770, 0x37af670, 0x37af970, 0x37b1750, 0x37afb70, 0x37b1850, 0x37b1950, 0x37b1850, 0x37b1a50, 0x37b1850, 0x37b1b50, 0x37b1650:1 [ORD=2] [ID=3]


*** Scheduling [1]: SU(1): 0x37b1e50: i64 = SUBREG_TO_REG 0x37b1c50, 0x37b3720, 0x37b2450 [ID=1]


Examining Available:
Height 2: SU(2): 0x37b3720: i32,i32 = MOV32r0 [ID=2]

Height 1: SU(3): 0x37b1d50: i64,ch,glue = CopyFromReg 0x37b1f50, 0x37af470, 0x37b1f50:1 [ORD=2] [ID=3]

    0x37af570: ch,glue = CopyToReg 0x3786790, 0x37af470, 0x37aed70 [ORD=2] [ID=3]

    0x37af870: ch,glue = CopyToReg 0x37af570, 0x37af770, 0x37aed70, 0x37af570:1 [ORD=2] [ID=3]

    0x37afa70: ch,glue = CopyToReg 0x37af870, 0x37af970, 0x37b2350, 0x37af870:1 [ORD=2] [ID=3]

    0x37b1650: ch,glue = CopyToReg 0x37afa70, 0x37afb70, 0x37aef70, 0x37afa70:1 [ORD=2] [ID=3]

    0x37b1f50: ch,glue = inlineasm 0x37b1650, 0x37af070, 0x37af170, 0x37af270, 0x37af370, 0x37af470, 0x37af670, 0x37af470, 0x37af670, 0x37af770, 0x37af670, 0x37af970, 0x37b1750, 0x37afb70, 0x37b1850, 0x37b1950, 0x37b1850, 0x37b1a50, 0x37b1850, 0x37b1b50, 0x37b1650:1 [ORD=2] [ID=3]


*** Scheduling [2]: SU(2): 0x37b3720: i32,i32 = MOV32r0 [ID=2]


Examining Available:
Height 1: SU(3): 0x37b1d50: i64,ch,glue = CopyFromReg 0x37b1f50, 0x37af470, 0x37b1f50:1 [ORD=2] [ID=3]

    0x37af570: ch,glue = CopyToReg 0x3786790, 0x37af470, 0x37aed70 [ORD=2] [ID=3]

    0x37af870: ch,glue = CopyToReg 0x37af570, 0x37af770, 0x37aed70, 0x37af570:1 [ORD=2] [ID=3]

    0x37afa70: ch,glue = CopyToReg 0x37af870, 0x37af970, 0x37b2350, 0x37af870:1 [ORD=2] [ID=3]

    0x37b1650: ch,glue = CopyToReg 0x37afa70, 0x37afb70, 0x37aef70, 0x37afa70:1 [ORD=2] [ID=3]

    0x37b1f50: ch,glue = inlineasm 0x37b1650, 0x37af070, 0x37af170, 0x37af270, 0x37af370, 0x37af470, 0x37af670, 0x37af470, 0x37af670, 0x37af770, 0x37af670, 0x37af970, 0x37b1750, 0x37afb70, 0x37b1850, 0x37b1950, 0x37b1850, 0x37b1a50, 0x37b1850, 0x37b1b50, 0x37b1650:1 [ORD=2] [ID=3]


*** Scheduling [3]: SU(3): 0x37b1d50: i64,ch,glue = CopyFromReg 0x37b1f50, 0x37af470, 0x37b1f50:1 [ORD=2] [ID=3]

    0x37af570: ch,glue = CopyToReg 0x3786790, 0x37af470, 0x37aed70 [ORD=2] [ID=3]

    0x37af870: ch,glue = CopyToReg 0x37af570, 0x37af770, 0x37aed70, 0x37af570:1 [ORD=2] [ID=3]

    0x37afa70: ch,glue = CopyToReg 0x37af870, 0x37af970, 0x37b2350, 0x37af870:1 [ORD=2] [ID=3]

    0x37b1650: ch,glue = CopyToReg 0x37afa70, 0x37afb70, 0x37aef70, 0x37afa70:1 [ORD=2] [ID=3]

    0x37b1f50: ch,glue = inlineasm 0x37b1650, 0x37af070, 0x37af170, 0x37af270, 0x37af370, 0x37af470, 0x37af670, 0x37af470, 0x37af670, 0x37af770, 0x37af670, 0x37af970, 0x37b1750, 0x37afb70, 0x37b1850, 0x37b1950, 0x37b1850, 0x37b1a50, 0x37b1850, 0x37b1b50, 0x37b1650:1 [ORD=2] [ID=3]


Examining Available:
Height 4: SU(4): 0x37aef70: i64 = SUBREG_TO_REG 0x37b1c50, 0x37b3920, 0x37b2450 [ID=4]

Height 4: SU(8): 0x37aed70: i64 = SUBREG_TO_REG 0x37b1c50, 0x37b3b20, 0x37b2450 [ID=8]

Height 4: SU(6): 0x37b2350: i64 = SUBREG_TO_REG 0x37b1c50, 0x37aee70, 0x37b2450 [ORD=2] [ID=6]


*** Scheduling [4]: SU(4): 0x37aef70: i64 = SUBREG_TO_REG 0x37b1c50, 0x37b3920, 0x37b2450 [ID=4]


Examining Available:
Height 5: SU(5): 0x37b3920: i32 = MOV32ri64 0x37b3820 [ID=5]

Height 4: SU(8): 0x37aed70: i64 = SUBREG_TO_REG 0x37b1c50, 0x37b3b20, 0x37b2450 [ID=8]

Height 4: SU(6): 0x37b2350: i64 = SUBREG_TO_REG 0x37b1c50, 0x37aee70, 0x37b2450 [ORD=2] [ID=6]


*** Scheduling [5]: SU(5): 0x37b3920: i32 = MOV32ri64 0x37b3820 [ID=5]


Examining Available:
Height 4: SU(8): 0x37aed70: i64 = SUBREG_TO_REG 0x37b1c50, 0x37b3b20, 0x37b2450 [ID=8]

Height 4: SU(6): 0x37b2350: i64 = SUBREG_TO_REG 0x37b1c50, 0x37aee70, 0x37b2450 [ORD=2] [ID=6]


*** Scheduling [6]: SU(8): 0x37aed70: i64 = SUBREG_TO_REG 0x37b1c50, 0x37b3b20, 0x37b2450 [ID=8]


Examining Available:
Height 7: SU(9): 0x37b3b20: i32 = MOV32ri64 0x37b3a20 [ID=9]

Height 4: SU(6): 0x37b2350: i64 = SUBREG_TO_REG 0x37b1c50, 0x37aee70, 0x37b2450 [ORD=2] [ID=6]


*** Scheduling [7]: SU(9): 0x37b3b20: i32 = MOV32ri64 0x37b3a20 [ID=9]


Examining Available:
Height 4: SU(6): 0x37b2350: i64 = SUBREG_TO_REG 0x37b1c50, 0x37aee70, 0x37b2450 [ORD=2] [ID=6]


*** Scheduling [8]: SU(6): 0x37b2350: i64 = SUBREG_TO_REG 0x37b1c50, 0x37aee70, 0x37b2450 [ORD=2] [ID=6]


Examining Available:
Height 9: SU(7): 0x37aee70: i32 = MOV32ri64 0x37b2250 [ORD=2] [ID=7]


*** Scheduling [9]: SU(7): 0x37aee70: i32 = MOV32ri64 0x37b2250 [ORD=2] [ID=7]

*** Final schedule ***
SU(7): 0x37aee70: i32 = MOV32ri64 0x37b2250 [ORD=2] [ID=7]

SU(6): 0x37b2350: i64 = SUBREG_TO_REG 0x37b1c50, 0x37aee70, 0x37b2450 [ORD=2] [ID=6]

SU(9): 0x37b3b20: i32 = MOV32ri64 0x37b3a20 [ID=9]

SU(8): 0x37aed70: i64 = SUBREG_TO_REG 0x37b1c50, 0x37b3b20, 0x37b2450 [ID=8]

SU(5): 0x37b3920: i32 = MOV32ri64 0x37b3820 [ID=5]

SU(4): 0x37aef70: i64 = SUBREG_TO_REG 0x37b1c50, 0x37b3920, 0x37b2450 [ID=4]

SU(3): 0x37b1d50: i64,ch,glue = CopyFromReg 0x37b1f50, 0x37af470, 0x37b1f50:1 [ORD=2] [ID=3]

    0x37af570: ch,glue = CopyToReg 0x3786790, 0x37af470, 0x37aed70 [ORD=2] [ID=3]

    0x37af870: ch,glue = CopyToReg 0x37af570, 0x37af770, 0x37aed70, 0x37af570:1 [ORD=2] [ID=3]

    0x37afa70: ch,glue = CopyToReg 0x37af870, 0x37af970, 0x37b2350, 0x37af870:1 [ORD=2] [ID=3]

    0x37b1650: ch,glue = CopyToReg 0x37afa70, 0x37afb70, 0x37aef70, 0x37afa70:1 [ORD=2] [ID=3]

    0x37b1f50: ch,glue = inlineasm 0x37b1650, 0x37af070, 0x37af170, 0x37af270, 0x37af370, 0x37af470, 0x37af670, 0x37af470, 0x37af670, 0x37af770, 0x37af670, 0x37af970, 0x37b1750, 0x37afb70, 0x37b1850, 0x37b1950, 0x37b1850, 0x37b1a50, 0x37b1850, 0x37b1b50, 0x37b1650:1 [ORD=2] [ID=3]

SU(2): 0x37b3720: i32,i32 = MOV32r0 [ID=2]

SU(1): 0x37b1e50: i64 = SUBREG_TO_REG 0x37b1c50, 0x37b3720, 0x37b2450 [ID=1]

SU(0): 0x37b2150: ch = RETQ 0x37af470, 0x37b2050, 0x37b2050:1 [ORD=3] [ID=0]

    0x37b2050: ch,glue = CopyToReg 0x37b1d50:1, 0x37af470, 0x37b1e50 [ORD=3] [ID=0]


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function main: SSA

BB#0: derived from LLVM BB %entry
	%vreg1<def> = MOV32ri64 <ga:@.str>; GR32:%vreg1
	%vreg2<def> = SUBREG_TO_REG 0, %vreg1<kill>, 4; GR64:%vreg2 GR32:%vreg1
	%vreg3<def> = MOV32ri64 1; GR32:%vreg3
	%vreg4<def> = SUBREG_TO_REG 0, %vreg3<kill>, 4; GR64:%vreg4 GR32:%vreg3
	%vreg5<def> = MOV32ri64 13; GR32:%vreg5
	%vreg0<def> = SUBREG_TO_REG 0, %vreg5<kill>, 4; GR64:%vreg0 GR32:%vreg5
	%RAX<def> = COPY %vreg4; GR64:%vreg4
	%RDI<def> = COPY %vreg4; GR64:%vreg4
	%RSI<def> = COPY %vreg2; GR64:%vreg2
	INLINEASM <es:syscall> [sideeffect] [mayload] [maystore] [attdialect], $0:[regdef], %RAX<imp-def>, $1:[reguse], %RAX, $2:[reguse], %RDI, $3:[reguse], %RSI, $4:[reguse:GR64], %vreg0, $5:[clobber], %RCX<earlyclobber,imp-def>, $6:[clobber], %R11<earlyclobber,imp-def>, $7:[clobber], %EFLAGS<earlyclobber,imp-def>, <<badref>>; GR64:%vreg0
	%vreg6<def> = COPY %RAX; GR64:%vreg6
	%vreg7<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg7
	%vreg8<def> = SUBREG_TO_REG 0, %vreg7<kill>, 4; GR64:%vreg8 GR32:%vreg7
	%RAX<def> = COPY %vreg8; GR64:%vreg8
	RETQ %RAX

# End machine code for function main.

# Machine code for function main: SSA

0B	BB#0: derived from LLVM BB %entry
16B		%vreg1<def> = MOV32ri64 <ga:@.str>; GR32:%vreg1
32B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1<kill>, 4; GR64:%vreg2 GR32:%vreg1
48B		%vreg3<def> = MOV32ri64 1; GR32:%vreg3
64B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3<kill>, 4; GR64:%vreg4 GR32:%vreg3
80B		%vreg5<def> = MOV32ri64 13; GR32:%vreg5
96B		%vreg0<def> = SUBREG_TO_REG 0, %vreg5<kill>, 4; GR64:%vreg0 GR32:%vreg5
112B		%RAX<def> = COPY %vreg4; GR64:%vreg4
128B		%RDI<def> = COPY %vreg4; GR64:%vreg4
144B		%RSI<def> = COPY %vreg2; GR64:%vreg2
160B		INLINEASM <es:syscall> [sideeffect] [mayload] [maystore] [attdialect], $0:[regdef], %RAX<imp-def>, $1:[reguse], %RAX, $2:[reguse], %RDI, $3:[reguse], %RSI, $4:[reguse:GR64], %vreg0, $5:[clobber], %RCX<earlyclobber,imp-def>, $6:[clobber], %R11<earlyclobber,imp-def>, $7:[clobber], %EFLAGS<earlyclobber,imp-def>, <<badref>>; GR64:%vreg0
176B		%vreg6<def> = COPY %RAX; GR64:%vreg6
192B		%vreg7<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg7
208B		%vreg8<def> = SUBREG_TO_REG 0, %vreg7<kill>, 4; GR64:%vreg8 GR32:%vreg7
224B		%RAX<def> = COPY %vreg8; GR64:%vreg8
240B		RETQ %RAX

# End machine code for function main.

********** Stack Coloring **********
********** Function: main
DeadMachineInstructionElim: DELETING: %vreg6<def> = COPY %RAX; GR64:%vreg6
******** Pre-regalloc Machine LICM: main ********
Entering: entry
Exiting: entry
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: main
********** PROCESS IMPLICIT DEFS **********
********** Function: main
********** REWRITING TWO-ADDR INSTRS **********
********** Function: main
# Machine code for function main: Post SSA

0B	BB#0: derived from LLVM BB %entry
16B		%vreg1<def> = MOV32ri64 <ga:@.str>; GR32:%vreg1
32B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1<kill>, 4; GR64:%vreg2 GR32:%vreg1
48B		%vreg3<def> = MOV32ri64 1; GR32:%vreg3
64B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3<kill>, 4; GR64:%vreg4 GR32:%vreg3
80B		%vreg5<def> = MOV32ri64 13; GR32:%vreg5
96B		%vreg0<def> = SUBREG_TO_REG 0, %vreg5<kill>, 4; GR64:%vreg0 GR32:%vreg5
112B		%RAX<def> = COPY %vreg4; GR64:%vreg4
128B		%RDI<def> = COPY %vreg4<kill>; GR64:%vreg4
144B		%RSI<def> = COPY %vreg2<kill>; GR64:%vreg2
160B		INLINEASM <es:syscall> [sideeffect] [mayload] [maystore] [attdialect], $0:[regdef], %RAX<imp-def,dead>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI<kill>, $3:[reguse], %RSI<kill>, $4:[reguse:GR64], %vreg0<kill>, $5:[clobber], %RCX<earlyclobber,imp-def,dead>, $6:[clobber], %R11<earlyclobber,imp-def,dead>, $7:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>; GR64:%vreg0
176B		%vreg7<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg7
192B		%vreg8<def> = SUBREG_TO_REG 0, %vreg7<kill>, 4; GR64:%vreg8 GR32:%vreg7
208B		%RAX<def> = COPY %vreg8<kill>; GR64:%vreg8
224B		RETQ %RAX<kill>

# End machine code for function main.

Computing live-in reg-units in ABI blocks.
Created 0 new intervals.
********** INTERVALS **********
%vreg0 [96r,160r:0)  0@96r
%vreg1 [16r,32r:0)  0@16r
%vreg2 [32r,144r:0)  0@32r
%vreg3 [48r,64r:0)  0@48r
%vreg4 [64r,128r:0)  0@64r
%vreg5 [80r,96r:0)  0@80r
%vreg7 [176r,192r:0)  0@176r
%vreg8 [192r,208r:0)  0@192r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function main: Post SSA

0B	BB#0: derived from LLVM BB %entry
16B		%vreg1<def> = MOV32ri64 <ga:@.str>; GR32:%vreg1
32B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
48B		%vreg3<def> = MOV32ri64 1; GR32:%vreg3
64B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
80B		%vreg5<def> = MOV32ri64 13; GR32:%vreg5
96B		%vreg0<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg0 GR32:%vreg5
112B		%RAX<def> = COPY %vreg4; GR64:%vreg4
128B		%RDI<def> = COPY %vreg4; GR64:%vreg4
144B		%RSI<def> = COPY %vreg2; GR64:%vreg2
160B		INLINEASM <es:syscall> [sideeffect] [mayload] [maystore] [attdialect], $0:[regdef], %RAX<imp-def,dead>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI<kill>, $3:[reguse], %RSI<kill>, $4:[reguse:GR64], %vreg0, $5:[clobber], %RCX<earlyclobber,imp-def,dead>, $6:[clobber], %R11<earlyclobber,imp-def,dead>, $7:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>; GR64:%vreg0
176B		%vreg7<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg7
192B		%vreg8<def> = SUBREG_TO_REG 0, %vreg7, 4; GR64:%vreg8 GR32:%vreg7
208B		%RAX<def> = COPY %vreg8; GR64:%vreg8
224B		RETQ %RAX<kill>

# End machine code for function main.

********** SIMPLE REGISTER COALESCING **********
********** Function: main
********** JOINING INTERVALS ***********
entry:
32B	%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
	Considering merging to GR64_with_sub_8bit with %vreg1 in %vreg2:sub_32bit
		RHS = %vreg1 [16r,32r:0)  0@16r
		LHS = %vreg2 [32r,144r:0)  0@32r
		merge %vreg2:0@32r into %vreg1:0@16r --> @16r
		erased:	32r	%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
AllocationOrder(GR64) = [ %RAX %RCX %RDX %RSI %RDI %R8 %R9 %R10 %R11 %RBX %R14 %R15 %R12 %R13 %RBP ]
AllocationOrder(GR64_with_sub_8bit) = [ %RAX %RCX %RDX %RSI %RDI %R8 %R9 %R10 %R11 %RBX %R14 %R15 %R12 %R13 %RBP ]
		updated: 16B	%vreg2:sub_32bit<def,read-undef> = MOV32ri64 <ga:@.str>; GR64_with_sub_8bit:%vreg2
	Joined. Result = %vreg2 [16r,144r:0)  0@16r
64B	%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
	Considering merging to GR64_with_sub_8bit with %vreg3 in %vreg4:sub_32bit
		RHS = %vreg3 [48r,64r:0)  0@48r
		LHS = %vreg4 [64r,128r:0)  0@64r
		merge %vreg4:0@64r into %vreg3:0@48r --> @48r
		erased:	64r	%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
		updated: 48B	%vreg4:sub_32bit<def,read-undef> = MOV32ri64 1; GR64_with_sub_8bit:%vreg4
	Joined. Result = %vreg4 [48r,128r:0)  0@48r
96B	%vreg0<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg0 GR32:%vreg5
	Considering merging to GR64_with_sub_8bit with %vreg5 in %vreg0:sub_32bit
		RHS = %vreg5 [80r,96r:0)  0@80r
		LHS = %vreg0 [96r,160r:0)  0@96r
		merge %vreg0:0@96r into %vreg5:0@80r --> @80r
		erased:	96r	%vreg0<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg0 GR32:%vreg5
		updated: 80B	%vreg0:sub_32bit<def,read-undef> = MOV32ri64 13; GR64_with_sub_8bit:%vreg0
	Joined. Result = %vreg0 [80r,160r:0)  0@80r
112B	%RAX<def> = COPY %vreg4; GR64_with_sub_8bit:%vreg4
	Considering merging %vreg4 with %RAX
	Can only merge into reserved registers.
Remat: %EAX<def,dead> = MOV32ri64 1, %RAX<imp-def>
Shrink: %vreg4 [48r,128r:0)  0@48r
Shrunk: %vreg4 [48r,128r:0)  0@48r
128B	%RDI<def> = COPY %vreg4; GR64_with_sub_8bit:%vreg4
	Considering merging %vreg4 with %RDI
	Can only merge into reserved registers.
Remat: %EDI<def,dead> = MOV32ri64 1, %RDI<imp-def>
Shrink: %vreg4 [48r,128r:0)  0@48r
All defs dead: 48r	%vreg4:sub_32bit<def,read-undef,dead> = MOV32ri64 1; GR64_with_sub_8bit:%vreg4
Shrunk: %vreg4 [48r,48d:0)  0@48r
Deleting dead def 48r	%vreg4:sub_32bit<def,read-undef,dead> = MOV32ri64 1; GR64_with_sub_8bit:%vreg4
144B	%RSI<def> = COPY %vreg2; GR64_with_sub_8bit:%vreg2
	Considering merging %vreg2 with %RSI
	Can only merge into reserved registers.
Remat: %ESI<def,dead> = MOV32ri64 <ga:@.str>, %RSI<imp-def>
Shrink: %vreg2 [16r,144r:0)  0@16r
All defs dead: 16r	%vreg2:sub_32bit<def,read-undef,dead> = MOV32ri64 <ga:@.str>; GR64_with_sub_8bit:%vreg2
Shrunk: %vreg2 [16r,16d:0)  0@16r
Deleting dead def 16r	%vreg2:sub_32bit<def,read-undef,dead> = MOV32ri64 <ga:@.str>; GR64_with_sub_8bit:%vreg2
192B	%vreg8<def> = SUBREG_TO_REG 0, %vreg7, 4; GR64:%vreg8 GR32:%vreg7
	Considering merging to GR64_with_sub_8bit with %vreg7 in %vreg8:sub_32bit
		RHS = %vreg7 [176r,192r:0)  0@176r
		LHS = %vreg8 [192r,208r:0)  0@192r
		merge %vreg8:0@192r into %vreg7:0@176r --> @176r
		erased:	192r	%vreg8<def> = SUBREG_TO_REG 0, %vreg7, 4; GR64:%vreg8 GR32:%vreg7
		updated: 176B	%vreg8:sub_32bit<def,read-undef> = MOV32r0 %EFLAGS<imp-def,dead>; GR64_with_sub_8bit:%vreg8
	Joined. Result = %vreg8 [176r,208r:0)  0@176r
208B	%RAX<def> = COPY %vreg8; GR64_with_sub_8bit:%vreg8
	Considering merging %vreg8 with %RAX
	Can only merge into reserved registers.
Remat: %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %RAX<imp-def>
Shrink: %vreg8 [176r,208r:0)  0@176r
All defs dead: 176r	%vreg8:sub_32bit<def,read-undef,dead> = MOV32r0 %EFLAGS<imp-def,dead>; GR64_with_sub_8bit:%vreg8
Shrunk: %vreg8 [176r,176d:0)  0@176r
Deleting dead def 176r	%vreg8:sub_32bit<def,read-undef,dead> = MOV32r0 %EFLAGS<imp-def,dead>; GR64_with_sub_8bit:%vreg8
Trying to inflate 0 regs.
********** INTERVALS **********
%vreg0 [80r,160r:0)  0@80r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function main: Post SSA

0B	BB#0: derived from LLVM BB %entry
80B		%vreg0:sub_32bit<def,read-undef> = MOV32ri64 13; GR64_with_sub_8bit:%vreg0
112B		%EAX<def,dead> = MOV32ri64 1, %RAX<imp-def>
128B		%EDI<def,dead> = MOV32ri64 1, %RDI<imp-def>
144B		%ESI<def,dead> = MOV32ri64 <ga:@.str>, %RSI<imp-def>
160B		INLINEASM <es:syscall> [sideeffect] [mayload] [maystore] [attdialect], $0:[regdef], %RAX<imp-def,dead>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI<kill>, $3:[reguse], %RSI<kill>, $4:[reguse:GR64], %vreg0, $5:[clobber], %RCX<earlyclobber,imp-def,dead>, $6:[clobber], %R11<earlyclobber,imp-def,dead>, $7:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>; GR64_with_sub_8bit:%vreg0
208B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %RAX<imp-def>
224B		RETQ %RAX<kill>

# End machine code for function main.

Before MISsched:
# Machine code for function main: Post SSA

BB#0: derived from LLVM BB %entry
	%vreg0:sub_32bit<def,read-undef> = MOV32ri64 13; GR64_with_sub_8bit:%vreg0
	%EAX<def,dead> = MOV32ri64 1, %RAX<imp-def>
	%EDI<def,dead> = MOV32ri64 1, %RDI<imp-def>
	%ESI<def,dead> = MOV32ri64 <ga:@.str>, %RSI<imp-def>
	INLINEASM <es:syscall> [sideeffect] [mayload] [maystore] [attdialect], $0:[regdef], %RAX<imp-def,dead>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI<kill>, $3:[reguse], %RSI<kill>, $4:[reguse:GR64], %vreg0, $5:[clobber], %RCX<earlyclobber,imp-def,dead>, $6:[clobber], %R11<earlyclobber,imp-def,dead>, $7:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>; GR64_with_sub_8bit:%vreg0
	%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %RAX<imp-def>
	RETQ %RAX<kill>

# End machine code for function main.

AllocationOrder(GR32) = [ %EAX %ECX %EDX %ESI %EDI %R8D %R9D %R10D %R11D %EBX %EBP %R14D %R15D %R12D %R13D ]
AllocationOrder(GR16) = [ %AX %CX %DX %SI %DI %R8W %R9W %R10W %R11W %BX %BP %R14W %R15W %R12W %R13W ]
AllocationOrder(GR8) = [ %AL %CL %DL %SIL %DIL %R8B %R9B %R10B %R11B %BL %BPL %R14B %R15B %R12B %R13B ]
********** MI Scheduling **********
main:BB#0 entry
  From: %vreg0:sub_32bit<def,read-undef> = MOV32ri64 13; GR64_with_sub_8bit:%vreg0
    To: RETQ %RAX<kill>
 RegionInstrs: 6 Remaining: 0
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   %vreg0:sub_32bit<def,read-undef> = MOV32ri64 13; GR64_with_sub_8bit:%vreg0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
   val SU(4): Latency=1 Reg=%vreg0

SU(1):   %EAX<def,dead> = MOV32ri64 1, %RAX<imp-def>
  # preds left       : 0
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
   out SU(5): Latency=0
   val SU(4): Latency=1 Reg=%RAX
   out SU(5): Latency=0
   out SU(4): Latency=0

SU(2):   %EDI<def,dead> = MOV32ri64 1, %RDI<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
   val SU(4): Latency=1 Reg=%RDI

SU(3):   %ESI<def,dead> = MOV32ri64 <ga:@.str>, %RSI<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
   val SU(4): Latency=1 Reg=%RSI

SU(4):   INLINEASM <es:syscall> [sideeffect] [mayload] [maystore] [attdialect], $0:[regdef], %RAX<imp-def,dead>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI<kill>, $3:[reguse], %RSI<kill>, $4:[reguse:GR64], %vreg0, $5:[clobber], %RCX<earlyclobber,imp-def,dead>, $6:[clobber], %R11<earlyclobber,imp-def,dead>, $7:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>; GR64_with_sub_8bit:%vreg0
  # preds left       : 5
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 4
  Depth              : 1
  Height             : 3
  Predecessors:
   val SU(0): Latency=1 Reg=%vreg0
   val SU(3): Latency=1 Reg=%RSI
   val SU(2): Latency=1 Reg=%RDI
   val SU(1): Latency=1 Reg=%RAX
   out SU(1): Latency=0
  Successors:
   out SU(5): Latency=0
   antiSU(5): Latency=0
   antiSU(5): Latency=0
   ch  SU(4294967295) *: Latency=3

SU(5):   %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %RAX<imp-def>
  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
   out SU(4): Latency=0
   antiSU(4): Latency=0
   antiSU(4): Latency=0
   out SU(1): Latency=0
   out SU(1): Latency=0
  Successors:
   ch  SU(4294967295) *: Latency=1

Critical Path: 4
Scheduling SU(5) %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %RAX<imp-def>
  Ready @1c
  BotQ.A TopLatency SU(5) 1c
  BotQ.A BotLatency SU(5) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
Scheduling SU(4) INLINEASM <es:syscall> [sideeffect] [mayload] [maystore] [attdialect], $0:[regdef], %RAX<imp-def,dead>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI<kill>, $3:[reguse], %RSI<kill>, $4:[reguse:GR64], %vreg0, $5:[clobber], %RCX<earlyclobber,imp-def,dead>, $6:[clobber], %R11<earlyclobber,imp-def,dead>, $7:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>; GR64_with_sub_8bit:%vreg0
  Ready @3c
  BotQ.A BotLatency SU(4) 3c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
BotQ.A: 0 3 2 1 
  SU(0) ORDER                              
  SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %ESI<def,dead> = MOV32ri64 <ga:@.str>, %RSI<imp-def>
  Ready @4c
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(3) 4c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 4c
  - Latency limited.
BotQ.A: 0 1 2 
  SU(0) ORDER                              
  SU(1) ORDER                              
  SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %EDI<def,dead> = MOV32ri64 1, %RDI<imp-def>
  Ready @4c
  SBPort015 +1x4u
  SBPortAny +1x2u
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 4c
  - Latency limited.
BotQ.A: 0 1 
  SU(0) ORDER                              
  SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %EAX<def,dead> = MOV32ri64 1, %RAX<imp-def>
  Ready @4c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 4c
  - Latency limited.
Scheduling SU(0) %vreg0:sub_32bit<def,read-undef> = MOV32ri64 13; GR64_with_sub_8bit:%vreg0
  Ready @4c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 4c
  - Latency limited.
*** Final schedule for BB#0 ***
SU(0):   %vreg0:sub_32bit<def,read-undef> = MOV32ri64 13; GR64_with_sub_8bit:%vreg0
SU(1):   %EAX<def,dead> = MOV32ri64 1, %RAX<imp-def>
SU(2):   %EDI<def,dead> = MOV32ri64 1, %RDI<imp-def>
SU(3):   %ESI<def,dead> = MOV32ri64 <ga:@.str>, %RSI<imp-def>
SU(4):   INLINEASM <es:syscall> [sideeffect] [mayload] [maystore] [attdialect], $0:[regdef], %RAX<imp-def,dead>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI<kill>, $3:[reguse], %RSI<kill>, $4:[reguse:GR64], %vreg0, $5:[clobber], %RCX<earlyclobber,imp-def,dead>, $6:[clobber], %R11<earlyclobber,imp-def,dead>, $7:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>; GR64_with_sub_8bit:%vreg0
SU(5):   %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %RAX<imp-def>

********** INTERVALS **********
%vreg0 [80r,160r:0)  0@80r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function main: Post SSA

0B	BB#0: derived from LLVM BB %entry
80B		%vreg0:sub_32bit<def,read-undef> = MOV32ri64 13; GR64_with_sub_8bit:%vreg0
112B		%EAX<def,dead> = MOV32ri64 1, %RAX<imp-def>
128B		%EDI<def,dead> = MOV32ri64 1, %RDI<imp-def>
144B		%ESI<def,dead> = MOV32ri64 <ga:@.str>, %RSI<imp-def>
160B		INLINEASM <es:syscall> [sideeffect] [mayload] [maystore] [attdialect], $0:[regdef], %RAX<imp-def,dead>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI<kill>, $3:[reguse], %RSI<kill>, $4:[reguse:GR64], %vreg0, $5:[clobber], %RCX<earlyclobber,imp-def,dead>, $6:[clobber], %R11<earlyclobber,imp-def,dead>, $7:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>; GR64_with_sub_8bit:%vreg0
208B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %RAX<imp-def>
224B		RETQ %RAX<kill>

# End machine code for function main.

RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
********** COMPUTING LIVE DEBUG VARIABLES: main **********
********** DEBUG VARIABLES **********
********** GREEDY REGISTER ALLOCATION **********
********** Function: main
********** Compute Spill Weights **********
********** Function: main
********** INTERVALS **********
%vreg0 [80r,160r:0)  0@80r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function main: Post SSA

0B	BB#0: derived from LLVM BB %entry
80B		%vreg0:sub_32bit<def,read-undef> = MOV32ri64 13; GR64_with_sub_8bit:%vreg0
112B		%EAX<def,dead> = MOV32ri64 1, %RAX<imp-def>
128B		%EDI<def,dead> = MOV32ri64 1, %RDI<imp-def>
144B		%ESI<def,dead> = MOV32ri64 <ga:@.str>, %RSI<imp-def>
160B		INLINEASM <es:syscall> [sideeffect] [mayload] [maystore] [attdialect], $0:[regdef], %RAX<imp-def,dead>, $1:[reguse], %RAX<kill>, $2:[reguse], %RDI<kill>, $3:[reguse], %RSI<kill>, $4:[reguse:GR64], %vreg0, $5:[clobber], %RCX<earlyclobber,imp-def,dead>, $6:[clobber], %R11<earlyclobber,imp-def,dead>, $7:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>; GR64_with_sub_8bit:%vreg0
208B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %RAX<imp-def>
224B		RETQ %RAX<kill>

# End machine code for function main.


selectOrSplit GR64_with_sub_8bit:%vreg0 [80r,160r:0)  0@80r w=2.083333e-03
AllocationOrder(GR64) = [ %RAX %RCX %RDX %RSI %RDI %R8 %R9 %R10 %R11 %RBX %R14 %R15 %R12 %R13 %RBP ]
AllocationOrder(GR64_with_sub_8bit) = [ %RAX %RCX %RDX %RSI %RDI %R8 %R9 %R10 %R11 %RBX %R14 %R15 %R12 %R13 %RBP ]
assigning %vreg0 to %RDX: DH DL
********** REWRITE VIRTUAL REGISTERS **********
********** Function: main
********** REGISTER MAP **********
[%vreg0 -> %RDX] GR64_with_sub_8bit

0B	BB#0: derived from LLVM BB %entry
80B		%vreg0:sub_32bit<def,read-undef> = MOV32ri64 13; GR64_with_sub_8bit:%vreg0
112B		%EAX<def,dead> = MOV32ri64 1, %RAX<imp-def>
128B		%EDI<def,dead> = MOV32ri64 1, %RDI<imp-def>
144B		%ESI<def,dead> = MOV32ri64 <ga:@.str>, %RSI<imp-def>
160B		INLINEASM <es:syscall> [sideeffect] [mayload] [maystore] [attdialect], $0:[regdef], %RAX<imp-def,dead>, $1:[reguse], %RAX, $2:[reguse], %RDI<kill>, $3:[reguse], %RSI<kill>, $4:[reguse:GR64], %vreg0<kill>, $5:[clobber], %RCX<earlyclobber,imp-def,dead>, $6:[clobber], %R11<earlyclobber,imp-def,dead>, $7:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>; GR64_with_sub_8bit:%vreg0
208B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %RAX<imp-def>
224B		RETQ %RAX
> %EDX<def> = MOV32ri64 13, %RDX<imp-def>
> %EAX<def,dead> = MOV32ri64 1, %RAX<imp-def>
> %EDI<def,dead> = MOV32ri64 1, %RDI<imp-def>
> %ESI<def,dead> = MOV32ri64 <ga:@.str>, %RSI<imp-def>
> INLINEASM <es:syscall> [sideeffect] [mayload] [maystore] [attdialect], $0:[regdef], %RAX<imp-def,dead>, $1:[reguse], %RAX, $2:[reguse], %RDI<kill>, $3:[reguse], %RSI<kill>, $4:[reguse:GR64], %RDX<kill>, $5:[clobber], %RCX<earlyclobber,imp-def,dead>, $6:[clobber], %R11<earlyclobber,imp-def,dead>, $7:[clobber], %EFLAGS<earlyclobber,imp-def,dead>, <<badref>>
> %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %RAX<imp-def>
> RETQ %RAX
********** EMITTING LIVE DEBUG VARIABLES **********
********** Stack Slot Coloring **********
********** Function: main
******** Post-regalloc Machine LICM: main ********
MCP: CopyPropagateBlock entry
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: main
RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
********** FIX EXECUTION DEPENDENCIES: VR128 **********
