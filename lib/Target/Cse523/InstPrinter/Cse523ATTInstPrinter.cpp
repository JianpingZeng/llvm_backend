//===-- Cse523ATTInstPrinter.cpp - AT&T assembly instruction printing --------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file includes code for rendering MCInst instances as AT&T-style
// assembly.
//
//===----------------------------------------------------------------------===//

#define DEBUG_TYPE "asm-printer"
#include "Cse523ATTInstPrinter.h"
#include "MCTargetDesc/Cse523BaseInfo.h"
#include "MCTargetDesc/Cse523MCTargetDesc.h"
#include "Cse523InstComments.h"
#include "llvm/MC/MCAsmInfo.h"
#include "llvm/MC/MCExpr.h"
#include "llvm/MC/MCInst.h"
#include "llvm/MC/MCInstrInfo.h"
#include "llvm/MC/MCRegisterInfo.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/Format.h"
#include "llvm/Support/FormattedStream.h"
#include <map>
using namespace llvm;


#if 0
// Include the auto-generated portion of the assembly writer.
#include "Cse523GenAsmWriter.inc"

#else

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void Cse523ATTInstPrinter::printInstruction(const MCInst *MI, raw_ostream &O) {
    static const uint32_t OpInfo[] = {
        0U,	// PHI
        0U,	// INLINEASM
        0U,	// PROLOG_LABEL
        0U,	// EH_LABEL
        0U,	// GC_LABEL
        0U,	// KILL
        0U,	// EXTRACT_SUBREG
        0U,	// INSERT_SUBREG
        0U,	// IMPLICIT_DEF
        0U,	// SUBREG_TO_REG
        0U,	// COPY_TO_REGCLASS
        21U,	// DBG_VALUE
        0U,	// REG_SEQUENCE
        0U,	// COPY
        14U,	// BUNDLE
        31U,	// LIFETIME_START
        1U,	// LIFETIME_END
        0U,	// STACKMAP
        0U,	// PATCHPOINT
        0U
    };

    const char AsmStrs[] = {
        /* 0 */ 'L', 'I', 'F', 'E', 'T', 'I', 'M', 'E', '_', 'E', 'N', 'D', 0,
        /* 13 */ 'B', 'U', 'N', 'D', 'L', 'E', 0,
        /* 20 */ 'D', 'B', 'G', '_', 'V', 'A', 'L', 'U', 'E', 0,
        /* 30 */ 'L', 'I', 'F', 'E', 'T', 'I', 'M', 'E', '_', 'S', 'T', 'A', 'R', 'T', 0,
    };

    O << "\t";

    // Emit the opcode for the instruction.
    uint32_t Bits = OpInfo[MI->getOpcode()];
    assert(Bits != 0 && "Cannot print this instruction.");
    O << AsmStrs+(Bits & 31)-1;


    // Fragment 0 encoded into 0 bits for 1 unique commands.
    // DBG_VALUE, BUNDLE, LIFETIME_START, LIFETIME_END
    return;


}

/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *Cse523ATTInstPrinter::getRegisterName(unsigned RegNo) {
    assert(RegNo && RegNo < 50 && "Invalid register number!");

    static const char AsmStrs[] = {
        /* 0 */ 'c', 'r', '1', '0', 0,
        /* 5 */ 'c', 'r', '0', 0,
        /* 9 */ 'd', 'r', '0', 0,
        /* 13 */ 'c', 'r', '1', '1', 0,
        /* 18 */ 'c', 'r', '1', 0,
        /* 22 */ 'd', 'r', '1', 0,
        /* 26 */ 'c', 'r', '1', '2', 0,
        /* 31 */ 'c', 'r', '2', 0,
        /* 35 */ 'd', 'r', '2', 0,
        /* 39 */ 'c', 'r', '1', '3', 0,
        /* 44 */ 'c', 'r', '3', 0,
        /* 48 */ 'd', 'r', '3', 0,
        /* 52 */ 'c', 'r', '1', '4', 0,
        /* 57 */ 'c', 'r', '4', 0,
        /* 61 */ 'd', 'r', '4', 0,
        /* 65 */ 'c', 'r', '1', '5', 0,
        /* 70 */ 'c', 'r', '5', 0,
        /* 74 */ 'd', 'r', '5', 0,
        /* 78 */ 'c', 'r', '6', 0,
        /* 82 */ 'd', 'r', '6', 0,
        /* 86 */ 'c', 'r', '7', 0,
        /* 90 */ 'd', 'r', '7', 0,
        /* 94 */ 'c', 'r', '8', 0,
        /* 98 */ 'c', 'r', '9', 0,
        /* 102 */ 'r', 'd', 'i', 0,
        /* 106 */ 'r', 's', 'i', 0,
        /* 110 */ 'r', 'b', 'p', 0,
        /* 114 */ 'r', 'i', 'p', 0,
        /* 118 */ 'r', 's', 'p', 0,
        /* 122 */ 'c', 's', 0,
        /* 125 */ 'd', 's', 0,
        /* 128 */ 'e', 's', 0,
        /* 131 */ 'f', 's', 0,
        /* 134 */ 'f', 'l', 'a', 'g', 's', 0,
        /* 140 */ 's', 's', 0,
        /* 143 */ 'r', 'a', 'x', 0,
        /* 147 */ 'r', 'b', 'x', 0,
        /* 151 */ 'r', 'c', 'x', 0,
        /* 155 */ 'r', 'd', 'x', 0,
        /* 159 */ 'r', 'i', 'z', 0,
    };

    static const uint32_t RegAsmOffset[] = {
        122, 125, 128, 131, 137, 143, 110, 147, 151, 102, 155, 134, 114, 159, 
        106, 118, 140, 5, 18, 31, 44, 57, 70, 78, 86, 94, 98, 0, 
        13, 26, 39, 52, 65, 9, 22, 35, 48, 61, 74, 82, 90, 95, 
        99, 1, 14, 27, 40, 53, 66, 
    };

    assert (*(AsmStrs+RegAsmOffset[RegNo-1]) &&
            "Invalid alt name index for register!");
    return AsmStrs+RegAsmOffset[RegNo-1];
}

bool Cse523ATTInstPrinter::printAliasInstr(const MCInst *MI, raw_ostream &OS) {
    return false;
}

#endif // #include "Cse523GenAsmWriter.inc"


void Cse523ATTInstPrinter::printRegName(raw_ostream &OS,
        unsigned RegNo) const {
    OS << markup("<reg:")
        << '%' << getRegisterName(RegNo)
        << markup(">");
}

void Cse523ATTInstPrinter::printInst(const MCInst *MI, raw_ostream &OS,
        StringRef Annot) {
    const MCInstrDesc &Desc = MII.get(MI->getOpcode());
    uint64_t TSFlags = Desc.TSFlags;

    if (TSFlags & Cse523II::LOCK)
        OS << "\tlock\n";

    // Try to print any aliases first.
    if (!printAliasInstr(MI, OS))
        printInstruction(MI, OS);

    // Next always print the annotation.
    printAnnotation(OS, Annot);

    // If verbose assembly is enabled, we can print some informative comments.
    if (CommentStream)
        EmitAnyCse523InstComments(MI, *CommentStream, getRegisterName);
}

void Cse523ATTInstPrinter::printSSECC(const MCInst *MI, unsigned Op,
        raw_ostream &O) {
    int64_t Imm = MI->getOperand(Op).getImm() & 0xf;
    switch (Imm) {
        default: llvm_unreachable("Invalid ssecc argument!");
        case    0: O << "eq"; break;
        case    1: O << "lt"; break;
        case    2: O << "le"; break;
        case    3: O << "unord"; break;
        case    4: O << "neq"; break;
        case    5: O << "nlt"; break;
        case    6: O << "nle"; break;
        case    7: O << "ord"; break;
        case    8: O << "eq_uq"; break;
        case    9: O << "nge"; break;
        case  0xa: O << "ngt"; break;
        case  0xb: O << "false"; break;
        case  0xc: O << "neq_oq"; break;
        case  0xd: O << "ge"; break;
        case  0xe: O << "gt"; break;
        case  0xf: O << "true"; break;
    }
}

void Cse523ATTInstPrinter::printAVXCC(const MCInst *MI, unsigned Op,
        raw_ostream &O) {
    int64_t Imm = MI->getOperand(Op).getImm() & 0x1f;
    switch (Imm) {
        default: llvm_unreachable("Invalid avxcc argument!");
        case    0: O << "eq"; break;
        case    1: O << "lt"; break;
        case    2: O << "le"; break;
        case    3: O << "unord"; break;
        case    4: O << "neq"; break;
        case    5: O << "nlt"; break;
        case    6: O << "nle"; break;
        case    7: O << "ord"; break;
        case    8: O << "eq_uq"; break;
        case    9: O << "nge"; break;
        case  0xa: O << "ngt"; break;
        case  0xb: O << "false"; break;
        case  0xc: O << "neq_oq"; break;
        case  0xd: O << "ge"; break;
        case  0xe: O << "gt"; break;
        case  0xf: O << "true"; break;
        case 0x10: O << "eq_os"; break;
        case 0x11: O << "lt_oq"; break;
        case 0x12: O << "le_oq"; break;
        case 0x13: O << "unord_s"; break;
        case 0x14: O << "neq_us"; break;
        case 0x15: O << "nlt_uq"; break;
        case 0x16: O << "nle_uq"; break;
        case 0x17: O << "ord_s"; break;
        case 0x18: O << "eq_us"; break;
        case 0x19: O << "nge_uq"; break;
        case 0x1a: O << "ngt_uq"; break;
        case 0x1b: O << "false_os"; break;
        case 0x1c: O << "neq_os"; break;
        case 0x1d: O << "ge_oq"; break;
        case 0x1e: O << "gt_oq"; break;
        case 0x1f: O << "true_us"; break;
    }
}

void Cse523ATTInstPrinter::printRoundingControl(const MCInst *MI, unsigned Op,
        raw_ostream &O) {
    int64_t Imm = MI->getOperand(Op).getImm() & 0x3;
    switch (Imm) {
        case 0: O << "{rn-sae}"; break;
        case 1: O << "{rd-sae}"; break;
        case 2: O << "{ru-sae}"; break;
        case 3: O << "{rz-sae}"; break;
    }
}
/// printPCRelImm - This is used to print an immediate value that ends up
/// being encoded as a pc-relative value (e.g. for jumps and calls).  These
/// print slightly differently than normal immediates.  For example, a $ is not
/// emitted.
void Cse523ATTInstPrinter::printPCRelImm(const MCInst *MI, unsigned OpNo,
        raw_ostream &O) {
    const MCOperand &Op = MI->getOperand(OpNo);
    if (Op.isImm())
        O << formatImm(Op.getImm());
    else {
        assert(Op.isExpr() && "unknown pcrel immediate operand");
        // If a symbolic branch target was added as a constant expression then print
        // that address in hex.
        const MCConstantExpr *BranchTarget = dyn_cast<MCConstantExpr>(Op.getExpr());
        int64_t Address;
        if (BranchTarget && BranchTarget->EvaluateAsAbsolute(Address)) {
            O << formatHex((uint64_t)Address);
        }
        else {
            // Otherwise, just print the expression.
            O << *Op.getExpr();
        }
    }
}

void Cse523ATTInstPrinter::printOperand(const MCInst *MI, unsigned OpNo,
        raw_ostream &O) {
    const MCOperand &Op = MI->getOperand(OpNo);
    if (Op.isReg()) {
        printRegName(O, Op.getReg());
    } else if (Op.isImm()) {
        // Print Cse523 immediates as signed values.
        O << markup("<imm:")
            << '$' << formatImm((int64_t)Op.getImm())
            << markup(">");

        if (CommentStream && (Op.getImm() > 255 || Op.getImm() < -256))
            *CommentStream << format("imm = 0x%" PRIX64 "\n", (uint64_t)Op.getImm());

    } else {
        assert(Op.isExpr() && "unknown operand kind in printOperand");
        O << markup("<imm:")
            << '$' << *Op.getExpr()
            << markup(">");
    }
}

void Cse523ATTInstPrinter::printMemReference(const MCInst *MI, unsigned Op,
        raw_ostream &O) {
    const MCOperand &BaseReg  = MI->getOperand(Op);
    const MCOperand &IndexReg = MI->getOperand(Op+2);
    const MCOperand &DispSpec = MI->getOperand(Op+3);
    const MCOperand &SegReg = MI->getOperand(Op+4);

    O << markup("<mem:");

    // If this has a segment register, print it.
    if (SegReg.getReg()) {
        printOperand(MI, Op+4, O);
        O << ':';
    }

    if (DispSpec.isImm()) {
        int64_t DispVal = DispSpec.getImm();
        if (DispVal || (!IndexReg.getReg() && !BaseReg.getReg()))
            O << formatImm(DispVal);
    } else {
        assert(DispSpec.isExpr() && "non-immediate displacement for LEA?");
        O << *DispSpec.getExpr();
    }

    if (IndexReg.getReg() || BaseReg.getReg()) {
        O << '(';
        if (BaseReg.getReg())
            printOperand(MI, Op, O);

        if (IndexReg.getReg()) {
            O << ',';
            printOperand(MI, Op+2, O);
            unsigned ScaleVal = MI->getOperand(Op+1).getImm();
            if (ScaleVal != 1) {
                O << ','
                    << markup("<imm:")
                    << ScaleVal // never printed in hex.
                    << markup(">");
            }
        }
        O << ')';
    }

    O << markup(">");
}

void Cse523ATTInstPrinter::printSrcIdx(const MCInst *MI, unsigned Op,
        raw_ostream &O) {
    const MCOperand &SegReg = MI->getOperand(Op+1);

    O << markup("<mem:");

    // If this has a segment register, print it.
    if (SegReg.getReg()) {
        printOperand(MI, Op+1, O);
        O << ':';
    }

    O << "(";
    printOperand(MI, Op, O);
    O << ")";

    O << markup(">");
}

void Cse523ATTInstPrinter::printDstIdx(const MCInst *MI, unsigned Op,
        raw_ostream &O) {
    O << markup("<mem:");

    O << "%es:(";
    printOperand(MI, Op, O);
    O << ")";

    O << markup(">");
}

void Cse523ATTInstPrinter::printMemOffset(const MCInst *MI, unsigned Op,
        raw_ostream &O) {
    const MCOperand &DispSpec = MI->getOperand(Op);
    const MCOperand &SegReg = MI->getOperand(Op+1);

    O << markup("<mem:");

    // If this has a segment register, print it.
    if (SegReg.getReg()) {
        printOperand(MI, Op+1, O);
        O << ':';
    }

    if (DispSpec.isImm()) {
        O << formatImm(DispSpec.getImm());
    } else {
        assert(DispSpec.isExpr() && "non-immediate displacement?");
        O << *DispSpec.getExpr();
    }

    O << markup(">");
}
